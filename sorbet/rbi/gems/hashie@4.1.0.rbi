# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `hashie` gem.
# Please instead update this file by running `bin/tapioca gem hashie`.

module Hashie
  class << self
    # The logger that Hashie uses for reporting errors.
    #
    # @return [Logger]
    def logger; end

    # Sets the logger that Hashie uses for reporting errors.
    #
    # @param logger [Logger] The logger to set as Hashie's logger.
    # @return [void]
    def logger=(logger); end
  end
end

class Hashie::Array < ::Array
  include ::Hashie::Extensions::Array::PrettyInspect
  include ::Hashie::Extensions::RubyVersionCheck
  extend ::Hashie::Extensions::RubyVersionCheck::ClassMethods

  def array_inspect; end
  def dig(*indexes); end
  def inspect; end
end

module Hashie::Extensions; end
module Hashie::Extensions::Array; end

module Hashie::Extensions::Array::PrettyInspect
  def hashie_inspect; end

  class << self
    # @private
    def included(base); end
  end
end

module Hashie::Extensions::KeyConflictWarning
  # Disable the logging of warnings based on keys conflicting keys/methods
  #
  # @api semipublic
  # @raise [CannotDisableMashWarnings]
  # @return [void]
  def disable_warnings(*method_keys); end

  # Checks whether this class disables warnings for conflicting keys/methods
  #
  # @api semipublic
  # @return [Boolean]
  def disable_warnings?(method_key = T.unsafe(nil)); end

  # Returns an array of methods that this class disables warnings for.
  #
  # @api semipublic
  # @return [Boolean]
  def disabled_warnings; end

  # Inheritance hook that sets class configuration when inherited.
  #
  # @api semipublic
  # @return [void]
  def inherited(subclass); end
end

class Hashie::Extensions::KeyConflictWarning::CannotDisableMashWarnings < ::StandardError
  # @return [CannotDisableMashWarnings] a new instance of CannotDisableMashWarnings
  def initialize; end
end

module Hashie::Extensions::PrettyInspect
  def hashie_inspect; end

  class << self
    # @private
    def included(base); end
  end
end

class Hashie::Extensions::RubyVersion
  include ::Comparable

  # @return [RubyVersion] a new instance of RubyVersion
  def initialize(version); end

  def <=>(other); end

  # Returns the value of attribute segments.
  def segments; end

  # Sets the attribute segments
  #
  # @param value the value to set the attribute segments to.
  def segments=(_arg0); end

  private

  def split_to_segments(version); end
end

module Hashie::Extensions::RubyVersionCheck
  mixes_in_class_methods ::Hashie::Extensions::RubyVersionCheck::ClassMethods

  class << self
    # @private
    def included(base); end
  end
end

module Hashie::Extensions::RubyVersionCheck::ClassMethods
  def with_minimum_ruby(version); end

  # @return [Boolean]
  def with_minimum_ruby?(version); end
end

module Hashie::Extensions::StringifyKeys
  extend ::Hashie::Extensions::StringifyKeys::ClassMethods

  # Return a new hash with all keys converted
  # to strings.
  def stringify_keys; end

  # Convert all keys in the hash to strings.
  #
  # @example
  #   test = {:abc => 'def'}
  #   test.stringify_keys!
  #   test # => {'abc' => 'def'}
  def stringify_keys!; end
end

module Hashie::Extensions::StringifyKeys::ClassMethods
  # Return a copy of hash with all keys converted
  # to strings.
  #
  # @param hash [::Hash]
  def stringify_keys(hash); end

  # Convert all keys in the hash to strings.
  #
  # @example
  #   test = {:abc => 'def'}
  #   test.stringify_keys!
  #   test # => {'abc' => 'def'}
  # @param hash [::Hash]
  def stringify_keys!(hash); end

  # Stringify all keys recursively within nested
  # hashes and arrays.
  #
  # @api private
  def stringify_keys_recursively!(object); end
end

# A Hashie Hash is simply a Hash that has convenience
# functions baked in such as stringify_keys that may
# not be available in all libraries.
class Hashie::Hash < ::Hash
  include ::Hashie::Extensions::PrettyInspect
  include ::Hashie::Extensions::StringifyKeys

  def hash_inspect; end
  def inspect; end

  # Converts a mash back to a hash (with stringified or symbolized keys)
  def to_hash(options = T.unsafe(nil)); end

  # The C generator for the json gem doesn't like mashies
  def to_json(*args); end

  # Convert this hash into a Mash
  def to_mash; end

  private

  def flexibly_convert_to_hash(object, options = T.unsafe(nil)); end
  def maybe_convert_to_hash(object, options); end
end

# Mash allows you to create pseudo-objects that have method-like
# accessors for hash keys. This is useful for such implementations
# as an API-accessing library that wants to fake robust objects
# without the overhead of actually doing so. Think of it as OpenStruct
# with some additional goodies.
#
# A Mash will look at the methods you pass it and perform operations
# based on the following rules:
#
# * No punctuation: Returns the value of the hash for that key, or nil if none exists.
# * Assignment (<tt>=</tt>): Sets the attribute of the given method name.
# * Truthiness (<tt>?</tt>): Returns true or false depending on the truthiness of
#   the attribute, or false if the key is not set.
# * Bang (<tt>!</tt>): Forces the existence of this key, used for deep Mashes. Think of it
#   as "touch" for mashes.
# * Under Bang (<tt>_</tt>): Like Bang, but returns a new Mash rather than creating a key.
#   Used to test existance in deep Mashes.
#
# == Basic Example
#
#   mash = Mash.new
#   mash.name? # => false
#   mash.name = "Bob"
#   mash.name # => "Bob"
#   mash.name? # => true
#
# == Hash Conversion  Example
#
#   hash = {:a => {:b => 23, :d => {:e => "abc"}}, :f => [{:g => 44, :h => 29}, 12]}
#   mash = Mash.new(hash)
#   mash.a.b # => 23
#   mash.a.d.e # => "abc"
#   mash.f.first.g # => 44
#   mash.f.last # => 12
#
# == Bang Example
#
#   mash = Mash.new
#   mash.author # => nil
#   mash.author! # => <Mash>
#
#   mash = Mash.new
#   mash.author!.name = "Michael Bleigh"
#   mash.author # => <Mash name="Michael Bleigh">
#
# == Under Bang Example
#
#   mash = Mash.new
#   mash.author # => nil
#   mash.author_ # => <Mash>
#   mash.author_.name # => nil
#
#   mash = Mash.new
#   mash.author_.name = "Michael Bleigh"  (assigned to temp object)
#   mash.author # => <Mash>
class Hashie::Mash < ::Hashie::Hash
  include ::Hashie::Extensions::RubyVersionCheck
  extend ::Hashie::Extensions::RubyVersionCheck::ClassMethods
  extend ::Hashie::Extensions::KeyConflictWarning

  # If you pass in an existing hash, it will
  # convert it to a Mash including recursively
  # descending into arrays and hashes, converting
  # them as well.
  #
  # @return [Mash] a new instance of Mash
  def initialize(source_hash = T.unsafe(nil), default = T.unsafe(nil), &blk); end

  # Retrieves an attribute set in the Mash. Will convert
  # any key passed in to a string before retrieving.
  #
  # @yield [value]
  def [](key); end

  # Sets an attribute in the Mash. Key will be converted to
  # a string before it is set, and Hashes will be converted
  # into Mashes for nesting purposes.
  def []=(key, value, convert = T.unsafe(nil)); end

  # Assigns a value to a key
  def assign_property(name, value); end

  def compact; end

  # Retrieves an attribute set in the Mash. Will convert
  # any key passed in to a string before retrieving.
  #
  # @yield [value]
  def custom_reader(key); end

  # Sets an attribute in the Mash. Key will be converted to
  # a string before it is set, and Hashes will be converted
  # into Mashes for nesting purposes.
  def custom_writer(key, value, convert = T.unsafe(nil)); end

  # Performs a deep_update on a duplicate of the
  # current mash.
  def deep_merge(*other_hashes, &blk); end

  # Recursively merges this mash with the passed
  # in hash, merging each hash in the hierarchy.
  def deep_merge!(*other_hashes, &blk); end

  # Recursively merges this mash with the passed
  # in hash, merging each hash in the hierarchy.
  def deep_update(*other_hashes, &blk); end

  def delete(key); end
  def dig(*keys); end

  # Duplicates the current mash as a new mash.
  def dup; end

  # play nice with ActiveSupport Array#extract_options!
  #
  # @return [Boolean]
  def extractable_options?; end

  def fetch(key, *args); end

  # @return [Boolean]
  def has_key?(key); end

  def hash_inspect; end

  # @return [Boolean]
  def include?(key); end

  # This is the bang method reader, it will return a new Mash
  # if there isn't a value already assigned to the key requested.
  def initializing_reader(key); end

  def inspect; end

  # Returns a new instance of the class it was called on, using its keys as
  # values, and its values as keys. The new values and keys will always be
  # strings.
  def invert; end

  # @return [Boolean]
  def key?(key); end

  # @return [Boolean]
  def member?(key); end

  # Performs a deep_update on a duplicate of the
  # current mash.
  # Alias these lexically so they get the correctly defined
  # #deep_merge and #deep_update based on ruby version.
  def merge(*other_hashes, &blk); end

  # Recursively merges this mash with the passed
  # in hash, merging each hash in the hierarchy.
  def merge!(*other_hashes, &blk); end

  def method_missing(method_name, *args, &blk); end

  # @return [Boolean]
  def prefix_method?(method_name); end

  def regular_dup; end
  def regular_key?(_arg0); end
  def regular_reader(_arg0); end
  def regular_writer(_arg0, _arg1); end

  # Returns a new instance of the class it was called on, containing elements
  # for which the given block returns false.
  def reject(&blk); end

  def replace(other_hash); end

  # another ActiveSupport method, see issue #270
  def reverse_merge(other_hash); end

  # Returns a new instance of the class it was called on, containing elements
  # for which the given block returns true.
  def select(&blk); end

  # Performs a shallow_update on a duplicate of the current mash
  def shallow_merge(other_hash); end

  # Merges (non-recursively) the hash from the argument,
  # changing the receiving hash
  def shallow_update(other_hash); end

  def slice(*keys); end
  def to_module(mash_method_name = T.unsafe(nil)); end
  def to_s; end
  def transform_keys(&blk); end
  def transform_values(&blk); end

  # This is the under bang method reader, it will return a temporary new Mash
  # if there isn't a value already assigned to the key requested.
  def underbang_reader(key); end

  # Recursively merges this mash with the passed
  # in hash, merging each hash in the hierarchy.
  def update(*other_hashes, &blk); end

  def values_at(*keys); end
  def with_accessors!; end

  protected

  def convert_key(key); end
  def convert_value(val, duping = T.unsafe(nil)); end
  def method_name_and_suffix(method_name); end
  def method_suffix(method_name); end

  private

  def _deep_update(other_hash, &blk); end
  def log_built_in_message(method_key); end

  # @return [Boolean]
  def log_collision?(method_key); end

  # @return [Boolean]
  def respond_to_missing?(method_name, *args); end

  class << self
    def [](*_arg0); end

    # @raise [ArgumentError]
    def load(path, options = T.unsafe(nil)); end

    # Creates a new anonymous subclass with key conflict
    # warnings disabled. You may pass an array of method
    # symbols to restrict the disabled warnings to.
    # Hashie::Mash.quiet.new(hash) all warnings disabled.
    # Hashie::Mash.quiet(:zip).new(hash) only zip warning
    # is disabled.
    def quiet(*method_keys); end
  end
end

Hashie::Mash::ALLOWED_SUFFIXES = T.let(T.unsafe(nil), Array)

# A collection of helper methods that can be used throughout the gem.
module Hashie::Utils
  class << self
    # Lists the classes Ruby uses for integers
    #
    # @api private
    # @return [Array<Class>]
    def integer_classes; end

    # Describes a method by where it was defined.
    #
    # @param bound_method [Method] The method to describe.
    # @return [String]
    def method_information(bound_method); end

    # Duplicates a value or returns the value when it is not duplicable
    #
    # @api public
    # @param value [Object] the value to safely duplicate
    # @return [Object] the duplicated value
    def safe_dup(value); end
  end
end
