# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `delayed_job` gem.
# Please instead update this file by running `bin/tapioca gem delayed_job`.

module ActiveRecord
  extend ::ActiveSupport::Autoload

  class << self
    def action_on_strict_loading_violation; end
    def action_on_strict_loading_violation=(_arg0); end
    def application_record_class; end
    def application_record_class=(_arg0); end
    def async_query_executor; end
    def async_query_executor=(_arg0); end
    def default_timezone; end

    # Determines whether to use Time.utc (using :utc) or Time.local (using :local) when pulling
    # dates and times from the database. This is set to :utc by default.
    def default_timezone=(default_timezone); end

    def dump_schema_after_migration; end
    def dump_schema_after_migration=(_arg0); end
    def dump_schemas; end
    def dump_schemas=(_arg0); end
    def eager_load!; end
    def error_on_ignored_order; end
    def error_on_ignored_order=(_arg0); end

    # Returns the version of the currently loaded Active Record as a <tt>Gem::Version</tt>
    def gem_version; end

    def global_executor_concurrency; end

    # Set the +global_executor_concurrency+. This configuration value can only be used
    # with the global thread pool async query executor.
    def global_executor_concurrency=(global_executor_concurrency); end

    def global_thread_pool_async_query_executor; end
    def index_nested_attribute_errors; end
    def index_nested_attribute_errors=(_arg0); end
    def lazily_load_schema_cache; end
    def lazily_load_schema_cache=(_arg0); end
    def legacy_connection_handling; end
    def legacy_connection_handling=(_arg0); end
    def maintain_test_schema; end
    def maintain_test_schema=(_arg0); end
    def query_transformers; end
    def query_transformers=(_arg0); end
    def queues; end
    def queues=(_arg0); end
    def reading_role; end
    def reading_role=(_arg0); end
    def schema_cache_ignored_tables; end
    def schema_cache_ignored_tables=(_arg0); end
    def schema_format; end
    def schema_format=(_arg0); end
    def suppress_multiple_database_warning; end
    def suppress_multiple_database_warning=(_arg0); end
    def timestamped_migrations; end
    def timestamped_migrations=(_arg0); end
    def verbose_query_logs; end
    def verbose_query_logs=(_arg0); end
    def verify_foreign_keys_for_fixtures; end
    def verify_foreign_keys_for_fixtures=(_arg0); end

    # Returns the version of the currently loaded ActiveRecord as a <tt>Gem::Version</tt>
    def version; end

    def warn_on_records_fetched_greater_than; end
    def warn_on_records_fetched_greater_than=(_arg0); end
    def writing_role; end
    def writing_role=(_arg0); end
  end
end

# = Active Record
#
# Active Record objects don't specify their attributes directly, but rather infer them from
# the table definition with which they're linked. Adding, removing, and changing attributes
# and their type is done directly in the database. Any change is instantly reflected in the
# Active Record objects. The mapping that binds a given Active Record class to a certain
# database table will happen automatically in most common cases, but can be overwritten for the uncommon ones.
#
# See the mapping rules in table_name and the full example in link:files/activerecord/README_rdoc.html for more insight.
#
# == Creation
#
# Active Records accept constructor parameters either in a hash or as a block. The hash
# method is especially useful when you're receiving the data from somewhere else, like an
# HTTP request. It works like this:
#
#   user = User.new(name: "David", occupation: "Code Artist")
#   user.name # => "David"
#
# You can also use block initialization:
#
#   user = User.new do |u|
#     u.name = "David"
#     u.occupation = "Code Artist"
#   end
#
# And of course you can just create a bare object and specify the attributes after the fact:
#
#   user = User.new
#   user.name = "David"
#   user.occupation = "Code Artist"
#
# == Conditions
#
# Conditions can either be specified as a string, array, or hash representing the WHERE-part of an SQL statement.
# The array form is to be used when the condition input is tainted and requires sanitization. The string form can
# be used for statements that don't involve tainted data. The hash form works much like the array form, except
# only equality and range is possible. Examples:
#
#   class User < ActiveRecord::Base
#     def self.authenticate_unsafely(user_name, password)
#       where("user_name = '#{user_name}' AND password = '#{password}'").first
#     end
#
#     def self.authenticate_safely(user_name, password)
#       where("user_name = ? AND password = ?", user_name, password).first
#     end
#
#     def self.authenticate_safely_simply(user_name, password)
#       where(user_name: user_name, password: password).first
#     end
#   end
#
# The <tt>authenticate_unsafely</tt> method inserts the parameters directly into the query
# and is thus susceptible to SQL-injection attacks if the <tt>user_name</tt> and +password+
# parameters come directly from an HTTP request. The <tt>authenticate_safely</tt> and
# <tt>authenticate_safely_simply</tt> both will sanitize the <tt>user_name</tt> and +password+
# before inserting them in the query, which will ensure that an attacker can't escape the
# query and fake the login (or worse).
#
# When using multiple parameters in the conditions, it can easily become hard to read exactly
# what the fourth or fifth question mark is supposed to represent. In those cases, you can
# resort to named bind variables instead. That's done by replacing the question marks with
# symbols and supplying a hash with values for the matching symbol keys:
#
#   Company.where(
#     "id = :id AND name = :name AND division = :division AND created_at > :accounting_date",
#     { id: 3, name: "37signals", division: "First", accounting_date: '2005-01-01' }
#   ).first
#
# Similarly, a simple hash without a statement will generate conditions based on equality with the SQL AND
# operator. For instance:
#
#   Student.where(first_name: "Harvey", status: 1)
#   Student.where(params[:student])
#
# A range may be used in the hash to use the SQL BETWEEN operator:
#
#   Student.where(grade: 9..12)
#
# An array may be used in the hash to use the SQL IN operator:
#
#   Student.where(grade: [9,11,12])
#
# When joining tables, nested hashes or keys written in the form 'table_name.column_name'
# can be used to qualify the table name of a particular condition. For instance:
#
#   Student.joins(:schools).where(schools: { category: 'public' })
#   Student.joins(:schools).where('schools.category' => 'public' )
#
# == Overwriting default accessors
#
# All column values are automatically available through basic accessors on the Active Record
# object, but sometimes you want to specialize this behavior. This can be done by overwriting
# the default accessors (using the same name as the attribute) and calling
# +super+ to actually change things.
#
#   class Song < ActiveRecord::Base
#     # Uses an integer of seconds to hold the length of the song
#
#     def length=(minutes)
#       super(minutes.to_i * 60)
#     end
#
#     def length
#       super / 60
#     end
#   end
#
# == Attribute query methods
#
# In addition to the basic accessors, query methods are also automatically available on the Active Record object.
# Query methods allow you to test whether an attribute value is present.
# Additionally, when dealing with numeric values, a query method will return false if the value is zero.
#
# For example, an Active Record User with the <tt>name</tt> attribute has a <tt>name?</tt> method that you can call
# to determine whether the user has a name:
#
#   user = User.new(name: "David")
#   user.name? # => true
#
#   anonymous = User.new(name: "")
#   anonymous.name? # => false
#
# Query methods will also respect any overwrites of default accessors:
#
#   class User
#     # Has admin boolean column
#     def admin
#       false
#     end
#   end
#
#   user.update(admin: true)
#
#   user.read_attribute(:admin)  # => true, gets the column value
#   user[:admin] # => true, also gets the column value
#
#   user.admin   # => false, due to the getter overwrite
#   user.admin?  # => false, due to the getter overwrite
#
# == Accessing attributes before they have been typecasted
#
# Sometimes you want to be able to read the raw attribute data without having the column-determined
# typecast run its course first. That can be done by using the <tt><attribute>_before_type_cast</tt>
# accessors that all attributes have. For example, if your Account model has a <tt>balance</tt> attribute,
# you can call <tt>account.balance_before_type_cast</tt> or <tt>account.id_before_type_cast</tt>.
#
# This is especially useful in validation situations where the user might supply a string for an
# integer field and you want to display the original string back in an error message. Accessing the
# attribute normally would typecast the string to 0, which isn't what you want.
#
# == Dynamic attribute-based finders
#
# Dynamic attribute-based finders are a mildly deprecated way of getting (and/or creating) objects
# by simple queries without turning to SQL. They work by appending the name of an attribute
# to <tt>find_by_</tt> like <tt>Person.find_by_user_name</tt>.
# Instead of writing <tt>Person.find_by(user_name: user_name)</tt>, you can use
# <tt>Person.find_by_user_name(user_name)</tt>.
#
# It's possible to add an exclamation point (!) on the end of the dynamic finders to get them to raise an
# ActiveRecord::RecordNotFound error if they do not return any records,
# like <tt>Person.find_by_last_name!</tt>.
#
# It's also possible to use multiple attributes in the same <tt>find_by_</tt> by separating them with
# "_and_".
#
#  Person.find_by(user_name: user_name, password: password)
#  Person.find_by_user_name_and_password(user_name, password) # with dynamic finder
#
# It's even possible to call these dynamic finder methods on relations and named scopes.
#
#   Payment.order("created_on").find_by_amount(50)
#
# == Saving arrays, hashes, and other non-mappable objects in text columns
#
# Active Record can serialize any object in text columns using YAML. To do so, you must
# specify this with a call to the class method
# {serialize}[rdoc-ref:AttributeMethods::Serialization::ClassMethods#serialize].
# This makes it possible to store arrays, hashes, and other non-mappable objects without doing
# any additional work.
#
#   class User < ActiveRecord::Base
#     serialize :preferences
#   end
#
#   user = User.create(preferences: { "background" => "black", "display" => large })
#   User.find(user.id).preferences # => { "background" => "black", "display" => large }
#
# You can also specify a class option as the second parameter that'll raise an exception
# if a serialized object is retrieved as a descendant of a class not in the hierarchy.
#
#   class User < ActiveRecord::Base
#     serialize :preferences, Hash
#   end
#
#   user = User.create(preferences: %w( one two three ))
#   User.find(user.id).preferences    # raises SerializationTypeMismatch
#
# When you specify a class option, the default value for that attribute will be a new
# instance of that class.
#
#   class User < ActiveRecord::Base
#     serialize :preferences, OpenStruct
#   end
#
#   user = User.new
#   user.preferences.theme_color = "red"
#
#
# == Single table inheritance
#
# Active Record allows inheritance by storing the name of the class in a
# column that is named "type" by default. See ActiveRecord::Inheritance for
# more details.
#
# == Connection to multiple databases in different models
#
# Connections are usually created through
# {ActiveRecord::Base.establish_connection}[rdoc-ref:ConnectionHandling#establish_connection] and retrieved
# by ActiveRecord::Base.connection. All classes inheriting from ActiveRecord::Base will use this
# connection. But you can also set a class-specific connection. For example, if Course is an
# ActiveRecord::Base, but resides in a different database, you can just say <tt>Course.establish_connection</tt>
# and Course and all of its subclasses will use this connection instead.
#
# This feature is implemented by keeping a connection pool in ActiveRecord::Base that is
# a hash indexed by the class. If a connection is requested, the
# {ActiveRecord::Base.retrieve_connection}[rdoc-ref:ConnectionHandling#retrieve_connection] method
# will go up the class-hierarchy until a connection is found in the connection pool.
#
# == Exceptions
#
# * ActiveRecordError - Generic error class and superclass of all other errors raised by Active Record.
# * AdapterNotSpecified - The configuration hash used in
#   {ActiveRecord::Base.establish_connection}[rdoc-ref:ConnectionHandling#establish_connection]
#   didn't include an <tt>:adapter</tt> key.
# * AdapterNotFound - The <tt>:adapter</tt> key used in
#   {ActiveRecord::Base.establish_connection}[rdoc-ref:ConnectionHandling#establish_connection]
#   specified a non-existent adapter
#   (or a bad spelling of an existing one).
# * AssociationTypeMismatch - The object assigned to the association wasn't of the type
#   specified in the association definition.
# * AttributeAssignmentError - An error occurred while doing a mass assignment through the
#   {ActiveRecord::Base#attributes=}[rdoc-ref:AttributeAssignment#attributes=] method.
#   You can inspect the +attribute+ property of the exception object to determine which attribute
#   triggered the error.
# * ConnectionNotEstablished - No connection has been established.
#   Use {ActiveRecord::Base.establish_connection}[rdoc-ref:ConnectionHandling#establish_connection] before querying.
# * MultiparameterAssignmentErrors - Collection of errors that occurred during a mass assignment using the
#   {ActiveRecord::Base#attributes=}[rdoc-ref:AttributeAssignment#attributes=] method.
#   The +errors+ property of this exception contains an array of
#   AttributeAssignmentError
#   objects that should be inspected to determine which attributes triggered the errors.
# * RecordInvalid - raised by {ActiveRecord::Base#save!}[rdoc-ref:Persistence#save!] and
#   {ActiveRecord::Base.create!}[rdoc-ref:Persistence::ClassMethods#create!]
#   when the record is invalid.
# * RecordNotFound - No record responded to the {ActiveRecord::Base.find}[rdoc-ref:FinderMethods#find] method.
#   Either the row with the given ID doesn't exist or the row didn't meet the additional restrictions.
#   Some {ActiveRecord::Base.find}[rdoc-ref:FinderMethods#find] calls do not raise this exception to signal
#   nothing was found, please check its documentation for further details.
# * SerializationTypeMismatch - The serialized object wasn't of the class specified as the second parameter.
# * StatementInvalid - The database server rejected the SQL statement. The precise error is added in the message.
#
# *Note*: The attributes listed are class-level attributes (accessible from both the class and instance level).
# So it's possible to assign a logger to the class through <tt>Base.logger=</tt> which will then be used by all
# instances in the current object space.
class ActiveRecord::Base
  include ::ActiveRecord::Core
  include ::ActiveRecord::Persistence
  include ::ActiveRecord::ReadonlyAttributes
  include ::ActiveRecord::ModelSchema
  include ::ActiveRecord::Inheritance
  include ::ActiveRecord::Scoping
  include ::ActiveRecord::Scoping::Default
  include ::ActiveRecord::Scoping::Named
  include ::ActiveRecord::Sanitization
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveModel::AttributeAssignment
  include ::ActiveRecord::AttributeAssignment
  include ::ActiveModel::Conversion
  include ::ActiveRecord::Integration
  include ::ActiveModel::Validations
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveRecord::Validations
  include ::ActiveRecord::CounterCache
  include ::ActiveRecord::Attributes
  include ::ActiveRecord::Locking::Optimistic
  include ::ActiveRecord::Locking::Pessimistic
  include ::ActiveModel::AttributeMethods
  include ::ActiveRecord::AttributeMethods
  include ::ActiveRecord::Base::GeneratedAttributeMethods
  include ::ActiveRecord::Base::GeneratedAssociationMethods
  include ::ActiveRecord::AttributeMethods::Read
  include ::ActiveRecord::AttributeMethods::Write
  include ::ActiveRecord::AttributeMethods::BeforeTypeCast
  include ::ActiveRecord::AttributeMethods::Query
  include ::ActiveRecord::AttributeMethods::PrimaryKey
  include ::ActiveRecord::AttributeMethods::TimeZoneConversion
  include ::ActiveModel::Dirty
  include ::ActiveRecord::AttributeMethods::Dirty
  include ::ActiveRecord::AttributeMethods::Serialization
  include ::ActiveRecord::Callbacks
  include ::ActiveModel::Validations::Callbacks
  include ::ActiveRecord::Timestamp
  include ::ActiveRecord::Associations
  include ::ActiveModel::SecurePassword
  include ::ActiveRecord::AutosaveAssociation
  include ::ActiveRecord::NestedAttributes
  include ::ActiveRecord::Transactions
  include ::ActiveRecord::TouchLater
  include ::ActiveRecord::NoTouching
  include ::ActiveRecord::Reflection
  include ::ActiveModel::Serialization
  include ::ActiveModel::Serializers::JSON
  include ::ActiveRecord::Serialization
  include ::ActiveRecord::Store
  include ::ActiveRecord::SecureToken
  include ::ActiveRecord::SignedId
  include ::ActiveRecord::Suppressor
  include ::ActiveRecord::Encryption::EncryptableRecord
  include ::Kaminari::ActiveRecordExtension
  extend ::ActiveModel::Naming
  extend ::ActiveSupport::Benchmarkable
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveRecord::ConnectionHandling
  extend ::ActiveRecord::QueryCache::ClassMethods
  extend ::ActiveRecord::Querying
  extend ::ActiveModel::Translation
  extend ::ActiveRecord::Translation
  extend ::ActiveRecord::DynamicMatchers
  extend ::ActiveRecord::DelegatedType
  extend ::ActiveRecord::Explain
  extend ::ActiveRecord::Enum
  extend ::ActiveRecord::Delegation::DelegateCache
  extend ::ActiveRecord::Aggregations::ClassMethods
  extend ::ActiveRecord::Core::ClassMethods
  extend ::ActiveRecord::Persistence::ClassMethods
  extend ::ActiveRecord::ReadonlyAttributes::ClassMethods
  extend ::ActiveRecord::ModelSchema::ClassMethods
  extend ::ActiveRecord::Inheritance::ClassMethods
  extend ::ActiveRecord::Scoping::ClassMethods
  extend ::ActiveRecord::Scoping::Default::ClassMethods
  extend ::ActiveRecord::Scoping::Named::ClassMethods
  extend ::ActiveRecord::Sanitization::ClassMethods
  extend ::ActiveModel::Conversion::ClassMethods
  extend ::ActiveRecord::Integration::ClassMethods
  extend ::ActiveModel::Validations::ClassMethods
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveModel::Validations::HelperMethods
  extend ::ActiveRecord::Validations::ClassMethods
  extend ::ActiveRecord::CounterCache::ClassMethods
  extend ::ActiveRecord::Attributes::ClassMethods
  extend ::ActiveRecord::Locking::Optimistic::ClassMethods
  extend ::ActiveModel::AttributeMethods::ClassMethods
  extend ::ActiveRecord::AttributeMethods::ClassMethods
  extend ::ActiveRecord::AttributeMethods::Read::ClassMethods
  extend ::ActiveRecord::AttributeMethods::Write::ClassMethods
  extend ::ActiveRecord::AttributeMethods::PrimaryKey::ClassMethods
  extend ::ActiveRecord::AttributeMethods::TimeZoneConversion::ClassMethods
  extend ::ActiveRecord::AttributeMethods::Dirty::ClassMethods
  extend ::ActiveRecord::AttributeMethods::Serialization::ClassMethods
  extend ::ActiveRecord::Callbacks::ClassMethods
  extend ::ActiveModel::Validations::Callbacks::ClassMethods
  extend ::ActiveRecord::Timestamp::ClassMethods
  extend ::ActiveRecord::Associations::ClassMethods
  extend ::ActiveModel::SecurePassword::ClassMethods
  extend ::ActiveRecord::AutosaveAssociation::ClassMethods
  extend ::ActiveRecord::NestedAttributes::ClassMethods
  extend ::ActiveRecord::Transactions::ClassMethods
  extend ::ActiveRecord::NoTouching::ClassMethods
  extend ::ActiveRecord::Reflection::ClassMethods
  extend ::ActiveRecord::Store::ClassMethods
  extend ::ActiveRecord::SecureToken::ClassMethods
  extend ::ActiveRecord::SignedId::ClassMethods
  extend ::ActiveRecord::Suppressor::ClassMethods
  extend ::ActiveRecord::Encryption::EncryptableRecord::ClassMethods
  extend ::Kaminari::ActiveRecordExtension::ClassMethods

  def __callbacks; end
  def __callbacks?; end
  def _before_commit_callbacks; end
  def _commit_callbacks; end
  def _create_callbacks; end
  def _destroy_callbacks; end
  def _find_callbacks; end
  def _initialize_callbacks; end
  def _reflections; end
  def _reflections?; end
  def _rollback_callbacks; end
  def _run_before_commit_callbacks(&block); end
  def _run_commit_callbacks(&block); end
  def _run_create_callbacks(&block); end
  def _run_destroy_callbacks(&block); end
  def _run_find_callbacks(&block); end
  def _run_initialize_callbacks(&block); end
  def _run_rollback_callbacks(&block); end
  def _run_save_callbacks(&block); end
  def _run_touch_callbacks(&block); end
  def _run_update_callbacks(&block); end
  def _run_validate_callbacks(&block); end
  def _run_validation_callbacks(&block); end
  def _save_callbacks; end
  def _touch_callbacks; end
  def _update_callbacks; end
  def _validate_callbacks; end
  def _validation_callbacks; end
  def _validators; end
  def _validators?; end
  def aggregate_reflections; end
  def aggregate_reflections?; end
  def attribute_aliases; end
  def attribute_aliases?; end
  def attribute_method_matchers; end
  def attribute_method_matchers?; end
  def automatic_scope_inversing; end
  def automatic_scope_inversing?; end
  def cache_timestamp_format; end
  def cache_timestamp_format?; end
  def cache_versioning; end
  def cache_versioning?; end
  def collection_cache_versioning; end
  def collection_cache_versioning?; end
  def column_for_attribute(*_arg0, **_arg1, &_arg2); end
  def default_connection_handler; end
  def default_connection_handler?; end
  def default_role; end
  def default_role?; end
  def default_scope_override; end
  def default_scopes; end
  def default_shard; end
  def default_shard?; end
  def defined_enums; end
  def defined_enums?; end
  def destroy_association_async_job; end
  def encrypted_attributes; end
  def encrypted_attributes=(_arg0); end
  def encrypted_attributes?; end
  def include_root_in_json; end
  def include_root_in_json?; end
  def lock_optimistically; end
  def lock_optimistically?; end
  def logger; end
  def logger?; end
  def model_name(*_arg0, **_arg1, &_arg2); end
  def nested_attributes_options; end
  def nested_attributes_options?; end
  def partial_inserts; end
  def partial_inserts?; end
  def partial_updates; end
  def partial_updates?; end
  def pluralize_table_names; end
  def pluralize_table_names?; end
  def primary_key_prefix_type; end
  def primary_key_prefix_type?; end
  def record_timestamps; end
  def record_timestamps=(_arg0); end
  def record_timestamps?; end
  def signed_id_verifier_secret; end
  def signed_id_verifier_secret?; end
  def skip_time_zone_conversion_for_attributes; end
  def skip_time_zone_conversion_for_attributes?; end
  def store_full_class_name; end
  def store_full_class_name?; end
  def store_full_sti_class; end
  def store_full_sti_class?; end
  def table_name_prefix; end
  def table_name_prefix?; end
  def table_name_suffix; end
  def table_name_suffix?; end
  def time_zone_aware_attributes; end
  def time_zone_aware_attributes?; end
  def time_zone_aware_types; end
  def time_zone_aware_types?; end
  def to_yaml_properties; end
  def type_for_attribute(*_arg0, **_arg1, &_arg2); end
  def validation_context; end

  private

  def validation_context=(_arg0); end

  class << self
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
    def _attr_readonly; end
    def _attr_readonly=(value); end
    def _attr_readonly?; end
    def _before_commit_callbacks; end
    def _before_commit_callbacks=(value); end
    def _commit_callbacks; end
    def _commit_callbacks=(value); end
    def _create_callbacks; end
    def _create_callbacks=(value); end
    def _destroy_callbacks; end
    def _destroy_callbacks=(value); end
    def _find_callbacks; end
    def _find_callbacks=(value); end
    def _initialize_callbacks; end
    def _initialize_callbacks=(value); end
    def _reflections; end
    def _reflections=(value); end
    def _reflections?; end
    def _rollback_callbacks; end
    def _rollback_callbacks=(value); end
    def _save_callbacks; end
    def _save_callbacks=(value); end
    def _touch_callbacks; end
    def _touch_callbacks=(value); end
    def _update_callbacks; end
    def _update_callbacks=(value); end
    def _validate_callbacks; end
    def _validate_callbacks=(value); end
    def _validation_callbacks; end
    def _validation_callbacks=(value); end
    def _validators; end
    def _validators=(value); end
    def _validators?; end
    def after_create(*args, **options, &block); end
    def after_destroy(*args, **options, &block); end
    def after_find(*args, **options, &block); end
    def after_initialize(*args, **options, &block); end
    def after_save(*args, **options, &block); end
    def after_touch(*args, **options, &block); end
    def after_update(*args, **options, &block); end
    def aggregate_reflections; end
    def aggregate_reflections=(value); end
    def aggregate_reflections?; end
    def application_record_class?; end
    def around_create(*args, **options, &block); end
    def around_destroy(*args, **options, &block); end
    def around_save(*args, **options, &block); end
    def around_update(*args, **options, &block); end
    def asynchronous_queries_session; end
    def asynchronous_queries_tracker; end
    def attribute_aliases; end
    def attribute_aliases=(value); end
    def attribute_aliases?; end
    def attribute_method_matchers; end
    def attribute_method_matchers=(value); end
    def attribute_method_matchers?; end
    def attributes_to_define_after_schema_loads; end
    def attributes_to_define_after_schema_loads=(value); end
    def attributes_to_define_after_schema_loads?; end
    def automatic_scope_inversing; end
    def automatic_scope_inversing=(value); end
    def automatic_scope_inversing?; end
    def before_create(*args, **options, &block); end
    def before_destroy(*args, **options, &block); end
    def before_save(*args, **options, &block); end
    def before_update(*args, **options, &block); end
    def belongs_to_required_by_default; end
    def belongs_to_required_by_default=(value); end
    def belongs_to_required_by_default?; end
    def cache_timestamp_format; end
    def cache_timestamp_format=(value); end
    def cache_timestamp_format?; end
    def cache_versioning; end
    def cache_versioning=(value); end
    def cache_versioning?; end
    def collection_cache_versioning; end
    def collection_cache_versioning=(value); end
    def collection_cache_versioning?; end
    def configurations; end
    def configurations=(config); end
    def connected_to_stack; end
    def connection_class; end
    def connection_class=(b); end
    def connection_class?; end
    def connection_class_for_self; end
    def connection_handler; end
    def connection_handler=(handler); end
    def connection_handlers; end
    def connection_handlers=(handlers); end
    def current_preventing_writes; end
    def current_role; end
    def current_shard; end
    def default_connection_handler; end
    def default_connection_handler=(value); end
    def default_connection_handler?; end
    def default_role; end
    def default_role=(value); end
    def default_role?; end
    def default_scope_override; end
    def default_scope_override=(value); end
    def default_scopes; end
    def default_scopes=(value); end
    def default_shard; end
    def default_shard=(value); end
    def default_shard?; end
    def defined_enums; end
    def defined_enums=(value); end
    def defined_enums?; end
    def destroy_association_async_job; end
    def destroy_association_async_job=(value); end
    def encrypted_attributes; end
    def encrypted_attributes=(value); end
    def encrypted_attributes?; end
    def enumerate_columns_in_select_statements; end
    def enumerate_columns_in_select_statements=(value); end
    def enumerate_columns_in_select_statements?; end
    def has_many_inversing; end
    def has_many_inversing=(value); end
    def has_many_inversing?; end
    def immutable_strings_by_default; end
    def immutable_strings_by_default=(value); end
    def immutable_strings_by_default?; end
    def implicit_order_column; end
    def implicit_order_column=(value); end
    def implicit_order_column?; end
    def include_root_in_json; end
    def include_root_in_json=(value); end
    def include_root_in_json?; end
    def inheritance_column; end
    def inheritance_column=(value); end
    def inheritance_column?; end
    def internal_metadata_table_name; end
    def internal_metadata_table_name=(value); end
    def internal_metadata_table_name?; end
    def local_stored_attributes; end
    def local_stored_attributes=(_arg0); end
    def lock_optimistically; end
    def lock_optimistically=(value); end
    def lock_optimistically?; end
    def logger; end
    def logger=(value); end
    def logger?; end
    def nested_attributes_options; end
    def nested_attributes_options=(value); end
    def nested_attributes_options?; end
    def partial_inserts; end
    def partial_inserts=(value); end
    def partial_inserts?; end
    def partial_updates; end
    def partial_updates=(value); end
    def partial_updates?; end
    def pluralize_table_names; end
    def pluralize_table_names=(value); end
    def pluralize_table_names?; end
    def primary_key_prefix_type; end
    def primary_key_prefix_type=(value); end
    def primary_key_prefix_type?; end
    def record_timestamps; end
    def record_timestamps=(value); end
    def record_timestamps?; end
    def schema_migrations_table_name; end
    def schema_migrations_table_name=(value); end
    def schema_migrations_table_name?; end
    def shard_selector; end
    def shard_selector=(value); end
    def shard_selector?; end
    def signed_id_verifier_secret; end
    def signed_id_verifier_secret=(value); end
    def signed_id_verifier_secret?; end
    def skip_time_zone_conversion_for_attributes; end
    def skip_time_zone_conversion_for_attributes=(value); end
    def skip_time_zone_conversion_for_attributes?; end
    def store_full_class_name; end
    def store_full_class_name=(value); end
    def store_full_class_name?; end
    def store_full_sti_class; end
    def store_full_sti_class=(value); end
    def store_full_sti_class?; end
    def strict_loading_by_default; end
    def strict_loading_by_default=(value); end
    def strict_loading_by_default?; end
    def strict_loading_violation!(owner:, reflection:); end
    def table_name_prefix; end
    def table_name_prefix=(value); end
    def table_name_prefix?; end
    def table_name_suffix; end
    def table_name_suffix=(value); end
    def table_name_suffix?; end
    def time_zone_aware_attributes; end
    def time_zone_aware_attributes=(value); end
    def time_zone_aware_attributes?; end
    def time_zone_aware_types; end
    def time_zone_aware_types=(value); end
    def time_zone_aware_types?; end
    def yaml_new(klass, _tag, val); end

    private

    def _inheritance_column=(value); end
  end
end

module ActiveRecord::Base::GeneratedAssociationMethods; end
module ActiveRecord::Base::GeneratedAttributeMethods; end

module ActiveRecord::Encryption::EncryptableRecord::ClassMethods
  def deterministic_encrypted_attributes; end
  def encrypts(*names, key_provider: T.unsafe(nil), key: T.unsafe(nil), deterministic: T.unsafe(nil), downcase: T.unsafe(nil), ignore_case: T.unsafe(nil), previous: T.unsafe(nil), **context_properties); end
  def source_attribute_from_preserved_attribute(attribute_name); end

  private

  def add_length_validation_for_encrypted_columns; end
  def encrypt_attribute(name, attribute_scheme); end
  def global_previous_schemes_for(scheme); end
  def load_schema!; end
  def override_accessors_to_preserve_original(name, original_attribute_name); end
  def preserve_original_encrypted(name); end
  def scheme_for(key_provider: T.unsafe(nil), key: T.unsafe(nil), deterministic: T.unsafe(nil), downcase: T.unsafe(nil), ignore_case: T.unsafe(nil), previous: T.unsafe(nil), **context_properties); end
  def validate_column_size(attribute_name); end
end

# MigrationProxy is used to defer loading of the actual migration classes
# until they are needed
class ActiveRecord::MigrationProxy < ::Struct
  # @return [MigrationProxy] a new instance of MigrationProxy
  def initialize(name, version, filename, scope); end

  def announce(*_arg0, **_arg1, &_arg2); end
  def basename; end
  def disable_ddl_transaction(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute filename
  #
  # @return [Object] the current value of filename
  def filename; end

  # Sets the attribute filename
  #
  # @param value [Object] the value to set the attribute filename to.
  # @return [Object] the newly set value
  def filename=(_); end

  def migrate(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  # Returns the value of attribute scope
  #
  # @return [Object] the current value of scope
  def scope; end

  # Sets the attribute scope
  #
  # @param value [Object] the value to set the attribute scope to.
  # @return [Object] the newly set value
  def scope=(_); end

  # Returns the value of attribute version
  #
  # @return [Object] the current value of version
  def version; end

  # Sets the attribute version
  #
  # @param value [Object] the value to set the attribute version to.
  # @return [Object] the newly set value
  def version=(_); end

  def write(*_arg0, **_arg1, &_arg2); end

  private

  def load_migration; end
  def migration; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Raised when unknown attributes are supplied via mass assignment.
ActiveRecord::UnknownAttributeError = ActiveModel::UnknownAttributeError

module Delayed; end
module Delayed::Backend; end

module Delayed::Backend::Base
  mixes_in_class_methods ::Delayed::Backend::Base::ClassMethods

  # @return [Boolean]
  def destroy_failed_jobs?; end

  # Returns the value of attribute error.
  def error; end

  def error=(error); end
  def fail!; end

  # @return [Boolean]
  def failed; end

  # @return [Boolean]
  def failed?; end

  def hook(name, *args); end
  def invoke_job; end
  def max_attempts; end
  def max_run_time; end
  def name; end
  def payload_object; end
  def payload_object=(object); end
  def reschedule_at; end

  # Unlock this job (note: not saved to DB)
  def unlock; end

  protected

  # Call during reload operation to clear out internal state
  def reset; end

  def set_default_run_at; end

  class << self
    # @private
    def included(base); end
  end
end

module Delayed::Backend::Base::ClassMethods
  # Hook method that is called after a new worker is forked
  def after_fork; end

  # Hook method that is called before a new worker is forked
  def before_fork; end

  # Add a job to the queue
  def enqueue(*args); end

  def enqueue_job(options); end

  # Allow the backend to attempt recovery from reserve errors
  def recover_from(_error); end

  def reserve(worker, max_run_time = T.unsafe(nil)); end
  def work_off(num = T.unsafe(nil)); end
end

Delayed::Backend::Base::ParseObjectFromYaml = T.let(T.unsafe(nil), Regexp)

class Delayed::Backend::JobPreparer
  # @return [JobPreparer] a new instance of JobPreparer
  def initialize(*args); end

  # Returns the value of attribute args.
  def args; end

  # Returns the value of attribute options.
  def options; end

  def prepare; end

  private

  def handle_deprecation; end
  def set_payload; end
  def set_priority; end
  def set_queue_name; end
end

class Delayed::Callback
  # @return [Callback] a new instance of Callback
  def initialize; end

  def add(type, &callback); end
  def execute(*args, &block); end
end

module Delayed::Compatibility
  class << self
    def executable_prefix; end
    def proxy_object_class; end
  end
end

module Delayed::DelayMail
  def delay(options = T.unsafe(nil)); end
end

class Delayed::DelayProxy < ::ActiveSupport::ProxyObject
  # @return [DelayProxy] a new instance of DelayProxy
  def initialize(payload_class, target, options); end

  def method_missing(method, *args); end
end

class Delayed::DeserializationError < ::StandardError; end
class Delayed::FatalBackendError < ::RuntimeError; end
class Delayed::InvalidCallback < ::RuntimeError; end
Delayed::Job = Delayed::Backend::ActiveRecord::Job

class Delayed::Lifecycle
  # @return [Lifecycle] a new instance of Lifecycle
  def initialize; end

  def after(event, &block); end
  def around(event, &block); end
  def before(event, &block); end
  def run_callbacks(event, *args, &block); end

  private

  def add(type, event, &block); end

  # @raise [InvalidCallback]
  def missing_callback(event); end
end

Delayed::Lifecycle::EVENTS = T.let(T.unsafe(nil), Hash)

module Delayed::MessageSending
  def __delay__(options = T.unsafe(nil)); end
  def delay(options = T.unsafe(nil)); end
  def send_at(time, method, *args); end
  def send_later(method, *args); end
end

module Delayed::MessageSendingClassMethods
  def handle_asynchronously(method, opts = T.unsafe(nil)); end
end

class Delayed::PerformableMailer < ::Delayed::PerformableMethod
  def perform; end
end

class Delayed::PerformableMethod
  # @raise [NoMethodError]
  # @return [PerformableMethod] a new instance of PerformableMethod
  def initialize(object, method_name, args); end

  # Returns the value of attribute args.
  def args; end

  # Sets the attribute args
  #
  # @param value the value to set the attribute args to.
  def args=(_arg0); end

  def display_name; end

  # serialize to YAML
  def encode_with(coder); end

  def method(sym); end
  def method_missing(symbol, *args); end

  # Returns the value of attribute method_name.
  def method_name; end

  # Sets the attribute method_name
  #
  # @param value the value to set the attribute method_name to.
  def method_name=(_arg0); end

  # Returns the value of attribute object.
  def object; end

  # Sets the attribute object
  #
  # @param value the value to set the attribute object to.
  def object=(_arg0); end

  def perform; end

  # @return [Boolean]
  def respond_to?(symbol, include_private = T.unsafe(nil)); end
end

class Delayed::Plugin
  # @return [Plugin] a new instance of Plugin
  def initialize; end

  def callback_block; end
  def callback_block=(_arg0); end
  def callback_block?; end

  class << self
    def callback_block; end
    def callback_block=(value); end
    def callback_block?; end
    def callbacks(&block); end
  end
end

module Delayed::Plugins; end

class Delayed::Plugins::ClearLocks < ::Delayed::Plugin
  class << self
    def callback_block; end
  end
end

module Delayed::PsychExt; end

class Delayed::PsychExt::ToRuby < ::Psych::Visitors::ToRuby
  # defined? is triggering something really messed up in
  # jruby causing both the if AND else clauses to execute,
  # however if the check is run here, everything is fine
  def jruby_is_seriously_borked; end

  def resolve_class(klass_name); end
  def visit_Psych_Nodes_Mapping(object); end
end

class Delayed::Railtie < ::Rails::Railtie; end

class Delayed::Worker
  # @return [Worker] a new instance of Worker
  def initialize(options = T.unsafe(nil)); end

  def backend; end
  def default_log_level; end
  def default_log_level=(val); end
  def default_priority; end
  def default_priority=(val); end
  def default_queue_name; end
  def default_queue_name=(val); end
  def delay_jobs; end
  def delay_jobs=(val); end
  def destroy_failed_jobs; end
  def destroy_failed_jobs=(val); end
  def exit_on_complete; end
  def exit_on_complete=(val); end
  def failed(job); end
  def job_say(job, text, level = T.unsafe(nil)); end
  def logger; end
  def logger=(val); end
  def max_attempts(job); end
  def max_attempts=(val); end
  def max_priority; end
  def max_priority=(val); end
  def max_run_time(job); end
  def max_run_time=(val); end
  def min_priority; end
  def min_priority=(val); end

  # Every worker has a unique name which by default is the pid of the process. There are some
  # advantages to overriding this with something which survives worker restarts:  Workers can
  # safely resume working on tasks which are locked by themselves. The worker will assume that
  # it crashed before.
  def name; end

  # Sets the name of the worker.
  # Setting the name to nil will reset the default worker name
  def name=(_arg0); end

  # name_prefix is ignored if name is set directly
  def name_prefix; end

  # name_prefix is ignored if name is set directly
  def name_prefix=(_arg0); end

  def plugins; end
  def plugins=(val); end
  def queue_attributes; end
  def queues; end
  def queues=(val); end
  def raise_signal_exceptions; end
  def raise_signal_exceptions=(val); end
  def read_ahead; end
  def read_ahead=(val); end

  # Reschedule the job in the future (when a job fails).
  # Uses an exponential scale depending on the number of failed attempts.
  def reschedule(job, time = T.unsafe(nil)); end

  def run(job); end
  def say(text, level = T.unsafe(nil)); end
  def sleep_delay; end
  def sleep_delay=(val); end
  def start; end
  def stop; end

  # @return [Boolean]
  def stop?; end

  # Do num jobs and return stats on success/failure.
  # Exit early if interrupted.
  def work_off(num = T.unsafe(nil)); end

  protected

  def handle_failed_job(job, error); end
  def reload!; end

  # Run the next job we can get an exclusive lock on.
  # If no jobs are left we return nil
  def reserve_and_run_one_job; end

  def reserve_job; end
  def say_queue(queue); end

  class << self
    def after_fork; end
    def backend; end
    def backend=(backend); end
    def before_fork; end
    def default_log_level; end
    def default_log_level=(val); end
    def default_priority; end
    def default_priority=(val); end
    def default_queue_name; end
    def default_queue_name=(val); end

    # @return [Boolean]
    def delay_job?(job); end

    def delay_jobs; end
    def delay_jobs=(val); end
    def destroy_failed_jobs; end
    def destroy_failed_jobs=(val); end
    def exit_on_complete; end
    def exit_on_complete=(val); end
    def guess_backend; end
    def lifecycle; end
    def logger; end
    def logger=(val); end
    def max_attempts; end
    def max_attempts=(val); end
    def max_priority; end
    def max_priority=(val); end
    def max_run_time; end
    def max_run_time=(val); end
    def min_priority; end
    def min_priority=(val); end
    def plugins; end
    def plugins=(val); end
    def queue_attributes; end
    def queue_attributes=(val); end
    def queues; end
    def queues=(val); end
    def raise_signal_exceptions; end
    def raise_signal_exceptions=(val); end
    def read_ahead; end
    def read_ahead=(val); end

    # @return [Boolean]
    def reload_app?; end

    def reset; end
    def setup_lifecycle; end
    def sleep_delay; end
    def sleep_delay=(val); end
  end
end

Delayed::Worker::DEFAULT_DEFAULT_PRIORITY = T.let(T.unsafe(nil), Integer)
Delayed::Worker::DEFAULT_DELAY_JOBS = T.let(T.unsafe(nil), TrueClass)
Delayed::Worker::DEFAULT_LOG_LEVEL = T.let(T.unsafe(nil), String)
Delayed::Worker::DEFAULT_MAX_ATTEMPTS = T.let(T.unsafe(nil), Integer)
Delayed::Worker::DEFAULT_MAX_RUN_TIME = T.let(T.unsafe(nil), ActiveSupport::Duration)
Delayed::Worker::DEFAULT_QUEUES = T.let(T.unsafe(nil), Array)
Delayed::Worker::DEFAULT_QUEUE_ATTRIBUTES = T.let(T.unsafe(nil), ActiveSupport::HashWithIndifferentAccess)
Delayed::Worker::DEFAULT_READ_AHEAD = T.let(T.unsafe(nil), Integer)
Delayed::Worker::DEFAULT_SLEEP_DELAY = T.let(T.unsafe(nil), Integer)

class Delayed::WorkerTimeout < ::Timeout::Error
  def message; end
end

module Psych
  extend ::Bootsnap::CompileCache::YAML::Psych4::Patch

  class << self
    def load_dj(yaml); end
  end
end

Psych::VERSION = T.let(T.unsafe(nil), String)
