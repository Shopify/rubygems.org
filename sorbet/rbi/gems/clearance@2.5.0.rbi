# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `clearance` gem.
# Please instead update this file by running `bin/tapioca gem clearance`.

module Clearance
  class << self
    # @return [Clearance::Configuration] Clearance's current configuration
    def configuration; end

    # Set Clearance's configuration
    #
    # @param config [Clearance::Configuration]
    def configuration=(config); end

    # Modify Clearance's current configuration
    # ```
    # Clearance.configure do |config|
    #   config.routes = false
    # end
    # ```
    #
    # @yieldparam config [Clearance::Configuration] current Clearance config
    def configure; end
  end
end

module Clearance::Authentication
  extend ::ActiveSupport::Concern

  # Authenticate a user with a provided email and password
  #
  # @param params [ActionController::Parameters] The parameters from the
  #   sign in form. `params[:session][:email]` and
  #   `params[:session][:password]` are required.
  # @return [User, nil] The user or nil if authentication fails.
  def authenticate(params); end

  # Get the user from the current clearance session. Exposed as a
  # `helper_method`, making it visible to views. Prefer {#signed_in?} or
  # {#signed_out?} if you only want to check for the presence of a current
  # user rather than access the actual user.
  #
  # @return [User, nil] The user if one is signed in or nil otherwise.
  def current_user; end

  # CSRF protection in Rails >= 3.0.4
  #
  # http://weblog.rubyonrails.org/2011/2/8/csrf-protection-bypass-in-ruby-on-rails
  #
  # @private
  def handle_unverified_request; end

  # Sign in the provided user.
  # Signing in will run the stack of {Configuration#sign_in_guards}.
  #
  # You can provide a block to this method to handle the result of that stack.
  # Your block will receive either a {SuccessStatus} or {FailureStatus}
  #
  #     sign_in(user) do |status|
  #       if status.success?
  #         # ...
  #       else
  #         # ...
  #       end
  #     end
  #
  # For an example of how clearance uses this internally, see
  # {SessionsController#create}.
  #
  # Signing in will also regenerate the CSRF token for the current session,
  # provided {Configuration#rotate_csrf_on_sign_in?} is set.
  #
  # @param user [User]
  def sign_in(user, &block); end

  # Destroy the current user's Clearance session.
  # See {Session#sign_out} for specifics.
  def sign_out; end

  # True if there is a currently-signed-in user. Exposed as a `helper_method`,
  # making it available to views.
  #
  # Using `signed_in?` is preferable to checking {#current_user} against nil
  # as it will allow you to introduce a null user object more simply at a
  # later date.
  #
  # @return [Boolean]
  def signed_in?; end

  # True if there is no currently-signed-in user. Exposed as a
  # `helper_method`, making it available to views.
  #
  # Usings `signed_out?` is preferable to checking for presence of
  # {#current_user} as it will allow you to introduce a null user object more
  # simply at a later date.
  #
  # @return [Boolean]
  def signed_out?; end

  protected

  # @api private
  def clearance_session; end
end

module Clearance::Authorization
  extend ::ActiveSupport::Concern

  # Responds to unauthorized requests in a manner fitting the request format.
  # `js`, `json`, and `xml` requests will receive a 401 with no body. All
  # other formats will be redirected appropriately and can optionally have the
  # flash message set.
  #
  # When redirecting, the originally requested url will be stored in the
  # session (`session[:return_to]`), allowing it to be used as a redirect url
  # once the user has successfully signed in.
  #
  # If there is a signed in user, the request will be redirected according to
  # the value returned from {#url_after_denied_access_when_signed_in}.
  #
  # If there is no signed in user, the request will be redirected according to
  # the value returned from {#url_after_denied_access_when_signed_out}.
  # For the exact redirect behavior, see {#redirect_request}.
  #
  # @param flash_message [String]
  def deny_access(flash_message = T.unsafe(nil)); end

  # Use as a `before_action` to require a user be signed in to proceed.
  # {Authentication#signed_in?} is used to determine if there is a signed in
  # user or not.
  #
  #     class PostsController < ApplicationController
  #       before_action :require_login
  #
  #       def index
  #         # ...
  #       end
  #     end
  def require_login; end

  protected

  # @api private
  def clear_return_to; end

  # @api private
  def path_without_leading_slashes(uri); end

  # @api private
  def redirect_back_or(default); end

  # @api private
  def redirect_request(flash_message); end

  # @api private
  def return_to; end

  # @api private
  def return_to_url; end

  # @api private
  def store_location; end

  # Used as the redirect location when {#deny_access} is called and there is a
  # currently signed in user.
  #
  # @return [String]
  def url_after_denied_access_when_signed_in; end

  # Used as the redirect location when {#deny_access} is called and there is
  # no currently signed in user.
  #
  # @return [String]
  def url_after_denied_access_when_signed_out; end
end

# Middleware which allows signing in by passing as=USER_ID in a query
# parameter. If `User#to_param` is overriden you may pass a block to
# override the default user lookup behaviour
#
# Designed to eliminate time in integration tests wasted by visiting and
# submitting the sign in form.
#
# Configuration:
#
#   # config/environments/test.rb
#   MyRailsApp::Application.configure do
#     # ...
#     config.middleware.use Clearance::BackDoor
#     # ...
#   end
#
#   # or if `User#to_param` is overridden (to `username` for example):
#
#   # config/environments/test.rb
#   MyRailsApp::Application.configure do
#     # ...
#     config.middleware.use Clearance::BackDoor do |username|
#       User.find_by(username: username)
#     end
#     # ...
#   end
#
# Usage:
#
#   visit new_feedback_path(as: user)
class Clearance::BackDoor
  # @return [BackDoor] a new instance of BackDoor
  def initialize(app, &block); end

  def call(env); end

  private

  # @api private
  def allowed_environments; end

  # @api private
  # @return [Boolean]
  def environment_is_allowed?; end

  # @api private
  def error_message; end

  # @api private
  def find_user(user_param); end

  # @api private
  def sign_in_through_the_back_door(env); end
end

class Clearance::Configuration
  # @return [Configuration] a new instance of Configuration
  def initialize; end

  # Controls whether the sign up route is enabled.
  # Defaults to `true`. Set to `false` to disable user creation routes.
  # The setting is ignored if routes are disabled.
  #
  # @param value [Boolean]
  # @return [Boolean]
  def allow_sign_up=(_arg0); end

  # Is the user sign up route enabled?
  #
  # @return [Boolean]
  def allow_sign_up?; end

  # The array of allowed environments where `Clearance::BackDoor` is enabled.
  # Defaults to ["test", "ci", "development"]
  #
  # @return [Array<String>]
  def allowed_backdoor_environments; end

  # The array of allowed environments where `Clearance::BackDoor` is enabled.
  # Defaults to ["test", "ci", "development"]
  #
  # @return [Array<String>]
  def allowed_backdoor_environments=(_arg0); end

  # The domain to use for the clearance remember token cookie.
  # Defaults to `nil`, which causes the cookie domain to default to the
  # domain of the request. For more, see
  # [RFC6265](http://tools.ietf.org/html/rfc6265#section-5.2.3).
  #
  # @return [String]
  def cookie_domain; end

  # The domain to use for the clearance remember token cookie.
  # Defaults to `nil`, which causes the cookie domain to default to the
  # domain of the request. For more, see
  # [RFC6265](http://tools.ietf.org/html/rfc6265#section-5.2.3).
  #
  # @return [String]
  def cookie_domain=(_arg0); end

  # A lambda called to set the remember token cookie expires attribute.
  # The lambda accepts the collection of cookies as an argument which
  # allows for changing the expiration according to those cookies.
  # This could be used, for example, to set a session cookie unless
  # a `remember_me` cookie was also present. By default, cookie expiration
  # is one year. For more on cookie expiration see
  # [RFC6265](http://tools.ietf.org/html/rfc6265#section-5.2.1).
  #
  # @return [Lambda]
  def cookie_expiration; end

  # A lambda called to set the remember token cookie expires attribute.
  # The lambda accepts the collection of cookies as an argument which
  # allows for changing the expiration according to those cookies.
  # This could be used, for example, to set a session cookie unless
  # a `remember_me` cookie was also present. By default, cookie expiration
  # is one year. For more on cookie expiration see
  # [RFC6265](http://tools.ietf.org/html/rfc6265#section-5.2.1).
  #
  # @return [Lambda]
  def cookie_expiration=(_arg0); end

  # The name of Clearance's remember token cookie.
  # Defaults to `remember_token`.
  #
  # @return [String]
  def cookie_name; end

  # The name of Clearance's remember token cookie.
  # Defaults to `remember_token`.
  #
  # @return [String]
  def cookie_name=(_arg0); end

  # Controls which paths the remember token cookie is valid for.
  # Defaults to `"/"` for the entire domain. For more, see
  # [RFC6265](http://tools.ietf.org/html/rfc6265#section-5.1.4).
  #
  # @return [String]
  def cookie_path; end

  # Controls which paths the remember token cookie is valid for.
  # Defaults to `"/"` for the entire domain. For more, see
  # [RFC6265](http://tools.ietf.org/html/rfc6265#section-5.1.4).
  #
  # @return [String]
  def cookie_path=(_arg0); end

  # Controls whether the HttpOnly flag should be set on the remember token
  # cookie. Defaults to `true`, which prevents the cookie from being made
  # available to JavaScript. For more see
  # [RFC6265](http://tools.ietf.org/html/rfc6265#section-5.2.6).
  #
  # @return [Boolean]
  def httponly; end

  # Controls whether the HttpOnly flag should be set on the remember token
  # cookie. Defaults to `true`, which prevents the cookie from being made
  # available to JavaScript. For more see
  # [RFC6265](http://tools.ietf.org/html/rfc6265#section-5.2.6).
  #
  # @return [Boolean]
  def httponly=(_arg0); end

  # Controls the address the password reset email is sent from.
  # Defaults to reply@example.com.
  #
  # @return [String]
  def mailer_sender; end

  # Controls the address the password reset email is sent from.
  # Defaults to reply@example.com.
  #
  # @return [String]
  def mailer_sender=(_arg0); end

  # The class representing the configured base controller.
  # In the default configuration, this is the `ApplicationController` class.
  #
  # @return [Class]
  def parent_controller; end

  # The controller class that all Clearance controllers will inherit from.
  # Defaults to `::ApplicationController`.
  #
  # @return [ActionController::Base]
  def parent_controller=(_arg0); end

  # The password strategy to use when authenticating and setting passwords.
  # Defaults to {Clearance::PasswordStrategies::BCrypt}.
  #
  # @return [Module #authenticated? #password=]
  def password_strategy; end

  # The password strategy to use when authenticating and setting passwords.
  # Defaults to {Clearance::PasswordStrategies::BCrypt}.
  #
  # @return [Module #authenticated? #password=]
  def password_strategy=(_arg0); end

  # The default path Clearance will redirect signed in users to.
  # Defaults to `"/"`. This can often be overridden for specific scenarios by
  # overriding controller methods that rely on it.
  #
  # @return [String]
  def redirect_url; end

  # The default path Clearance will redirect signed in users to.
  # Defaults to `"/"`. This can often be overridden for specific scenarios by
  # overriding controller methods that rely on it.
  #
  # @return [String]
  def redirect_url=(_arg0); end

  # Reloads the clearance user model class.
  # This is called from the Clearance engine to reload the configured
  # user class during each request while in development mode, but only once
  # in production.
  #
  # @api private
  def reload_user_model; end

  # Controls whether Clearance will rotate the CSRF token on sign in.
  # Defaults to `nil` which generates a warning. Will default to true in
  # Clearance 2.0.
  def rotate_csrf_on_sign_in; end

  # Controls whether Clearance will rotate the CSRF token on sign in.
  # Defaults to `nil` which generates a warning. Will default to true in
  # Clearance 2.0.
  def rotate_csrf_on_sign_in=(_arg0); end

  # @return [Boolean]
  def rotate_csrf_on_sign_in?; end

  # Set to `false` to disable Clearance's built-in routes.
  # Defaults to `true`. When set to false, your app is responsible for all
  # routes. You can dump a copy of Clearance's default routes with
  # `rails generate clearance:routes`.
  #
  # @return [Boolean]
  def routes=(_arg0); end

  # @return [Boolean] are Clearance's built-in routes enabled?
  def routes_enabled?; end

  # Same-site cookies ("First-Party-Only" or "First-Party") allow servers to
  # mitigate the risk of CSRF and information leakage attacks by asserting
  # that a particular cookie should only be sent with requests initiated from
  # the same registrable domain.
  # Defaults to `nil`. For more, see
  # [RFC6265](https://tools.ietf.org/html/draft-west-first-party-cookies-06#section-4.1.1).
  # and https://github.com/rack/rack/blob/6eda04886e3a57918ca2d6a482fda02a678fef0a/lib/rack/utils.rb#L232-L244
  #
  # @return [String]
  def same_site; end

  # Same-site cookies ("First-Party-Only" or "First-Party") allow servers to
  # mitigate the risk of CSRF and information leakage attacks by asserting
  # that a particular cookie should only be sent with requests initiated from
  # the same registrable domain.
  # Defaults to `nil`. For more, see
  # [RFC6265](https://tools.ietf.org/html/draft-west-first-party-cookies-06#section-4.1.1).
  # and https://github.com/rack/rack/blob/6eda04886e3a57918ca2d6a482fda02a678fef0a/lib/rack/utils.rb#L232-L244
  #
  # @return [String]
  def same_site=(_arg0); end

  # Controls the secure setting on the remember token cookie.
  # Defaults to `false`. When set, the browser will only send the
  # cookie to the server over HTTPS. You should set this value to true in
  # live environments to prevent session hijacking. For more, see
  # [RFC6265](http://tools.ietf.org/html/rfc6265#section-5.2.5).
  #
  # @return [Boolean]
  def secure_cookie; end

  # Controls the secure setting on the remember token cookie.
  # Defaults to `false`. When set, the browser will only send the
  # cookie to the server over HTTPS. You should set this value to true in
  # live environments to prevent session hijacking. For more, see
  # [RFC6265](http://tools.ietf.org/html/rfc6265#section-5.2.5).
  #
  # @return [Boolean]
  def secure_cookie=(_arg0); end

  # The array of sign in guards to run when signing a user in.
  # Defaults to an empty array. Sign in guards respond to `call` and are
  # initialized with a session and the current stack. Each guard can decide
  # to fail the sign in, yield to the next guard, or allow the sign in.
  #
  # @return [Array<#call>]
  def sign_in_guards; end

  # The array of sign in guards to run when signing a user in.
  # Defaults to an empty array. Sign in guards respond to `call` and are
  # initialized with a session and the current stack. Each guard can decide
  # to fail the sign in, yield to the next guard, or allow the sign in.
  #
  # @return [Array<#call>]
  def sign_in_guards=(_arg0); end

  # Controls whether cookies are signed.
  # Defaults to `false` for backwards compatibility.
  # When set, uses Rails' signed cookies
  # (more secure against timing/brute-force attacks)
  # see [ActionDispatch::Cookies](https://api.rubyonrails.org/classes/ActionDispatch/Cookies.html)
  #
  # @return [Boolean|:migrate]
  def signed_cookie; end

  def signed_cookie=(value); end

  # Specifies which controller actions are allowed for user resources.
  # This will be `[:create]` is `allow_sign_up` is true (the default), and
  # empty otherwise.
  #
  # @return [Array<Symbol>]
  def user_actions; end

  # The name of foreign key parameter for the configured user model.
  # This is derived from the `model_name` of the `user_model` setting.
  # In the default configuration, this is `user_id`.
  #
  # @return [Symbol]
  def user_id_parameter; end

  # The class representing the configured user model.
  # In the default configuration, this is the `User` class.
  #
  # @return [Class]
  def user_model; end

  # The ActiveRecord class that represents users in your application.
  # Defaults to `::User`.
  #
  # @return [ActiveRecord::Base]
  def user_model=(_arg0); end

  # The name of user parameter for the configured user model.
  # This is derived from the `model_name` of the `user_model` setting.
  # In the default configuration, this is `user`.
  #
  # @return [Symbol]
  def user_parameter; end
end

# Clearance provides Rails routing constraints that can control access and the
# visibility of routes at the routing layer. The {Constraints::SignedIn}
# constraint can be used to make routes visible only to signed in users. The
# {Constraints::SignedOut} constraint can be used to make routes visible only
# to signed out users.
#
# @see http://guides.rubyonrails.org/routing.html#advanced-constraints
module Clearance::Constraints; end

# Can be applied to make a set of routes visible only to users that are
# signed in.
#
#     # config/routes.rb
#     constraints Clearance::Constraints::SignedIn.new do
#       resources :posts
#     end
#
# In the example above, requests to `/posts` from users that are not signed
# in will result in a 404. You can make additional assertions about the user
# by passing a block. For instance, if you want to require that the
# signed-in user be an admin:
#
#     # config/routes.rb
#     constraints Clearance::Constraints::SignedIn.new { |user| user.admin? } do
#       resources :posts
#     end
class Clearance::Constraints::SignedIn
  # @return [SignedIn] a new instance of SignedIn
  def initialize(&block); end

  # @return [Boolean]
  def matches?(request); end

  private

  # @api private
  def clearance_session; end

  # @api private
  def current_user; end

  # @api private
  # @return [Boolean]
  def current_user_fulfills_additional_requirements?; end

  # @api private
  # @return [Boolean]
  def signed_in?; end
end

# Can be applied to make a set of routes visible only to users that are
# signed out.
#
#     # config/routes.rb
#     constraints Clearance::Constraints::SignedOut.new do
#       resources :registrations, only: [:new, :create]
#     end
#
# In the example above, requests to `/registrations/new` from users that are
# signed in will result in a 404.
class Clearance::Constraints::SignedOut
  # @return [Boolean]
  def matches?(request); end

  private

  # @api private
  def clearance_session; end

  # @api private
  # @return [Boolean]
  def missing_session?; end
end

# Adds clearance controller helpers to the controller it is mixed into.
#
# This exposes clearance controller and helper methods such as `current_user`.
# See {Authentication} and {Authorization} documentation for complete
# documentation on the methods.
#
# The `clearance:install` generator automatically adds this mixin to
# `ApplicationController`, which is the recommended configuration.
#
#     class ApplicationController < ActionController::Base
#       include Clearance::Controller
#     end
module Clearance::Controller
  extend ::ActiveSupport::Concern
  include ::Clearance::Authentication
  include ::Clearance::Authorization
end

# Runs as the base {SignInGuard} for all requests, regardless of configured
# {Configuration#sign_in_guards}.
class Clearance::DefaultSignInGuard < ::Clearance::SignInGuard
  # Runs the default sign in guard.
  #
  # If there is a value set in the clearance session object, then the guard
  # returns {SuccessStatus}. Otherwise, it returns {FailureStatus} with the
  # message returned by {#default_failure_message}.
  #
  # @return [SuccessStatus, FailureStatus]
  def call; end

  # The default failure message pulled from the i18n framework.
  #
  # Will use the value returned from the following i18n keys, in this order:
  #
  # * `clearance.controllers.sessions.bad_email_or_password`
  # * `flashes.failure_after_create`
  #
  # @return [String]
  def default_failure_message; end
end

# Makes Clearance behavior available to Rails apps on initialization. By using
# a Rails Engine rather than a Railtie, Clearance can automatically expose its
# own routes and views to the hosting application.
#
# Requiring `clearance` (likely by having it in your `Gemfile`) will
# automatically require the engine. You can opt-out of Clearance's internal
# routes by using {Configuration#routes=}. You can override the Clearance
# views by running `rails generate clearance:views`.
#
# In addition to providing routes and views, the Clearance engine:
#
# * Ensures `password` and `token` parameters are filtered out of Rails logs.
# * Mounts the {RackSession} middleware in the appropriate location
# * Reloads classes referenced in your {Configuration} on every request in
#   development mode.
class Clearance::Engine < ::Rails::Engine; end

# Indicates a failure in the {SignInGuard} stack which prevented successful
# sign in.
class Clearance::FailureStatus
  # @param failure_message [String] The reason the sign in failed.
  # @return [FailureStatus] a new instance of FailureStatus
  def initialize(failure_message); end

  # The reason the sign in failed.
  def failure_message; end

  # Is false, indicating that the sign in was unsuccessful.
  #
  # @return [Boolean]
  def success?; end
end

# Control how users are authenticated and how passwords are stored.
#
# The default password strategy is {Clearance::PasswordStrategies::BCrypt},
# but this can be overridden in {Clearance::Configuration}.
#
# You can supply your own password strategy by implementing a module that
# responds to the proper interface methods. Once this module is configured as
# your password strategy, Clearance will mix it into your Clearance User
# class. Thus, your module can access any methods or attributes on User.
#
# Password strategies need to respond to `authenticated?(password)` and
# `password=(new_password)`. For an example of how to implement these methods,
# see {Clearance::PasswordStrategies::BCrypt}.
module Clearance::PasswordStrategies; end

# Uses Argon2 to authenticate users and store encrypted passwords.
module Clearance::PasswordStrategies::Argon2
  # @return [Boolean]
  def authenticated?(password); end

  def password=(new_password); end
end

# Uses BCrypt to authenticate users and store encrypted passwords.
#
# BCrypt has a `cost` argument which determines how computationally
# expensive the hash is to calculate. The higher the cost, the harder it is
# for attackers to crack passwords even if they posess a database dump of
# the encrypted passwords. Clearance uses the `bcrypt-ruby` default cost
# except in the test environment, where it uses the minimum cost value for
# speed. If you wish to increase the cost over the default, you can do so
# by setting a higher cost in an initializer:
# `BCrypt::Engine.cost = 12`
module Clearance::PasswordStrategies::BCrypt
  # @return [Boolean]
  def authenticated?(password); end

  def configured_bcrypt_cost; end
  def password=(new_password); end
end

# Rack middleware that manages the Clearance {Session}. This middleware is
# automatically mounted by the Clearance {Engine}.
#
# * maintains the session cookie specified by your {Configuration}.
# * exposes previously cookied sessions to Clearance and your app at
#   `request.env[:clearance]`, which {Authentication#current_user} pulls the
#   user from.
#
# @see Session
# @see Configuration#cookie_name
class Clearance::RackSession
  # @return [RackSession] a new instance of RackSession
  def initialize(app); end

  # Reads previously existing sessions from a cookie and maintains the cookie
  # on each response.
  def call(env); end
end

# Represents a clearance session, ultimately persisted in
# `request.env[:clearance]` by {RackSession}.
class Clearance::Session
  # @param env The current rack environment
  # @return [Session] a new instance of Session
  def initialize(env); end

  # Called by {RackSession} to add the Clearance session cookie to a response.
  #
  # @return [void]
  def add_cookie_to_headers; end

  # True if a successful authentication has been performed
  #
  # @return [Boolean]
  def authentication_successful?; end

  # The current user represented by this session.
  #
  # @return [User, nil]
  def current_user; end

  # Sign the provided user in, if approved by the configured sign in guards.
  # If the sign in guard stack returns {SuccessStatus}, the {#current_user}
  # will be set and then remember token cookie will be set to the user's
  # remember token. If the stack returns {FailureStatus}, {#current_user} will
  # be nil.
  #
  # In either event, the resulting status will be yielded to a provided block,
  # if provided. See {SessionsController#create} for an example of how this
  # can be used.
  #
  # @param user [User]
  # @return [void]
  # @yieldparam status [SuccessStatus, FailureStatus] Result of the sign in
  #   operation.
  def sign_in(user, &block); end

  # Invalidates the users remember token and removes the remember token cookie
  # from the store. The invalidation of the remember token causes any other
  # sessions that are signed in from other locations to also be invalidated on
  # their next request. This is because all Clearance sessions for a given
  # user share a remember token.
  #
  # @return [void]
  def sign_out; end

  # True if {#current_user} is set.
  #
  # @return [Boolean]
  def signed_in?; end

  # True if {#current_user} is not set
  #
  # @return [Boolean]
  def signed_out?; end

  private

  # @api private
  def configured_cookie_domain; end

  # @api private
  def cookie_options(value); end

  # @api private
  def cookies; end

  # @api private
  def delete_cookie_options; end

  # @api private
  def domain; end

  # @api private
  def expires_configuration; end

  # @api private
  def initialize_sign_in_guard_stack; end

  # @api private
  def remember_token; end

  # @api private
  def remember_token_cookie; end

  # @api private
  def remember_token_expires; end

  # @api private
  def request_with_env; end

  # @api private
  def run_sign_in_stack; end

  # @api private
  def set_remember_token(token); end

  # @api private
  # @return [Boolean]
  def signed_in_with_remember_token?; end

  # @api private
  def user_from_remember_token(token); end
end

# The base class for {DefaultSignInGuard} and all custom sign in guards.
#
# Sign in guards provide you with fine-grained control over the process of
# signing in a user. Each guard is run in order and can do one of the
# following:
#
# * Fail the sign in process
# * Call the next guard in the stack
# * Short circuit all remaining guards, declaring sign in successfull.
#
# Sign In Guards could be used, for instance, to require that a user confirm
# their email address before being allowed to sign in.
#
#     # in config/initializers/clearance.rb
#     Clearance.configure do |config|
#       config.sign_in_guards = [ConfirmationGuard]
#     end
#
#     # in lib/guards/confirmation_guard.rb
#     class ConfirmationGuard < Clearance::SignInGuard
#       def call
#         if signed_in? && current_user.email_confirmed?
#           next_guard
#         else
#           failure("You must confirm your email address.")
#         end
#       end
#     end
#
# Calling `success` or `failure` in any guard short circuits all of the
# remaining guards in the stack. In most cases, you will want to either call
# `failure` or `next_guard`. The {DefaultSignInGuard} will always be the final
# guard called and will handle calling `success` if appropriate.
#
# The stack is designed such that calling `call` will eventually return
# {SuccessStatus} or {FailureStatus}, thus halting the chain.
class Clearance::SignInGuard
  # Creates an instance of a sign in guard.
  #
  # This is called by {Session} automatically using the array of guards
  # configured in {Configuration#sign_in_guards} and the {DefaultSignInGuard}.
  # There is no reason for users of Clearance to concern themselves with the
  # initialization of each guard or the stack as a whole.
  #
  # @param session [Session] The current clearance session
  # @param stack [[SignInGuard]] The sign in guards that come after this
  #   guard in the stack
  # @return [SignInGuard] a new instance of SignInGuard
  def initialize(session, stack = T.unsafe(nil)); end

  # Indicates this guard failed, and the entire sign in process should fail as
  # a result.
  #
  # @param message [String] The reason the guard failed.
  # @return [FailureStatus]
  def failure(message); end

  # Passes off responsibility for determining success or failure to the next
  # guard in the stack.
  #
  # @return [SuccessStatus, FailureStatus]
  def next_guard; end

  # Indicates the entire sign in operation is successful and that no further
  # guards should be run.
  #
  # In most cases your guards will want to delegate this responsibility to the
  # {DefaultSignInGuard}, allowing the entire stack to execute. In that case,
  # your custom guard would likely want to call `next_guard` instead.
  #
  # @return [SuccessStatus]
  def success; end

  private

  # The user currently stored in the clearance environment.
  def current_user; end

  # Returns the value of attribute session.
  def session; end

  # True if there is a currently a user stored in the clearance environment.
  #
  # @return [Boolean]
  def signed_in?; end

  # Returns the value of attribute stack.
  def stack; end
end

# Indicates a user was successfully signed in, passing all {SignInGuard}s.
class Clearance::SuccessStatus
  # Is true, indicating that the sign in was successful.
  #
  # @return [Boolean]
  def success?; end
end

# Random token used for password reset and remember tokens.
# Clearance tokens are also public API and are inteded to be used anywhere you
# need a random token to correspond to a given user (e.g. you added an email
# confirmation token).
class Clearance::Token
  class << self
    # Generate a new random, 20 byte hex token.
    #
    # @return [String]
    def new; end
  end
end

# Required to be included in your configued user class, which is `User` by
# default, but can be changed with {Configuration#user_model=}.
#
#     class User
#       include Clearance::User
#
#       # ...
#     end
#
# This will also include methods exposed by your password strategy, which can
# be configured with {Configuration#password_strategy=}. By default, this is
# {PasswordStrategies::BCrypt}.
#
# ## Validations
#
# These validations are added to the class that the {User} module is mixed
# into.
#
# * If {#email_optional?} is false, {#email} is validated for presence,
#   uniqueness and email format (using the `email_validator` gem in strict
#   mode).
# * If {#skip_password_validation?} is false, {#password} is validated
#   for presence.
#
# ## Callbacks
#
# * {#normalize_email} will be called on `before_validation`
# * {#generate_remember_token} will be called on `before_create`
module Clearance::User
  extend ::ActiveSupport::Concern
  include ::Clearance::User::Validations
  include ::Clearance::User::Callbacks
  include ::Clearance::PasswordStrategies::BCrypt

  mixes_in_class_methods ::Clearance::User::ClassMethods

  # Generates a {#confirmation_token} for the user, which allows them to reset
  # their password via an email link.
  #
  # Calling `forgot_password!` will cause the user model to be saved without
  # validations. Any other changes you made to this user instance will also
  # be persisted, without validation. It is inteded to be called on an
  # instance with no changes (`dirty? == false`).
  #
  # @return [Boolean] Was the save successful?
  def forgot_password!; end

  # Generates a new {#remember_token} for the user, which will have the effect
  # of signing all of the user's current sessions out. This is called
  # internally by {Session#sign_out}.
  #
  # Calling `reset_remember_token!` will cause the user model to be saved
  # without validations. Any other changes you made to this user instance will
  # also be persisted, without validation. It is inteded to be called on an
  # instance with no changes (`dirty? == false`).
  #
  # @return [Boolean] Was the save successful?
  def reset_remember_token!; end

  # Sets the user's password to the new value, using the `password=` method on
  # the configured password strategy. By default, this is
  # {PasswordStrategies::BCrypt#password=}.
  #
  # This also has the side-effect of blanking the {#confirmation_token} and
  # rotating the `#remember_token`.
  #
  # Validations will be run as part of this update. If the user instance is
  # not valid, the password change will not be persisted, and this method will
  # return `false`.
  #
  # @return [Boolean] Was the save successful?
  def update_password(new_password); end

  private

  # Always false. Override this method in your user model to allow for other
  # forms of user authentication (username, Facebook, etc).
  #
  # @return [false]
  def email_optional?; end

  # Sets the {#confirmation_token} on the instance to a new value generated by
  # {Token.new}. The change is not automatically persisted. If you would like
  # to generate and save in a single method call, use {#forgot_password!}.
  #
  # @return [String] The new confirmation token
  def generate_confirmation_token; end

  # Sets the {#remember_token} on the instance to a new value generated by
  # {Token.new}. The change is not automatically persisted. If you would like
  # to generate and save in a single method call, use
  # {#reset_remember_token!}.
  #
  # @return [String] The new remember token
  def generate_remember_token; end

  # Sets the email on this instance to the value returned by
  # {.normalize_email}
  #
  # @return [String]
  def normalize_email; end

  # Always false. Override this method in your user model to allow for other
  # forms of user authentication (username, Facebook, etc).
  #
  # @return [false]
  def password_optional?; end

  # True if {#password_optional?} is true or if the user already has an
  # {#encrypted_password} that is not changing.
  #
  # @return [Boolean]
  def skip_password_validation?; end
end

# @api private
module Clearance::User::Callbacks
  extend ::ActiveSupport::Concern
end

# @api private
module Clearance::User::ClassMethods
  # @api private
  def authenticate(email, password); end

  # @api private
  def find_by_normalized_email(email); end

  # @api private
  def normalize_email(email); end

  private

  # @api private
  def password_strategy; end

  # @api private
  def prevent_timing_attack; end
end

# @api private
Clearance::User::ClassMethods::DUMMY_PASSWORD = T.let(T.unsafe(nil), String)

# @api private
module Clearance::User::Validations
  extend ::ActiveSupport::Concern
end
