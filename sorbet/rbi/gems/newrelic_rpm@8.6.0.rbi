# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `newrelic_rpm` gem.
# Please instead update this file by running `bin/tapioca gem newrelic_rpm`.

module DependencyDetection
  private

  def defer(&block); end
  def dependency_by_name(name); end
  def detect!; end
  def installed?(name); end
  def items; end
  def items=(new_items); end

  class << self
    def defer(&block); end
    def dependency_by_name(name); end
    def detect!; end

    # @return [Boolean]
    def installed?(name); end

    def items; end
    def items=(new_items); end
  end
end

class DependencyDetection::Dependent
  # @return [Dependent] a new instance of Dependent
  def initialize; end

  # @return [Boolean]
  def allowed_by_config?; end

  def auto_configured?; end
  def chain_configured?; end
  def chain_instrument(instrumenting_module, supportability_name = T.unsafe(nil)); end
  def chain_instrument_target(target, instrumenting_module, supportability_name = T.unsafe(nil)); end
  def check_dependencies; end
  def config_key; end
  def config_name; end

  # Sets the attribute config_name
  #
  # @param value the value to set the attribute config_name to.
  def config_name=(_arg0); end

  def config_value; end
  def configure_with(new_config_name); end
  def conflicts_with_prepend(&block); end

  # Returns the value of attribute dependencies.
  def dependencies; end

  # @return [Boolean]
  def dependencies_satisfied?; end

  def depends_on(&block); end

  # TODO: Remove in 8.0
  # will only return true if a disabled key is found and is truthy
  #
  # @return [Boolean]
  def deprecated_disabled_configured?; end

  def disabled_configured?; end
  def execute; end

  # Returns the value of attribute executed.
  def executed; end

  def executed!; end
  def executes(&block); end

  # Extracts the instrumented library name from the instrumenting module's name
  # Given "NewRelic::Agent::Instrumentation::NetHTTP::Prepend"
  # Will extract "NetHTTP" which is in the 2nd to last spot
  def extract_supportability_name(instrumenting_module); end

  # fetches and transform potentially invalid value given to one of the valid config values
  # logs the resolved value during debug mode.
  def fetch_config_value(key); end

  def log_and_instrument(method, instrumenting_module, supportability_name); end

  # Returns the value of attribute name.
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  def name=(_arg0); end

  def named(new_name); end
  def prepend_configured?; end

  # Returns the value of attribute prepend_conflicts.
  def prepend_conflicts; end

  # @return [Boolean]
  def prepend_conflicts?; end

  def prepend_instrument(target_class, instrumenting_module, supportability_name = T.unsafe(nil)); end
  def source_location_for(klass, method_name); end

  # @return [Boolean]
  def use_prepend?; end

  # returns only a valid value for instrumentation configuration
  # If user uses "enabled" it's converted to "auto"
  def valid_config_value(retrieved_value); end
end

DependencyDetection::Dependent::AUTO_CONFIG_VALUE = T.let(T.unsafe(nil), Symbol)
DependencyDetection::Dependent::VALID_CONFIG_VALUES = T.let(T.unsafe(nil), Array)
module NewRelic; end

# This module contains most of the public API methods for the Ruby Agent.
#
# For adding custom instrumentation to method invocations, see
# the docs for {NewRelic::Agent::MethodTracer} and
# {NewRelic::Agent::MethodTracer::ClassMethods}.
#
# For information on how to trace transactions in non-Rack contexts,
# see {NewRelic::Agent::Instrumentation::ControllerInstrumentation}.
#
# For general documentation about the Ruby agent, see:
# https://docs.newrelic.com/docs/agents/ruby-agent
#
# @api public
module NewRelic::Agent
  extend ::NewRelic::Agent
  extend ::Forwardable
  extend ::NewRelic::SupportabilityHelper

  # Add attributes to the transaction trace, Insights Transaction event, and
  # any traced errors recorded for the current transaction.
  #
  # If Browser Monitoring is enabled, and the
  # browser_monitoring.attributes.enabled configuration setting is true,
  # these custom attributes will also be present in the script injected into
  # the response body, making them available on Insights PageView events.
  #
  # @api public
  # @param params [Hash] A Hash of attributes to be attached to the transaction event.
  #   Keys should be strings or symbols, and values
  #   may be strings, symbols, numeric values or
  #   booleans.
  def add_custom_attributes(params); end

  # Add custom attributes to the span event for the current span. Attributes will be visible on spans in the
  # New Relic Distributed Tracing UI and on span events in New Relic Insights.
  #
  # Custom attributes will not be transmitted when +high_security+ setting is enabled or
  # +custom_attributes+ setting is disabled.
  #
  # @api public
  # @param params [Hash] A Hash of attributes to be attached to the span event.
  #   Keys should be strings or symbols, and values
  #   may be strings, symbols, numeric values or
  #   booleans.
  # @see https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/glossary#span
  def add_custom_span_attributes(params); end

  # @api public
  def add_deferred_method_tracers_now; end

  # Add instrumentation files to the agent.  The argument should be
  # a glob matching ruby scripts which will be executed at the time
  # instrumentation is loaded.  Since instrumentation is not loaded
  # when the agent is not running it's better to use this method to
  # register instrumentation than just loading the files directly,
  # although that probably also works.
  #
  # @api public
  def add_instrumentation(file_pattern); end

  # A third-party class may call add_method_tracer before the agent
  # is initialized; these methods enable us to defer these calls
  # until we have started up and can process them.
  #
  # @api public
  def add_or_defer_method_tracer(receiver, method_name, metric_name, options); end

  # Register this method as a callback for processes that fork
  # jobs.
  #
  # If the master/parent connects to the agent prior to forking the
  # agent in the forked process will use that agent_run.  Otherwise
  # the forked process will establish a new connection with the
  # server.
  #
  # Use this especially when you fork the process to run background
  # jobs or other work.  If you are doing this with a web dispatcher
  # that forks worker processes then you will need to force the
  # agent to reconnect, which it won't do by default.  Passenger and
  # Rainbows and Unicorn are already handled, nothing special needed for them.
  #
  # Options:
  # * <tt>:force_reconnect => true</tt> to force the spawned process to
  #   establish a new connection, such as when forking a long running process.
  #   The default is false--it will only connect to the server if the parent
  #   had not connected.
  # * <tt>:keep_retrying => false</tt> if we try to initiate a new
  #   connection, this tells me to only try it once so this method returns
  #   quickly if there is some kind of latency with the server.
  #
  # @api public
  def after_fork(options = T.unsafe(nil)); end

  # The singleton Agent instance.  Used internally.
  #
  # @api public
  def agent; end

  # @api public
  def agent=(new_instance); end

  # This method returns a string suitable for inclusion in a page - known as
  # 'manual instrumentation' for Real User Monitoring. Can return either a
  # script tag with associated javascript, or in the case of disabled Real
  # User Monitoring, an empty string
  #
  # This is the header string - it should be placed as high in the page as is
  # reasonably possible - that is, before any style or javascript inclusions,
  # but after any header-related meta tags
  #
  # In previous agents there was a corresponding footer required, but all the
  # work is now done by this single method.
  #
  # @api public
  # @param nonce [String] The nonce to use in the javascript tag for browser instrumentation
  def browser_timing_header(nonce = T.unsafe(nil)); end

  # @api public
  def config; end

  # Yield to the block without collecting any metrics or traces in
  # any of the subsequent calls.  If executed recursively, will keep
  # track of the first entry point and turn on tracing again after
  # leaving that block.  This uses the thread local Tracer::State.
  #
  # @api public
  def disable_all_tracing; end

  # This method sets the state of sql recording in the transaction
  # sampler feature. Within the given block, no sql will be recorded
  #
  # usage:
  #
  #   NewRelic::Agent.disable_sql_recording do
  #     ...
  #   end
  #
  # @api public
  def disable_sql_recording; end

  # This method disables the recording of transaction traces in the given
  # block.  See also #disable_all_tracing
  #
  # @api public
  def disable_transaction_tracing; end

  # Clear out any data the agent has buffered but has not yet transmitted
  # to the collector.
  #
  # @api public
  def drop_buffered_data; end

  # Get the name of the current running transaction.  This is useful if you
  # want to modify the default name.
  #
  # @api public
  def get_transaction_name; end

  # This method disables the recording of Apdex metrics in the current
  # transaction.
  #
  # @api public
  def ignore_apdex; end

  # This method disables browser monitoring javascript injection in the
  # current transaction.
  #
  # @api public
  def ignore_enduser; end

  # Set a filter to be applied to errors that the Ruby Agent will
  # track.  The block should evalute to the exception to track
  # (which could be different from the original exception) or nil to
  # ignore this exception.
  #
  # The block is yielded to with the exception to filter.
  #
  # Return the new block or the existing filter Proc if no block is passed.
  #
  # @api public
  def ignore_error_filter(&block); end

  # This method disables the recording of the current transaction. No metrics,
  # traced errors, transaction traces, Insights events, slow SQL traces,
  # or RUM injection will happen for this transaction.
  #
  # @api public
  def ignore_transaction; end

  # THREAD_LOCAL_ACCESS
  #
  # @api public
  def increment_metric(metric_name, amount = T.unsafe(nil)); end

  # The singleton Agent instance.  Used internally.
  #
  # @api public
  def instance; end

  # Returns a new hash containing trace and entity metadata that can be used
  # to relate data to a trace or to an entity in APM.
  #
  # This hash includes:
  # * trace.id    - The current trace id, if there is a current trace id. This
  #   value may be omitted.
  # * span.id     - The current span id, if there is a current span.  This
  #   value may be omitted.
  # * entity.name - The name of the current application. This is read from
  #   the +app_name+ key in your config.  If there are multiple application
  #   names, the first one is used.
  # * entity.type - The entity type is hardcoded to the string +'SERVICE'+.
  # * entity.guid - The guid of the current entity.
  # * hostname    - The fully qualified hostname.
  #
  # @api public
  def linking_metadata; end

  # Primary interface to logging is fronted by this accessor
  # Access via ::NewRelic::Agent.logger
  #
  # @api public
  def logger; end

  # @api public
  def logger=(log); end

  # Call this to manually start the Agent in situations where the Agent does
  # not auto-start.
  #
  # When the app environment loads, so does the Agent. However, the
  # Agent will only connect to the service if a web front-end is found. If
  # you want to selectively monitor ruby processes that don't use
  # web plugins, then call this method in your code and the Agent
  # will fire up and start reporting to the service.
  #
  # Options are passed in as overrides for values in the
  # newrelic.yml, such as app_name.  In addition, the option +log+
  # will take a logger that will be used instead of the standard
  # file logger.  The setting for the newrelic.yml section to use
  # (ie, RAILS_ENV) can be overridden with an :env argument.
  #
  # @api public
  def manual_start(options = T.unsafe(nil)); end

  # Send an error to New Relic.
  #
  # Any option keys other than the ones listed here are treated as
  # <code>:custom_params</code>.
  #
  # *Note:* Previous versions of the agent allowed passing
  # <code>:request_params</code>, but those are now ignored.  If you
  # need to record the request parameters, call this method inside a
  # transaction or pass the information in
  # <code>:custom_params</code>.
  #
  # Most of the time, you do not need to specify the
  # <code>:uri</code> or <code>:metric</code> options; only pass
  # them if you are calling <code>notice_error</code> outside a
  # transaction.
  #
  # @api public
  # @option options
  # @option options
  # @option options
  # @option options
  # @param exception [Exception] Error you wish to send
  # @param options [Hash] Modify how New Relic processes the error
  def notice_error(exception, options = T.unsafe(nil)); end

  # Fire an event of the specified +event_type+, passing it an the given +args+
  # to any registered handlers.
  #
  # @api public
  def notify(event_type, *args); end

  # Record a custom event to be sent to New Relic Insights.
  # The recorded event will be buffered in memory until the next time the
  # agent sends data to New Relic's servers.
  #
  # If you want to be able to tie the information recorded via this call back
  # to the web request or background job that it happened in, you may want to
  # instead use the add_custom_attributes API call to attach attributes to
  # the Transaction event that will automatically be generated for the
  # request.
  #
  # A timestamp will be automatically added to the recorded event when this
  # method is called.
  #
  # @api public
  # @param event_type [Symbol or String] The name of the event type to record. Event
  #   types must consist of only alphanumeric
  #   characters, '_', ':', or ' '.
  # @param event_attrs [Hash] A Hash of attributes to be attached to the event.
  #   Keys should be strings or symbols, and values
  #   may be strings, symbols, numeric values or
  #   booleans.
  def record_custom_event(event_type, event_attrs); end

  # Record a value for the given metric name.
  #
  # This method should be used to record event-based metrics such as method
  # calls that are associated with a specific duration or magnitude.
  #
  # +metric_name+ should follow a slash separated path convention. Application
  # specific metrics should begin with "Custom/".
  #
  # +value+ should be either a single Numeric value representing the duration/
  # magnitude of the event being recorded, or a Hash containing :count,
  # :total, :min, :max, and :sum_of_squares keys. The latter form is useful
  # for recording pre-aggregated metrics collected externally.
  #
  # This method is safe to use from any thread.
  #
  # @api public
  def record_metric(metric_name, value); end

  def register_report_channel(*args, **_arg1, &block); end

  # Require agent testing helper methods
  #
  # @api public
  def require_test_helper; end

  # For testing
  # Important that we don't change the instance or we orphan callbacks
  #
  # @api public
  def reset_config; end

  # This method sets the block sent to this method as a sql
  # obfuscator.  The block will be called with a single String SQL
  # statement to obfuscate.  The method must return the obfuscated
  # String SQL.  If chaining of obfuscators is required, use type =
  # :before or :after
  #
  # type = :before, :replace, :after
  #
  # Example:
  #
  #    NewRelic::Agent.set_sql_obfuscator(:replace) do |sql|
  #       my_obfuscator(sql)
  #    end
  #
  # @api public
  def set_sql_obfuscator(type = T.unsafe(nil), &block); end

  # Set the name of the current running transaction.  The agent will
  # apply a reasonable default based on framework routing, but in
  # cases where this is insufficient, this can be used to manually
  # control the name of the transaction.
  #
  # The category of transaction can be specified via the +:category+ option.
  # The following are the only valid categories:
  #
  # * <tt>:category => :controller</tt> indicates that this is a
  #   controller action and will appear with all the other actions.
  # * <tt>:category => :task</tt> indicates that this is a
  #   background task and will show up in New Relic with other background
  #   tasks instead of in the controllers list
  # * <tt>:category => :middleware</tt> if you are instrumenting a rack
  #   middleware call.  The <tt>:name</tt> is optional, useful if you
  #   have more than one potential transaction in the #call.
  # * <tt>:category => :uri</tt> indicates that this is a
  #   web transaction whose name is a normalized URI, where  'normalized'
  #   means the URI does not have any elements with data in them such
  #   as in many REST URIs.
  #
  # The default category is the same as the running transaction.
  #
  # @api public
  def set_transaction_name(name, options = T.unsafe(nil)); end

  # Shutdown the agent.  Call this before exiting.  Sends any queued data
  # and kills the background thread.
  #
  # @api public
  # @param options [Hash] Unused options Hash, for back compatibility only
  def shutdown(options = T.unsafe(nil)); end

  # Subscribe to events of +event_type+, calling the given +handler+
  # when one is sent.
  #
  # @api public
  def subscribe(event_type, &handler); end

  # Check to see if we are capturing metrics currently on this thread.
  #
  # @api public
  # @return [Boolean]
  def tl_is_execution_traced?; end

  # helper method to check the thread local to determine whether sql
  # is being recorded or not
  #
  # @api public
  # @return [Boolean]
  def tl_is_sql_recorded?; end

  # Yield to a block that is run with a database metric name context.  This means
  # the Database instrumentation will use this for the metric name if it does not
  # otherwise know about a model.  This is re-entrant.
  #
  # identify the operation with.
  #
  # @api public
  # @param model [String, Class, #to_s] the DB model class
  # @param method [String] the name of the finder method or other method to
  def with_database_metric_name(model, method = T.unsafe(nil), product = T.unsafe(nil), &block); end
end

class NewRelic::Agent::AdaptiveSampler
  # @return [AdaptiveSampler] a new instance of AdaptiveSampler
  def initialize(target_samples = T.unsafe(nil), period_duration = T.unsafe(nil)); end

  def exponential_backoff; end

  # Called at the beginning of each transaction, increments seen and
  # returns a boolean indicating if we should mark the transaction as
  # sampled. This uses the adaptive sampling algorithm.
  #
  # @return [Boolean]
  def sampled?; end

  def stats; end

  private

  def register_config_callbacks; end
  def register_sampling_period_callback; end
  def register_sampling_target_callback; end
  def reset_if_period_expired!; end
end

# The Agent is a singleton that is instantiated when the plugin is
# activated.  It collects performance data from ruby applications
# in realtime as the application runs, and periodically sends that
# data to the NewRelic server.
class NewRelic::Agent::Agent
  include ::NewRelic::Agent::Agent::InstanceMethods::Start
  include ::NewRelic::Agent::Agent::InstanceMethods::StartWorkerThread
  include ::NewRelic::Agent::Agent::InstanceMethods::Connect
  include ::NewRelic::Agent::Agent::InstanceMethods
  extend ::NewRelic::Agent::Agent::ClassMethods

  # @return [Agent] a new instance of Agent
  def initialize; end

  def refresh_attribute_filter; end
  def setup_attribute_filter; end

  class << self
    def config; end
  end
end

# contains all the class-level methods for NewRelic::Agent::Agent
module NewRelic::Agent::Agent::ClassMethods
  # Should only be called by NewRelic::Control - returns a
  # memoized singleton instance of the agent, creating one if needed
  def instance; end
end

# Holds all the methods defined on NewRelic::Agent::Agent
# instances
module NewRelic::Agent::Agent::InstanceMethods
  include ::NewRelic::Agent::Agent::InstanceMethods::Start
  include ::NewRelic::Agent::Agent::InstanceMethods::StartWorkerThread
  include ::NewRelic::Agent::Agent::InstanceMethods::Connect

  # Returns the value of attribute adaptive_sampler.
  def adaptive_sampler; end

  # This method should be called in a forked process after a fork.
  # It assumes the parent process initialized the agent, but does
  # not assume the agent started.
  #
  # The call is idempotent, but not re-entrant.
  #
  # * It clears any metrics carried over from the parent process
  # * Restarts the sampler thread if necessary
  # * Initiates a new agent run and worker loop unless that was done
  #   in the parent process and +:force_reconnect+ is not true
  #
  # Options:
  # * <tt>:force_reconnect => true</tt> to force the spawned process to
  #   establish a new connection, such as when forking a long running process.
  #   The default is false--it will only connect to the server if the parent
  #   had not connected.
  # * <tt>:keep_retrying => false</tt> if we try to initiate a new
  #   connection, this tells me to only try it once so this method returns
  #   quickly if there is some kind of latency with the server.
  def after_fork(options = T.unsafe(nil)); end

  # manages agent commands we receive from the collector, and the handlers
  def agent_command_router; end

  def agent_id=(agent_id); end

  # Check to see if the agent should start, returning +true+ if it should.
  #
  # @return [Boolean]
  def agent_should_start?; end

  # Returns the value of attribute attribute_filter.
  def attribute_filter; end

  # Returns the value of attribute cross_app_encoding_bytes.
  def cross_app_encoding_bytes; end

  # cross application tracing ids and encoding
  def cross_process_id; end

  # Returns the value of attribute custom_event_aggregator.
  def custom_event_aggregator; end

  # @return [Boolean]
  def defer_for_delayed_job?; end

  # Clear out the metric data, errors, and transaction traces, etc.
  def drop_buffered_data; end

  # Returns the value of attribute environment_report.
  def environment_report; end

  # error collector is a simple collection of recorded errors
  def error_collector; end

  # Global events dispatcher. This will provides our primary mechanism
  # for agent-wide events, such as finishing configuration, error notification
  # and request before/after from Rack.
  def events; end

  def flush_pipe_data; end

  # Returns the value of attribute harvest_samplers.
  def harvest_samplers; end

  # Responsbile for restarting the harvest thread
  def harvester; end

  def install_pipe_service(channel_id); end

  # builder for JS agent scripts to inject
  def javascript_instrumentor; end

  # Returns the value of attribute log_event_aggregator.
  def log_event_aggregator; end

  def merge_data_for_endpoint(endpoint, data); end

  # listens and responds to events that need to process headers
  # for synthetics and distributed tracing
  def monitors; end

  # GC::Profiler.total_time is not monotonic so we wrap it.
  def monotonic_gc_profiler; end

  # Pop the current trace execution status.  Restore trace execution status
  # to what it was before we pushed the current flag.
  def pop_trace_execution_flag; end

  # Push flag indicating whether we should be tracing in this
  # thread. This uses a stack which allows us to disable tracing
  # children of a transaction without affecting the tracing of
  # the whole transaction
  def push_trace_execution_flag(should_trace = T.unsafe(nil)); end

  # whether we should record raw, obfuscated, or no sql
  def record_sql; end

  # Clear out state for any objects that we know lock from our parents
  # This is necessary for cases where we're in a forked child and Ruby
  # might be holding locks for background thread that aren't there anymore.
  def reset_objects_with_locks; end

  def revert_to_default_configuration; end

  # service for communicating with collector
  def service; end

  # service for communicating with collector
  def service=(_arg0); end

  # Sets a thread local variable as to whether we should or
  # should not record sql in the current thread. Returns the
  # previous value, if there is one
  def set_record_sql(should_record); end

  # Attempt a graceful shutdown of the agent, flushing any remaining
  # data.
  def shutdown; end

  # Returns the value of attribute span_event_aggregator.
  def span_event_aggregator; end

  # Returns the value of attribute sql_sampler.
  def sql_sampler; end

  # Logs a bunch of data and starts the agent, if needed
  def start; end

  # True if we have initialized and completed 'start'
  #
  # @return [Boolean]
  def started?; end

  # the statistics engine that holds all the timeslice data
  def stats_engine; end

  # If the @worker_thread encounters an error during the attempt to connect to the collector
  # then the connect attempts enter an exponential backoff retry loop.  To avoid potential
  # race conditions with shutting down while also attempting to reconnect, we join the
  # pending data to the server, but without waiting indefinitely for a reconnect to succeed.
  # The use-case where this typically arises is in cronjob scheduled rake tasks where there's
  # also some network stability/latency issues happening.
  def stop_event_loop; end

  def synthetics_event_aggregator; end
  def transaction_event_aggregator; end

  # Returns the value of attribute transaction_event_recorder.
  def transaction_event_recorder; end

  # Transaction and metric renaming rules as provided by the
  # collector on connect.  The former are applied during txns,
  # the latter during harvest.
  def transaction_rules; end

  # Transaction and metric renaming rules as provided by the
  # collector on connect.  The former are applied during txns,
  # the latter during harvest.
  def transaction_rules=(_arg0); end

  # the transaction sampler that handles recording transactions
  def transaction_sampler; end

  def trap_signals_for_litespeed; end
  def untraced_graceful_disconnect; end

  private

  def check_for_and_handle_agent_commands; end

  # Establish a connection to New Relic servers.
  #
  # By default, if a connection has already been established, this method
  # will be a no-op.
  #
  # @option options
  # @option options
  # @param options [Hash]
  def connect(options = T.unsafe(nil)); end

  def container_for_endpoint(endpoint); end

  # A shorthand for NewRelic::Control.instance
  def control; end

  # Delegates to the control class to determine the root
  # directory of this project
  def determine_home_directory; end

  # This method contacts the server to send remaining data and
  # let the server know that the agent is shutting down - this
  # allows us to do things like accurately set the end of the
  # lifetime of the process
  #
  # If this process comes from a parent process, it will not
  # disconnect, so that the parent process can continue to send data
  def graceful_disconnect; end

  def harvest_and_send_analytic_event_data; end
  def harvest_and_send_custom_event_data; end
  def harvest_and_send_error_event_data; end
  def harvest_and_send_errors; end
  def harvest_and_send_for_agent_commands; end

  # Harvests data from the given container, sends it to the named endpoint
  # on the service, and automatically merges back in upon a recoverable
  # failure.
  #
  # The given container should respond to:
  #
  #  #harvest!
  #    returns a payload that contains enumerable collection of data items and
  #    optional metadata to be sent to the collector.
  #
  #  #reset!
  #    drop any stored data and reset to a clean state.
  #
  #  #merge!(payload)
  #    merge the given payload back into the internal buffer of the
  #    container, so that it may be harvested again later.
  def harvest_and_send_from_container(container, endpoint); end

  def harvest_and_send_log_event_data; end
  def harvest_and_send_slowest_sql; end
  def harvest_and_send_span_event_data; end
  def harvest_and_send_timeslice_data; end

  # This handles getting the transaction traces and then sending
  # them across the wire.  This includes gathering SQL
  # explanations, stripping out stack traces, and normalizing
  # SQL.  note that we explain only the sql statements whose
  # nodes' execution times exceed our threshold (to avoid
  # unnecessary overhead of running explains on fast queries.)
  def harvest_and_send_transaction_traces; end

  def harvest_from_container(container, endpoint); end
  def harvest_size(container, items); end
  def log_remote_unavailable(endpoint, e); end
  def send_data_to_endpoint(endpoint, payload, container); end

  # Try to launch the worker thread and connect to the server.
  #
  # See #connect for a description of connection_options.
  def start_worker_thread(connection_options = T.unsafe(nil)); end

  def transmit_analytic_event_data; end
  def transmit_custom_event_data; end
  def transmit_data; end
  def transmit_error_event_data; end
  def transmit_log_event_data; end
  def transmit_single_data_type(harvest_method, supportability_name); end
  def transmit_span_event_data; end
end

NewRelic::Agent::Agent::InstanceMethods::CUSTOM_EVENT = T.let(T.unsafe(nil), String)

# This module is an artifact of a refactoring of the connect
# method - all of its methods are used in that context, so it
# can be refactored at will. It should be fully tested
module NewRelic::Agent::Agent::InstanceMethods::Connect
  # apdex_f is always 4 times the apdex_t
  def apdex_f; end

  # number of attempts we've made to contact the server
  def connect_attempts; end

  # number of attempts we've made to contact the server
  def connect_attempts=(_arg0); end

  # Per the spec at
  # /agents/agent-specs/Collector-Response-Handling.md, retry
  # connections after a specific backoff sequence to prevent
  # hammering the server.
  def connect_retry_period; end

  # Builds the payload to send to the connect service,
  # connects, then configures the agent using the response from
  # the connect service
  def connect_to_server; end

  # @return [Boolean]
  def connected?; end

  # Disconnect just sets the connect state to disconnected, preventing
  # further retries.
  def disconnect; end

  # @return [Boolean]
  def disconnected?; end

  # Checks whether we should send environment info, and if so,
  # returns the snapshot from the local environment.
  # Generating the EnvironmentReport has the potential to trigger
  # require calls in Rails environments, so this method should only
  # be called synchronously from on the main thread.
  def environment_for_connect; end

  # Constructs and memoizes an event_harvest_config hash to be used in
  # the payload sent during connect (and reconnect)
  def event_harvest_config; end

  def handle_license_error(error); end
  def handle_unrecoverable_agent_error(error); end
  def log_collector_messages(messages); end

  # Logs when we connect to the server, for debugging purposes
  # - makes sure we know if an agent has not connected
  def log_connection(config_data); end

  # When we have a problem connecting to the server, we need
  # to tell the user what happened, since this is not an error
  # we can handle gracefully.
  def log_error(error); end

  def note_connect_failure; end
  def should_connect?(force = T.unsafe(nil)); end
  def signal_connected; end
  def wait_on_connect(timeout); end

  # Used for testing to let us know we've actually started to wait
  #
  # @return [Boolean]
  def waited_on_connect?; end
end

class NewRelic::Agent::Agent::InstanceMethods::Connect::WaitOnConnectTimeout < ::StandardError; end
NewRelic::Agent::Agent::InstanceMethods::ERROR_EVENT = T.let(T.unsafe(nil), String)
NewRelic::Agent::Agent::InstanceMethods::LOG_EVENT = T.let(T.unsafe(nil), String)
NewRelic::Agent::Agent::InstanceMethods::SPAN_EVENT = T.let(T.unsafe(nil), String)

# Herein lies the corpse of the former 'start' method. May
# its unmatched flog score rest in pieces.
module NewRelic::Agent::Agent::InstanceMethods::Start
  # Check whether we have already started, which is an error condition
  #
  # @return [Boolean]
  def already_started?; end

  # Logs the configured application names
  #
  # @return [Boolean]
  def app_name_configured?; end

  # Sanity-check the agent configuration and start the agent,
  # setting up the worker thread and the exit handler to shut
  # down the agent
  def check_config_and_start_agent; end

  # Connecting in the foreground blocks further startup of the
  # agent until we have a connection - useful in cases where
  # you're trying to log a very-short-running process and want
  # to get statistics from before a server connection
  # (typically 20 seconds) exists
  def connect_in_foreground; end

  def correct_license_length; end

  # Return true if we're using resque and it hasn't had a chance to (potentially)
  # daemonize itself. This avoids hanging when there's a Thread started
  # before Resque calls Process.daemon (Jira RUBY-857)
  #
  # @return [Boolean]
  def defer_for_resque?; end

  # The agent is disabled when it is not force enabled by the
  # 'agent_enabled' option (e.g. in a manual start), or
  # enabled normally through the configuration file
  #
  # @return [Boolean]
  def disabled?; end

  def has_correct_license_key?; end
  def has_license_key?; end

  # @return [Boolean]
  def in_resque_child_process?; end

  def install_exit_handler; end
  def log_app_name; end

  # Logs the dispatcher to the log file to assist with
  # debugging. When no debugger is present, logs this fact to
  # assist with proper dispatcher detection
  def log_dispatcher; end

  # Log the environment the app thinks it's running in.
  # Useful in debugging, as this is the key for config YAML lookups.
  def log_environment; end

  def log_ignore_url_regexes; end

  # Log startup information that we almost always want to know
  def log_startup; end

  # Classy logging of the agent version and the current pid,
  # so we can disambiguate processes in the log file and make
  # sure they're running a reasonable version
  def log_version_and_pid; end

  # Warn the user if they have configured their agent not to
  # send data, that way we can see this clearly in the log file
  #
  # @return [Boolean]
  def monitoring?; end

  # This is the shared method between the main agent startup and the
  # after_fork call restarting the thread in deferred dispatchers.
  #
  # Treatment of @started and env report is important to get right.
  def setup_and_start_agent(options = T.unsafe(nil)); end

  # @return [Boolean]
  def should_install_exit_handler?; end

  # This matters when the following three criteria are met:
  #
  # 1. A Sinatra 'classic' application is being run
  # 2. The app is being run by executing the main file directly, rather
  #    than via a config.ru file.
  # 3. newrelic_rpm is required *after* sinatra
  #
  # In this case, the entire application runs from an at_exit handler in
  # Sinatra, and if we were to install ours, it would be executed before
  # the one in Sinatra, meaning that we'd shutdown the agent too early
  # and never collect any data.
  #
  # @return [Boolean]
  def sinatra_classic_app?; end

  # If we're using a dispatcher that forks before serving
  # requests, we need to wait until the children are forked
  # before connecting, otherwise the parent process sends useless data
  #
  # @return [Boolean]
  def using_forking_dispatcher?; end
end

# All of this module used to be contained in the
# start_worker_thread method - this is an artifact of
# refactoring and can be moved, renamed, etc at will
module NewRelic::Agent::Agent::InstanceMethods::StartWorkerThread
  # a wrapper method to handle all the errors that can happen
  # in the connection and worker thread system. This
  # guarantees a no-throw from the background thread.
  def catch_errors; end

  def create_and_run_event_loop; end
  def create_event_loop; end

  # This is the method that is run in a new thread in order to
  # background the harvesting and sending of data during the
  # normal operation of the agent.
  #
  # Takes connection options that determine how we should
  # connect to the server, and loops endlessly - typically we
  # never return from this method unless we're shutting down
  # the agent
  def deferred_work!(connection_options); end

  # when a disconnect is requested, stop the current thread, which
  # is the worker thread that gathers data and talks to the
  # server.
  def handle_force_disconnect(error); end

  # Handles the case where the server tells us to restart -
  # this clears the data, clears connection attempts, and
  # waits a while to reconnect.
  def handle_force_restart(error); end

  # Handles an unknown error in the worker thread by logging
  # it and disconnecting the agent, since we are now in an
  # unknown state.
  def handle_other_error(error); end

  # Certain event types may sometimes need to be on the same interval as metrics,
  # so we will check config assigned in EventHarvestConfig to determine the interval
  # on which to report them
  def interval_for(event_type); end
end

NewRelic::Agent::Agent::InstanceMethods::StartWorkerThread::ANALYTIC_EVENT_DATA = T.let(T.unsafe(nil), String)
NewRelic::Agent::Agent::InstanceMethods::StartWorkerThread::CUSTOM_EVENT_DATA = T.let(T.unsafe(nil), String)
NewRelic::Agent::Agent::InstanceMethods::StartWorkerThread::ERROR_EVENT_DATA = T.let(T.unsafe(nil), String)
NewRelic::Agent::Agent::InstanceMethods::StartWorkerThread::LOG_EVENT_DATA = T.let(T.unsafe(nil), String)
NewRelic::Agent::Agent::InstanceMethods::StartWorkerThread::LOG_ONCE_KEYS_RESET_PERIOD = T.let(T.unsafe(nil), Float)
NewRelic::Agent::Agent::InstanceMethods::StartWorkerThread::SPAN_EVENT_DATA = T.let(T.unsafe(nil), String)
NewRelic::Agent::Agent::InstanceMethods::TRANSACTION_EVENT = T.let(T.unsafe(nil), String)

class NewRelic::Agent::AgentLogger
  include ::NewRelic::Agent::LogOnce

  # @return [AgentLogger] a new instance of AgentLogger
  def initialize(root = T.unsafe(nil), override_logger = T.unsafe(nil)); end

  def debug(*msgs, &blk); end
  def error(*msgs, &blk); end
  def fatal(*msgs, &blk); end
  def info(*msgs, &blk); end

  # @return [Boolean]
  def is_startup_logger?; end

  # Use this when you want to log an exception with explicit control over
  # the log level that the backtrace is logged at. If you just want the
  # default behavior of backtraces logged at debug, use one of the methods
  # above and pass an Exception as one of the args.
  def log_exception(level, e, backtrace_level = T.unsafe(nil)); end

  def log_formatter=(formatter); end
  def warn(*msgs, &blk); end

  private

  def backtrace_from_exception(e); end
  def create_log(root, override_logger); end
  def create_log_to_file(root); end
  def create_null_logger; end

  # Don't allow agent logs into agent log forwarding for now
  def disable_log_instrumentation!; end

  def find_or_create_file_path(path_setting, root); end

  # Allows for passing exceptions in explicitly, which format with backtrace
  def format_and_send(level, *msgs, &block); end

  def gather_startup_logs; end
  def set_log_format!; end
  def set_log_level!; end

  # @return [Boolean]
  def wants_stdout?; end

  class << self
    def format_fatal_error(message); end
    def log_level_for(level); end
  end
end

NewRelic::Agent::AgentLogger::LOG_LEVELS = T.let(T.unsafe(nil), Hash)

class NewRelic::Agent::AttributeFilter
  # @return [AttributeFilter] a new instance of AttributeFilter
  def initialize(config); end

  # @return [Boolean]
  def allows?(allowed_destinations, requested_destination); end

  # @return [Boolean]
  def allows_key?(key, destination); end

  def apply(attribute_name, default_destinations); end
  def build_rule(attribute_names, destinations, is_include); end
  def build_uri_rule(excluded_attributes); end

  # For attribute prefixes where we know the default destinations will
  # always be DST_NONE, we can statically determine that any attribute
  # starting with the prefix will not be allowed unless there's an include
  # rule that might match attributes starting with it.
  #
  # This allows us to skip significant preprocessing work (hash/array
  # flattening and type coercion) for HTTP request parameters and job
  # arguments for Sidekiq and Resque in the common case, since none of
  # these attributes are captured by default.
  def cache_prefix_denylist; end

  # @return [Boolean]
  def high_security?; end

  def include_destinations_for_capture_params(capturing); end

  # Note that the given prefix *must* be a Symbol
  #
  # @return [Boolean]
  def might_allow_prefix?(prefix); end

  # @return [Boolean]
  def might_allow_prefix_uncached?(prefix); end

  # Returns the value of attribute rules.
  def rules; end

  # Note the key_cache is a global cache, accessible by multiple threads,
  # but is intentionally left unsynchronized for liveness. Writes will always
  # involve writing the same boolean value for each key, so there is no
  # worry of one value clobbering another. For reads, if a value hasn't been
  # written to the cache yet, the worst that will happen is that it will run
  # through the filter rules again. Both reads and writes will become
  # eventually consistent.
  def setup_key_cache; end
end

NewRelic::Agent::AttributeFilter::DST_ALL = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::AttributeFilter::DST_BROWSER_MONITORING = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::AttributeFilter::DST_ERROR_COLLECTOR = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::AttributeFilter::DST_NONE = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::AttributeFilter::DST_SPAN_EVENTS = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::AttributeFilter::DST_TRANSACTION_EVENTS = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::AttributeFilter::DST_TRANSACTION_SEGMENTS = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::AttributeFilter::DST_TRANSACTION_TRACER = T.let(T.unsafe(nil), Integer)

class NewRelic::Agent::AttributeFilterRule
  # @return [AttributeFilterRule] a new instance of AttributeFilterRule
  def initialize(attribute_name, destinations, is_include); end

  # Rules are sorted from least specific to most specific
  #
  # All else being the same, wildcards are considered less specific
  # All else being the same, include rules are less specific than excludes
  def <=>(other); end

  # Returns the value of attribute attribute_name.
  def attribute_name; end

  # Returns the value of attribute destinations.
  def destinations; end

  # @return [Boolean]
  def empty?; end

  # Returns the value of attribute is_include.
  def is_include; end

  # @return [Boolean]
  def match?(name); end

  # Returns the value of attribute wildcard.
  def wildcard; end
end

module NewRelic::Agent::AttributeProcessing
  private

  def flatten_and_coerce(object, prefix = T.unsafe(nil), result = T.unsafe(nil), &blk); end
  def flatten_and_coerce_array(array, prefix, result, &blk); end
  def flatten_and_coerce_hash(hash, prefix, result, &blk); end

  class << self
    def flatten_and_coerce(object, prefix = T.unsafe(nil), result = T.unsafe(nil), &blk); end
    def flatten_and_coerce_array(array, prefix, result, &blk); end
    def flatten_and_coerce_hash(hash, prefix, result, &blk); end
  end
end

NewRelic::Agent::AttributeProcessing::EMPTY_ARRAY_STRING_LITERAL = T.let(T.unsafe(nil), String)
NewRelic::Agent::AttributeProcessing::EMPTY_HASH_STRING_LITERAL = T.let(T.unsafe(nil), String)

class NewRelic::Agent::Attributes
  # @return [Attributes] a new instance of Attributes
  def initialize(filter); end

  def add_agent_attribute(key, value, default_destinations); end
  def add_agent_attribute_with_key_check(key, value, default_destinations); end
  def add_intrinsic_attribute(key, value); end
  def agent_attributes_for(destination); end

  # Returns the value of attribute custom_attributes.
  def custom_attributes; end

  def custom_attributes_for(destination); end
  def intrinsic_attributes_for(destination); end
  def merge_custom_attributes(other); end
  def merge_untrusted_agent_attributes(attributes, prefix, default_destinations); end

  private

  def add(attributes, key, value); end
  def add_custom_attribute(key, value); end

  # @return [Boolean]
  def exceeds_bytesize_limit?(value, limit); end

  def for_destination(attributes, calculated_destinations, destination); end

  # Take one byte past our limit. Why? This lets us unconditionally chop!
  # the end. It'll either remove the one-character-too-many we have, or
  # peel off the partial, mangled character left by the byteslice.
  def slice(incoming); end
end

NewRelic::Agent::Attributes::COUNT_LIMIT = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::Attributes::KEY_LIMIT = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::Attributes::VALUE_LIMIT = T.let(T.unsafe(nil), Integer)

class NewRelic::Agent::AuditLogger
  # @return [AuditLogger] a new instance of AuditLogger
  def initialize; end

  # @return [Boolean]
  def allowed_endpoint?(uri); end

  def create_log_formatter; end

  # Sets the attribute enabled
  #
  # @param value the value to set the attribute enabled to.
  def enabled=(_arg0); end

  # @return [Boolean]
  def enabled?; end

  def ensure_log_path; end
  def log_request(uri, data, marshaller); end
  def log_request_headers(uri, headers); end

  # @return [Boolean]
  def setup?; end

  def setup_logger; end

  # @return [Boolean]
  def wants_stdout?; end
end

# A singleton responsible for determining if the agent should start
# monitoring.
#
# If the agent is in a monitored environment (e.g. production) it will
# attempt to avoid starting at "inappropriate" times, for example in an IRB
# session.  On Heroku, logs typically go to STDOUT so agent logs can spam
# the console during interactive sessions.
#
# It should be possible to override Autostart logic with an explicit
# configuration, for example the NEW_RELIC_AGENT_ENABLED environment variable or
# agent_enabled key in newrelic.yml
module NewRelic::Agent::Autostart
  extend ::NewRelic::Agent::Autostart

  # The constants, executables (i.e. $0) and rake tasks used can be
  # configured with the config keys 'autostart.denylisted_constants',
  # 'autostart.denylisted_executables' and
  # 'autostart.denylisted_rake_tasks'
  #
  # @return [Boolean]
  def agent_should_start?; end

  # Lookup whether namespaced constants (e.g. ::Foo::Bar::Baz) are in the
  # environment.
  #
  # @return [Boolean]
  def constant_is_defined?(const_name); end

  # @return [Boolean]
  def denylisted?(value, &block); end

  # @return [Boolean]
  def denylisted_constants?; end

  # @return [Boolean]
  def denylisted_executables?; end

  # @return [Boolean]
  def in_denylisted_rake_task?; end
end

NewRelic::Agent::Autostart::COMMA = T.let(T.unsafe(nil), String)

# @api public
class NewRelic::Agent::BackgroundLoadingError < ::StandardError; end

module NewRelic::Agent::Commands; end

class NewRelic::Agent::Commands::AgentCommand
  # @return [AgentCommand] a new instance of AgentCommand
  def initialize(raw_collector_command); end

  # Returns the value of attribute arguments.
  def arguments; end

  # Returns the value of attribute id.
  def id; end

  # Returns the value of attribute name.
  def name; end
end

class NewRelic::Agent::Commands::AgentCommandRouter
  # @return [AgentCommandRouter] a new instance of AgentCommandRouter
  def initialize(event_listener = T.unsafe(nil)); end

  # Returns the value of attribute backtrace_service.
  def backtrace_service; end

  # Sets the attribute backtrace_service
  #
  # @param value the value to set the attribute backtrace_service to.
  def backtrace_service=(_arg0); end

  def call_handler_for(agent_command); end
  def check_for_and_handle_agent_commands; end
  def error(err); end
  def get_agent_commands; end

  # Returns the value of attribute handlers.
  def handlers; end

  def harvest!; end
  def harvest_from_thread_profiler_session; end
  def invoke_command(agent_command); end
  def invoke_commands(agent_commands); end
  def log_profiles(profiles); end

  # We don't currently support merging thread profiles that failed to send
  # back into the AgentCommandRouter, so we just no-op this method.
  # Same with reset! - we don't support asynchronous cancellation of a
  # running thread profile currently.
  def merge!(*args); end

  def new_relic_service; end
  def on_before_shutdown(*args); end
  def reset!; end
  def select_handler(agent_command); end
  def success; end

  # Returns the value of attribute thread_profiler_session.
  def thread_profiler_session; end

  # Sets the attribute thread_profiler_session
  #
  # @param value the value to set the attribute thread_profiler_session to.
  def thread_profiler_session=(_arg0); end

  def unrecognized_agent_command(agent_command); end
end

class NewRelic::Agent::Commands::AgentCommandRouter::AgentCommandError < ::StandardError; end
NewRelic::Agent::Commands::AgentCommandRouter::ERROR_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::Commands::AgentCommandRouter::SUCCESS_RESULT = T.let(T.unsafe(nil), Hash)

class NewRelic::Agent::Commands::ThreadProfilerSession
  # @return [ThreadProfilerSession] a new instance of ThreadProfilerSession
  def initialize(backtrace_service); end

  # @return [Boolean]
  def enabled?; end

  def handle_start_command(agent_command); end
  def handle_stop_command(agent_command); end
  def harvest; end

  # @return [Boolean]
  def past_time?; end

  # @return [Boolean]
  def ready_to_harvest?; end

  # @return [Boolean]
  def running?; end

  def start(agent_command); end
  def stop(report_data); end

  # @return [Boolean]
  def stopped?; end

  private

  def raise_already_started_error; end

  # @raise [NewRelic::Agent::Commands::AgentCommandRouter::AgentCommandError]
  def raise_command_error(msg); end

  def raise_thread_profiler_disabled; end
  def raise_unsupported_error; end
end

module NewRelic::Agent::Configuration
  class << self
    # Marks the config option as deprecated in the documentation once generated.
    # Does not appear in logs.
    def deprecated_description(new_setting, description); end

    def instrumentation_value_from_boolean(key); end

    # Combines potentially two properties into one.
    # Given the example:
    #    :disable_net_http and :prepend_net_instrumentation
    #    if :disable_net_http is true, then returned value is "disabled"
    #    if :prepend_net_instrumentation is false, then returned value is "chain"
    #    otherwise, "auto" is returned.
    #
    # Intent is:
    #     - if user sets disable_xxx property, then don't instrument
    #     - if user set prepend to `false` then we use method_alias chaining
    #     - auto, when returned means, try to use prepend unless conflicting gems discovered
    def instrumentation_value_of(disable_key, prepend_key = T.unsafe(nil)); end

    # Helper since default Procs are evaluated in the context of this module
    def value_of(key); end
  end
end

NewRelic::Agent::Configuration::AUTOSTART_DENYLISTED_RAKE_TASKS = T.let(T.unsafe(nil), String)

class NewRelic::Agent::Configuration::Boolean
  class << self
    def ===(o); end
  end
end

NewRelic::Agent::Configuration::DEFAULTS = T.let(T.unsafe(nil), Hash)

class NewRelic::Agent::Configuration::DefaultSource
  extend ::Forwardable

  # @return [DefaultSource] a new instance of DefaultSource
  def initialize; end

  def [](*args, **_arg1, &block); end
  def default_values; end

  # Returns the value of attribute defaults.
  def defaults; end

  def delete(*args, **_arg1, &block); end
  def each(*args, **_arg1, &block); end
  def has_key?(*args, **_arg1, &block); end
  def keys(*args, **_arg1, &block); end
  def merge(*args, **_arg1, &block); end
  def to_hash(*args, **_arg1, &block); end

  class << self
    def agent_enabled; end
    def api_host; end
    def app_name; end
    def audit_log_path; end

    # This check supports the js_errors_beta key we've asked clients to
    # set. Once JS errors are GA, browser_monitoring.loader can stop
    # being dynamic.
    def browser_monitoring_loader; end

    def config_path; end
    def config_search_paths; end
    def convert_to_constant_list(raw_value); end
    def convert_to_list(value); end
    def convert_to_list_on_semicolon(value); end
    def convert_to_regexp_list(raw_value); end
    def dispatcher; end
    def enforce_fallback(allowed_values: T.unsafe(nil), fallback: T.unsafe(nil)); end
    def framework; end
    def host; end
    def profiling_available; end
    def thread_profiler_enabled; end
    def transaction_tracer_transaction_threshold; end
    def transform_for(key); end
  end
end

NewRelic::Agent::Configuration::DefaultSource::DEFAULT_LOG_DIR = T.let(T.unsafe(nil), String)
NewRelic::Agent::Configuration::DefaultSource::SEMICOLON = T.let(T.unsafe(nil), String)

class NewRelic::Agent::Configuration::DottedHash < ::Hash
  # @return [DottedHash] a new instance of DottedHash
  def initialize(hash, keep_nesting = T.unsafe(nil)); end

  def inspect; end
  def to_hash; end

  protected

  # turns {'a' => {'b' => 'c'}} into {'a.b' => 'c'}
  def dot_flattened(nested_hash, names = T.unsafe(nil), result = T.unsafe(nil)); end

  class << self
    def symbolize(hash); end
  end
end

class NewRelic::Agent::Configuration::EnvironmentSource < ::NewRelic::Agent::Configuration::DottedHash
  # @return [EnvironmentSource] a new instance of EnvironmentSource
  def initialize; end

  # Returns the value of attribute alias_map.
  def alias_map; end

  # Sets the attribute alias_map
  #
  # @param value the value to set the attribute alias_map to.
  def alias_map=(_arg0); end

  def collect_new_relic_environment_variable_keys; end
  def convert_environment_key_to_config_key(key); end
  def set_aliases(config_setting, value); end
  def set_config_file; end
  def set_dotted_alias(original_config_setting); end
  def set_key_by_type(config_key, environment_key); end
  def set_log_file; end
  def set_value_from_environment_variable(key); end
  def set_values_from_new_relic_environment_variables; end

  # Returns the value of attribute type_map.
  def type_map; end

  # Sets the attribute type_map
  #
  # @param value the value to set the attribute type_map to.
  def type_map=(_arg0); end
end

NewRelic::Agent::Configuration::EnvironmentSource::SPECIAL_CASE_KEYS = T.let(T.unsafe(nil), Array)
NewRelic::Agent::Configuration::EnvironmentSource::SUPPORTED_PREFIXES = T.let(T.unsafe(nil), Regexp)

module NewRelic::Agent::Configuration::EventHarvestConfig
  extend ::NewRelic::Agent::Configuration::EventHarvestConfig

  def from_config(config); end
  def to_config_hash(connect_reply); end

  private

  def transform_event_harvest_config_keys(connect_reply, event_harvest_interval); end
  def transform_span_event_harvest_config(config_hash, connect_reply); end
end

NewRelic::Agent::Configuration::EventHarvestConfig::EVENT_HARVEST_CONFIG_KEY_MAPPING = T.let(T.unsafe(nil), Hash)

# not including span_event_data here because spans are handled separately in transform_span_event_harvest_config
NewRelic::Agent::Configuration::EventHarvestConfig::EVENT_HARVEST_EVENT_REPORT_PERIOD_KEY_MAPPING = T.let(T.unsafe(nil), Hash)

class NewRelic::Agent::Configuration::HighSecuritySource < ::NewRelic::Agent::Configuration::DottedHash
  # @return [HighSecuritySource] a new instance of HighSecuritySource
  def initialize(local_settings); end

  def record_sql_setting(local_settings, key); end
end

NewRelic::Agent::Configuration::HighSecuritySource::OBFUSCATED = T.let(T.unsafe(nil), String)
NewRelic::Agent::Configuration::HighSecuritySource::OFF = T.let(T.unsafe(nil), String)
NewRelic::Agent::Configuration::HighSecuritySource::RAW = T.let(T.unsafe(nil), String)
NewRelic::Agent::Configuration::HighSecuritySource::SET_TO_OBFUSCATED = T.let(T.unsafe(nil), Array)
NewRelic::Agent::Configuration::MASK_DEFAULTS = T.let(T.unsafe(nil), Hash)

class NewRelic::Agent::Configuration::Manager
  # @return [Manager] a new instance of Manager
  def initialize; end

  # Defining these explicitly saves object allocations that we incur
  # if we use Forwardable and def_delegators.
  def [](key); end

  def add_config_for_testing(source, level = T.unsafe(nil)); end
  def apply_mask(hash); end
  def apply_transformations(key, value); end
  def break_label_string_into_pairs(labels); end
  def config_classes_for_testing; end
  def delete_all_configs_for_testing; end
  def evaluate_and_apply_transformations(key, value); end
  def evaluate_procs(value); end
  def fetch(key); end

  # @return [Boolean]
  def finished_configuring?; end

  def flattened; end

  # @return [Boolean]
  def has_key?(key); end

  def invoke_callbacks(direction, source); end
  def keys; end
  def limit_number_of_labels(pairs); end
  def log_config(direction, source); end
  def make_label_hash(pairs, labels = T.unsafe(nil)); end

  # This event is intended to be fired once during the entire lifespan of
  # an agent run, after the server source has been applied for the first
  # time.  This should indicate that all configuration has been applied,
  # and the main functions of the agent are safe to start.
  def notify_finished_configuring; end

  # This event is intended to be fired every time the server source is
  # applied.  This happens after the agent's initial connect, and again
  # on every forced reconnect.
  def notify_server_source_added; end

  def num_configs_for_testing; end
  def parse_labels_from_dictionary; end
  def parse_labels_from_string; end
  def parsed_labels; end
  def register_callback(key, &proc); end
  def remove_config(source); end
  def remove_config_type(sym); end

  # We only take the last value provided for a given label type key
  def remove_duplicates(pairs); end

  def replace_or_add_config(source); end
  def reset_cache; end

  # Generally only useful during initial construction and tests
  def reset_to_defaults; end

  def source(key); end
  def to_collector_hash; end
  def transform_from_default(key); end
  def truncate(text, key = T.unsafe(nil)); end

  # @return [Boolean]
  def valid_label_item?(item); end

  # @return [Boolean]
  def valid_label_pairs?(label_pairs); end

  private

  def config_stack; end
end

NewRelic::Agent::Configuration::Manager::MALFORMED_LABELS_WARNING = T.let(T.unsafe(nil), String)
NewRelic::Agent::Configuration::Manager::MAX_LABEL_COUNT = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::Configuration::Manager::MAX_LABEL_LENGTH = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::Configuration::Manager::PARSING_LABELS_FAILURE = T.let(T.unsafe(nil), String)

class NewRelic::Agent::Configuration::ManualSource < ::NewRelic::Agent::Configuration::DottedHash
  # @return [ManualSource] a new instance of ManualSource
  def initialize(hash); end
end

class NewRelic::Agent::Configuration::SecurityPolicySource < ::NewRelic::Agent::Configuration::DottedHash
  # @return [SecurityPolicySource] a new instance of SecurityPolicySource
  def initialize(security_policies); end

  def build_overrides(security_policies); end

  class << self
    def change_setting(policies, option, new_value); end

    # @return [Boolean]
    def enabled?(option); end

    # @return [Boolean]
    def not_empty?(option); end

    # @return [Boolean]
    def record_sql_enabled?(option); end
  end
end

NewRelic::Agent::Configuration::SecurityPolicySource::COLON_COLON = T.let(T.unsafe(nil), String)
NewRelic::Agent::Configuration::SecurityPolicySource::ENABLED = T.let(T.unsafe(nil), String)

# The keys of the security settings map are the names of security
# policies received from the server. They map to multiple configuration
# options in the local config. There is a hash of metadata that
# corresponds to each configuration option with the following keys:
#
# option: the configuration option name
# supported: true if the agent has one or more corresponding
#   configuration options
# enabled_fn: a callable that takes the configuration option and returns
#   true if the option is enabled, false otherwise
# disabled_value: the value of the configuration option when it is
#   disabled
# permitted_fn: a callable, that will be executed if an option is
#   permitted by the security policy and is also enabled by the config
NewRelic::Agent::Configuration::SecurityPolicySource::SECURITY_SETTINGS_MAP = T.let(T.unsafe(nil), Hash)

class NewRelic::Agent::Configuration::ServerSource < ::NewRelic::Agent::Configuration::DottedHash
  # @return [ServerSource] a new instance of ServerSource
  def initialize(connect_reply, existing_config = T.unsafe(nil)); end

  def add_event_harvest_config(merged_settings, connect_reply); end

  # These feature gates are not intended to be bullet-proof, but only to
  # avoid the overhead of collecting and transmitting additional data if
  # the user's subscription level precludes its use. The server is the
  # ultimate authority regarding subscription levels, so we expect it to
  # do the real enforcement there.
  def apply_feature_gates(merged_settings, connect_reply, existing_config); end

  def event_harvest_config_is_valid(connect_reply); end
  def filter_keys(merged_settings); end
  def fix_transaction_threshold(merged_settings); end
  def merge_agent_config_hash(merged_settings, connect_reply); end
  def merge_top_level_keys(merged_settings, connect_reply); end
  def ungated_value(key, merged_settings, existing_config); end
end

NewRelic::Agent::Configuration::ServerSource::EVENT_HARVEST_CONFIG_SUPPORTABILITY_METRIC_NAMES = T.let(T.unsafe(nil), Hash)

# These keys appear *outside* of the agent_config hash in the connect
# response, but should still be merged in as config settings to the
# main agent configuration.
NewRelic::Agent::Configuration::ServerSource::TOP_LEVEL_KEYS = T.let(T.unsafe(nil), Array)

class NewRelic::Agent::Configuration::YamlSource < ::NewRelic::Agent::Configuration::DottedHash
  # @return [YamlSource] a new instance of YamlSource
  def initialize(path, env); end

  # @return [Boolean]
  def failed?; end

  # Returns the value of attribute failures.
  def failures; end

  # Sets the attribute failures
  #
  # @param value the value to set the attribute failures to.
  def failures=(_arg0); end

  # Returns the value of attribute file_path.
  def file_path; end

  # Sets the attribute file_path
  #
  # @param value the value to set the attribute file_path to.
  def file_path=(_arg0); end

  # Returns the value of attribute generated_for_user.
  def generated_for_user; end

  def license_key; end

  protected

  def booleanify_values(config, *keys); end
  def dot_flattened(nested_hash, names = T.unsafe(nil), result = T.unsafe(nil)); end

  # @return [Boolean]
  def is_boolean?(value); end

  def log_failure(*messages); end
  def process_erb(file); end
  def process_yaml(file, env, config, path); end
  def substitute_transaction_threshold(config); end
  def validate_config_file_path(path); end
  def warn_missing_config_file(path); end
end

# These are configuration options that have a value of a Hash
# This is used in YamlSource#dot_flattened prevent flattening these values
NewRelic::Agent::Configuration::YamlSource::CONFIG_WITH_HASH_VALUE = T.let(T.unsafe(nil), Array)

module NewRelic::Agent::Connect; end

class NewRelic::Agent::Connect::RequestBuilder
  # @return [RequestBuilder] a new instance of RequestBuilder
  def initialize(new_relic_service, config, event_harvest_config, environment_report); end

  # Initializes the hash of settings that we send to the
  # server. Returns a literal hash containing the options
  def connect_payload; end

  def environment_metadata; end
  def local_host; end

  # We've seen objects in the environment report (Rails.env in
  # particular) that can't seralize to JSON. Cope with that here and
  # clear out so downstream code doesn't have to check again.
  def sanitize_environment_report(environment_report); end
end

class NewRelic::Agent::Connect::ResponseHandler
  # @return [ResponseHandler] a new instance of ResponseHandler
  def initialize(agent, config); end

  def add_security_policy_config(security_policies); end
  def add_server_side_config(config_data); end

  # Takes a hash of configuration data returned from the
  # server and uses it to set local variables and to
  # initialize various parts of the agent that are configured
  # separately.
  #
  # Can accommodate most arbitrary data - anything extra is
  # ignored unless we say to do something with it here.
  def configure_agent(config_data); end
end

class NewRelic::Agent::CrossAppPayload
  # @return [CrossAppPayload] a new instance of CrossAppPayload
  def initialize(id, transaction, transaction_info); end

  def as_json_array(content_length); end

  # Returns the value of attribute id.
  def id; end

  # Returns the value of attribute referring_guid.
  def referring_guid; end

  # Returns the value of attribute referring_path_hash.
  def referring_path_hash; end

  # Returns the value of attribute referring_trip_id.
  def referring_trip_id; end

  # Returns the value of attribute transaction.
  def transaction; end

  private

  def string_or_false_for(value); end
end

module NewRelic::Agent::CrossAppTracing
  def add_message_cat_headers(headers); end
  def assign_cross_app_intrinsics; end
  def cat_path_hash; end

  # Returns the value of attribute cat_path_hashes.
  def cat_path_hashes; end

  # Sets the attribute cat_path_hashes
  #
  # @param value the value to set the attribute cat_path_hashes to.
  def cat_path_hashes=(_arg0); end

  def cat_trip_id; end
  def cross_app_monitor; end

  # Returns the value of attribute cross_app_payload.
  def cross_app_payload; end

  # Sets the attribute cross_app_payload
  #
  # @param value the value to set the attribute cross_app_payload to.
  def cross_app_payload=(_arg0); end

  def insert_cross_app_header(headers); end

  # @return [Boolean]
  def is_cross_app?; end

  # @return [Boolean]
  def is_cross_app_callee?; end

  # Returns the value of attribute is_cross_app_caller.
  def is_cross_app_caller; end

  # Sets the attribute is_cross_app_caller
  #
  # @param value the value to set the attribute is_cross_app_caller to.
  def is_cross_app_caller=(_arg0); end

  # @return [Boolean]
  def is_cross_app_caller?; end

  def record_cross_app_metrics; end

  private

  def append_cat_info(payload); end

  # From inbound request headers
  def assign_intrinsic_transaction_attributes(state); end

  def cat_referring_path_hash; end
  def cross_app_enabled?; end
  def cross_application_tracer_enabled?; end

  # Extract x-process application data from the specified +response+ and return
  # it as an array of the form:
  #
  #  [
  #    <cross app ID>,
  #    <transaction name>,
  #    <queue time in seconds>,
  #    <response time in seconds>,
  #    <request content length in bytes>,
  #    <transaction GUID>
  #  ]
  def extract_appdata(response); end

  def insert_message_headers(headers, txn_guid, trip_id, path_hash, synthetics_header); end
  def insert_request_headers(request, txn_guid, trip_id, path_hash); end
  def message_has_crossapp_request_header?(headers); end
  def obfuscator; end
  def record_cat_path_hash(hash); end
  def reject_messaging_cat_headers(headers); end
  def response_has_crossapp_header?(response); end
  def trusted_valid_cross_app_id?(id); end
  def trusts?(id); end
  def valid_cross_app_id?(xp_id); end
  def valid_cross_process_id?; end
  def valid_encoding_key?; end

  class << self
    # From inbound request headers
    def assign_intrinsic_transaction_attributes(state); end

    # @return [Boolean]
    def cross_app_enabled?; end

    # @return [Boolean]
    def cross_application_tracer_enabled?; end

    # Extract x-process application data from the specified +response+ and return
    # it as an array of the form:
    #
    #  [
    #    <cross app ID>,
    #    <transaction name>,
    #    <queue time in seconds>,
    #    <response time in seconds>,
    #    <request content length in bytes>,
    #    <transaction GUID>
    #  ]
    def extract_appdata(response); end

    def insert_request_headers(request, txn_guid, trip_id, path_hash); end

    # @return [Boolean]
    def message_has_crossapp_request_header?(headers); end

    def obfuscator; end
    def reject_messaging_cat_headers(headers); end

    # @return [Boolean]
    def response_has_crossapp_header?(response); end

    # @return [Boolean]
    def trusted_valid_cross_app_id?(id); end

    # @return [Boolean]
    def trusts?(id); end

    # @return [Boolean]
    def valid_cross_app_id?(xp_id); end

    # @return [Boolean]
    def valid_cross_process_id?; end

    # @return [Boolean]
    def valid_encoding_key?; end
  end
end

# The cross app response header for "outgoing" calls
NewRelic::Agent::CrossAppTracing::NR_APPDATA_HEADER = T.let(T.unsafe(nil), String)

# The cross app id header for "outgoing" calls
NewRelic::Agent::CrossAppTracing::NR_ID_HEADER = T.let(T.unsafe(nil), String)

NewRelic::Agent::CrossAppTracing::NR_MESSAGE_BROKER_ID_HEADER = T.let(T.unsafe(nil), String)
NewRelic::Agent::CrossAppTracing::NR_MESSAGE_BROKER_SYNTHETICS_HEADER = T.let(T.unsafe(nil), String)
NewRelic::Agent::CrossAppTracing::NR_MESSAGE_BROKER_TXN_HEADER = T.let(T.unsafe(nil), String)

# The cross app transaction header for "outgoing" calls
NewRelic::Agent::CrossAppTracing::NR_TXN_HEADER = T.let(T.unsafe(nil), String)

class NewRelic::Agent::CustomEventAggregator < ::NewRelic::Agent::EventAggregator
  include ::NewRelic::Coerce

  def record(type, attributes); end

  private

  def after_harvest(metadata); end
  def after_initialize; end
  def create_event(type, priority, attributes); end
  def note_dropped_event(type); end
  def note_dropped_events(total_count, dropped_count); end
  def record_supportability_metrics(total_count, captured_count, dropped_count); end
end

NewRelic::Agent::CustomEventAggregator::EVENT_TYPE_REGEX = T.let(T.unsafe(nil), Regexp)
NewRelic::Agent::CustomEventAggregator::PRIORITY = T.let(T.unsafe(nil), String)
NewRelic::Agent::CustomEventAggregator::TIMESTAMP = T.let(T.unsafe(nil), String)
NewRelic::Agent::CustomEventAggregator::TYPE = T.let(T.unsafe(nil), String)

module NewRelic::Agent::Database
  extend ::NewRelic::Agent::Database

  # Properly encode, truncate, and dup the incoming query.
  # Take care not to the dup the query more than once as
  # correctly encoded may also dup the query.
  def capture_query(query); end

  def close_connections; end

  # Perform this in the runtime environment of a managed
  # application, to explain the sql statement executed within a
  # node of a transaction sample. Returns an array of two arrays.
  # The first array contains the headers, while the second consists of
  # arrays of strings for each column returned by the explain query.
  # Note this happens only for statements whose execution time exceeds
  # a threshold (e.g. 500ms) and only within the slowest transaction
  # in a report period, selected for shipment to New Relic
  def explain_sql(statement); end

  def get_connection(config, &connector); end
  def obfuscate_sql(sql); end
  def parse_operation_from_query(sql); end
  def record_sql_method(config_section = T.unsafe(nil)); end
  def record_sql_method_key(config_section); end
  def set_sql_obfuscator(type, &block); end

  # @return [Boolean]
  def should_collect_explain_plans?(config_section = T.unsafe(nil)); end

  # @return [Boolean]
  def should_record_sql?(config_section = T.unsafe(nil)); end

  def truncate_query(query); end
end

class NewRelic::Agent::Database::ConnectionManager
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # Closes all the connections in the internal connection cache
  def close_connections; end

  # Returns a cached connection for a given ActiveRecord
  # configuration - these are stored or reopened as needed, and if
  # we cannot get one, we ignore it and move on without explaining
  # the sql
  def get_connection(config, &connector); end
end

NewRelic::Agent::Database::ELLIPSIS = T.let(T.unsafe(nil), String)

module NewRelic::Agent::Database::ExplainPlanHelpers
  def handle_exception_in_explain; end

  # @return [Boolean]
  def is_select?(sql); end

  # @return [Boolean]
  def multiple_queries?(sql); end

  # @return [Boolean]
  def parameterized?(sql); end

  def process_explain_results_mysql(results); end
  def process_explain_results_mysql2(results); end
  def process_explain_results_postgres(results); end
  def process_explain_results_sqlite(results); end
  def process_resultset(results, adapter); end

  # Sequel returns explain plans as just one big pre-formatted String
  # In that case, we send a nil headers array, and the single string
  # wrapped in an array for the values.
  # Note that we don't use this method for Postgres explain plans, since
  # they need to be passed through the explain plan obfuscator first.
  def string_explain_plan_results(results); end
end

# SQL containing a semicolon in the middle (with something
# other than whitespace after it) may contain two or more
# queries.  It's not safe to EXPLAIN this kind of expression,
# since it could lead to executing unwanted SQL.
NewRelic::Agent::Database::ExplainPlanHelpers::MULTIPLE_QUERIES = T.let(T.unsafe(nil), Regexp)

NewRelic::Agent::Database::ExplainPlanHelpers::QUERY_PLAN = T.let(T.unsafe(nil), String)
NewRelic::Agent::Database::ExplainPlanHelpers::SELECT = T.let(T.unsafe(nil), String)
NewRelic::Agent::Database::ExplainPlanHelpers::SQLITE_EXPLAIN_COLUMNS = T.let(T.unsafe(nil), Array)
NewRelic::Agent::Database::ExplainPlanHelpers::SUPPORTED_ADAPTERS_FOR_EXPLAIN = T.let(T.unsafe(nil), Array)
NewRelic::Agent::Database::KNOWN_OPERATIONS = T.let(T.unsafe(nil), Array)
NewRelic::Agent::Database::MAX_QUERY_LENGTH = T.let(T.unsafe(nil), Integer)

module NewRelic::Agent::Database::ObfuscationHelpers
  def detect_unmatched_pairs(obfuscated, adapter); end
  def obfuscate(sql, adapter); end
  def obfuscate_single_quote_literals(sql); end

  class << self
    def generate_regex(dialect); end
  end
end

NewRelic::Agent::Database::ObfuscationHelpers::CASSANDRA_COMPONENTS_REGEX = T.let(T.unsafe(nil), Regexp)

# We use these to check whether the query contains any quote characters
# after obfuscation. If so, that's a good indication that the original
# query was malformed, and so our obfuscation can't reliably find
# literals. In such a case, we'll replace the entire query with a
# placeholder.
NewRelic::Agent::Database::ObfuscationHelpers::CLEANUP_REGEX = T.let(T.unsafe(nil), Hash)

NewRelic::Agent::Database::ObfuscationHelpers::COMPONENTS_REGEX_MAP = T.let(T.unsafe(nil), Hash)
NewRelic::Agent::Database::ObfuscationHelpers::DIALECT_COMPONENTS = T.let(T.unsafe(nil), Hash)
NewRelic::Agent::Database::ObfuscationHelpers::FAILED_TO_OBFUSCATE_MESSAGE = T.let(T.unsafe(nil), String)
NewRelic::Agent::Database::ObfuscationHelpers::FALLBACK_REGEX = T.let(T.unsafe(nil), Regexp)
NewRelic::Agent::Database::ObfuscationHelpers::MYSQL_COMPONENTS_REGEX = T.let(T.unsafe(nil), Regexp)
NewRelic::Agent::Database::ObfuscationHelpers::ORACLE_COMPONENTS_REGEX = T.let(T.unsafe(nil), Regexp)
NewRelic::Agent::Database::ObfuscationHelpers::PLACEHOLDER = T.let(T.unsafe(nil), String)
NewRelic::Agent::Database::ObfuscationHelpers::POSTGRES_COMPONENTS_REGEX = T.let(T.unsafe(nil), Regexp)
NewRelic::Agent::Database::ObfuscationHelpers::SQLITE_COMPONENTS_REGEX = T.let(T.unsafe(nil), Regexp)

class NewRelic::Agent::Database::Obfuscator
  include ::Singleton
  include ::NewRelic::Agent::Database::ObfuscationHelpers
  extend ::Singleton::SingletonClassMethods

  # @return [Obfuscator] a new instance of Obfuscator
  def initialize; end

  def default_sql_obfuscator(sql); end

  # Returns the value of attribute obfuscator.
  def obfuscator; end

  def reset; end

  # Sets the sql obfuscator used to clean up sql when sending it
  # to the server. Possible types are:
  #
  # :before => sets the block to run before the existing
  # obfuscators
  #
  # :after => sets the block to run after the existing
  # obfuscator(s)
  #
  # :replace => removes the current obfuscator and replaces it
  # with the provided block
  def set_sql_obfuscator(type, &block); end
end

NewRelic::Agent::Database::Obfuscator::ELLIPSIS = T.let(T.unsafe(nil), String)
NewRelic::Agent::Database::Obfuscator::QUERY_TOO_LARGE_MESSAGE = T.let(T.unsafe(nil), String)

module NewRelic::Agent::Database::PostgresExplainObfuscator
  extend ::NewRelic::Agent::Database::PostgresExplainObfuscator

  def obfuscate(explain); end
end

NewRelic::Agent::Database::PostgresExplainObfuscator::LABEL_LINE_REGEX = T.let(T.unsafe(nil), Regexp)

# Note that this regex can't be shared with the ones in the
# Database::Obfuscator class because here we don't look for
# backslash-escaped strings.
NewRelic::Agent::Database::PostgresExplainObfuscator::QUOTED_STRINGS_REGEX = T.let(T.unsafe(nil), Regexp)

NewRelic::Agent::Database::RECORD_FOR = T.let(T.unsafe(nil), Array)
NewRelic::Agent::Database::SQL_COMMENT_REGEX = T.let(T.unsafe(nil), Regexp)

class NewRelic::Agent::Database::Statement
  include ::NewRelic::Agent::Database::ExplainPlanHelpers

  # @return [Statement] a new instance of Statement
  def initialize(sql, config = T.unsafe(nil), explainer = T.unsafe(nil), binds = T.unsafe(nil), name = T.unsafe(nil), host = T.unsafe(nil), port_path_or_id = T.unsafe(nil), database_name = T.unsafe(nil)); end

  # This takes a connection config hash from ActiveRecord or Sequel and
  # returns a symbol describing the associated database adapter
  def adapter; end

  def append_sql(new_sql); end

  # Returns the value of attribute binds.
  def binds; end

  # Sets the attribute binds
  #
  # @param value the value to set the attribute binds to.
  def binds=(_arg0); end

  # Returns the value of attribute config.
  def config; end

  # Sets the attribute config
  #
  # @param value the value to set the attribute config to.
  def config=(_arg0); end

  # Returns the value of attribute database_name.
  def database_name; end

  # Sets the attribute database_name
  #
  # @param value the value to set the attribute database_name to.
  def database_name=(_arg0); end

  def explain; end

  # Returns the value of attribute explainer.
  def explainer; end

  # Sets the attribute explainer
  #
  # @param value the value to set the attribute explainer to.
  def explainer=(_arg0); end

  # Returns the value of attribute host.
  def host; end

  # Sets the attribute host
  #
  # @param value the value to set the attribute host to.
  def host=(_arg0); end

  # Returns the value of attribute name.
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  def name=(_arg0); end

  # Returns the value of attribute port_path_or_id.
  def port_path_or_id; end

  # Sets the attribute port_path_or_id
  #
  # @param value the value to set the attribute port_path_or_id to.
  def port_path_or_id=(_arg0); end

  # Returns an sql statement that will be in the form most permissable by
  # the config. The format will be safe for transmission to New Relic.
  def safe_sql; end

  # Returns the value of attribute sql.
  def sql; end

  # Sets the attribute sql
  #
  # @param value the value to set the attribute sql to.
  def sql=(_arg0); end

  private

  # @return [Boolean]
  def explainable?; end

  def symbolized_adapter(adapter); end
end

NewRelic::Agent::Database::Statement::DEFAULT_QUERY_NAME = T.let(T.unsafe(nil), String)
NewRelic::Agent::Database::Statement::MYSQL2_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::Database::Statement::MYSQL_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::Database::Statement::NEWLINE = T.let(T.unsafe(nil), String)
NewRelic::Agent::Database::Statement::POSTGIS_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::Database::Statement::POSTGRES_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::Database::Statement::SQLITE_PREFIX = T.let(T.unsafe(nil), String)

class NewRelic::Agent::DatabaseAdapter
  # @return [DatabaseAdapter] a new instance of DatabaseAdapter
  def initialize(env, version); end

  # Returns the value of attribute env.
  def env; end

  def value; end

  # Returns the value of attribute version.
  def version; end

  class << self
    def value; end
  end
end

NewRelic::Agent::DatabaseAdapter::VERSIONS = T.let(T.unsafe(nil), Hash)

# This module contains helper methods to facilitate instrumentation of
# datastores not directly supported by the Ruby agent. It is intended to be
# primarily used by authors of 3rd-party datastore instrumentation.
#
# @api public
module NewRelic::Agent::Datastores
  class << self
    # Wrapper for simplifying attaching SQL queries during a transaction.
    #
    # If you are recording non-SQL data, please use {notice_statement}
    # instead.
    #
    #   NewRelic::Agent::Datastores.notice_sql(query, metrics, elapsed)
    #
    # @api public
    # @note THERE ARE SECURITY CONCERNS WHEN CAPTURING QUERY TEXT!
    #   New Relic's Transaction Tracing and Slow SQL features will
    #   attempt to apply obfuscation to the passed queries, but it is possible
    #   for a query format to be unsupported and result in exposing user
    #   information embedded within captured queries.
    # @param query [String] the SQL text to be captured. Note that depending
    #   on user settings, this string will be run through obfuscation, but
    #   some dialects of SQL (or non-SQL queries) are not guaranteed to be
    #   properly obfuscated by these routines!
    # @param scoped_metric [String] The most specific metric relating to this
    #   query. Typically the result of
    #   NewRelic::Agent::Datastores::MetricHelper#metrics_for
    # @param elapsed [Float] the elapsed time during query execution
    def notice_sql(query, scoped_metric, elapsed); end

    # Wrapper for simplifying attaching non-SQL data statements to a
    # transaction. For instance, Mongo or CQL queries, Memcached or Redis
    # keys would all be appropriate data to attach as statements.
    #
    # Data passed to this method is NOT obfuscated by New Relic, so please
    # ensure that user information is obfuscated if the agent setting
    # `transaction_tracer.record_sql` is set to `obfuscated`
    #
    #   NewRelic::Agent::Datastores.notice_statement("key", elapsed)
    #
    # @api public
    # @note THERE ARE SECURITY CONCERNS WHEN CAPTURING STATEMENTS!
    #   This method will properly ignore statements when the user has turned
    #   off capturing queries, but it is not able to obfuscate arbitrary data!
    #   To prevent exposing user information embedded in captured queries,
    #   please ensure all data passed to this method is safe to transmit to
    #   New Relic.
    # @param statement [String] text of the statement to capture.
    # @param elapsed [Float] the elapsed time during query execution
    def notice_statement(statement, elapsed); end

    # Add Datastore tracing to a method. This properly generates the metrics
    # for New Relic's Datastore features. It does not capture the actual
    # query content into Transaction Traces. Use wrap if you want to provide
    # that functionality.
    #
    # @api public
    # @param klass [Class] the class to instrument
    # @param method_name [String, Symbol] the name of instance method to
    #   instrument
    # @param product [String] name of your datastore for use in metric naming, e.g. "Redis"
    # @param operation [optional, String] the name of operation if different
    #   than the instrumented method name
    def trace(klass, method_name, product, operation = T.unsafe(nil)); end

    # Wrap a call to a datastore and record New Relic Datastore metrics. This
    # method can be used when a collection (i.e. table or model name) is
    # known at runtime to be included in the metric naming. It is intended
    # for situations that the simpler NewRelic::Agent::Datastores.trace can't
    # properly handle.
    #
    # To use this, wrap the datastore operation in the block passed to wrap.
    #
    #   NewRelic::Agent::Datastores.wrap("FauxDB", "find", "items") do
    #     FauxDB.find(query)
    #   end
    #
    # @api public
    # @note THERE ARE SECURITY CONCERNS WHEN CAPTURING QUERY TEXT!
    #   New Relic's Transaction Tracing and Slow SQL features will
    #   attempt to apply obfuscation to the passed queries, but it is possible
    #   for a query format to be unsupported and result in exposing user
    #   information embedded within captured queries.
    # @param product [String] the datastore name for use in metric naming,
    #   e.g. "FauxDB"
    # @param operation [String, Symbol] the name of operation (e.g. "select"),
    #   often named after the method that's being instrumented.
    # @param collection [optional, String] the collection name for use in
    #   statement-level metrics (i.e. table or model name)
    # @param callback [Proc, #call] proc or other callable to invoke after
    #   running the datastore block. Receives three arguments: result of the
    #   yield, the most specific (scoped) metric name, and elapsed time of the
    #   call. An example use is attaching SQL to Transaction Traces at the end
    #   of a wrapped datastore call.
    #
    #   callback = Proc.new do |result, metrics, elapsed|
    #   NewRelic::Agent::Datastores.notice_sql(query, metrics, elapsed)
    #   end
    #
    #   NewRelic::Agent::Datastores.wrap("FauxDB", "find", "items", callback) do
    #   FauxDB.find(query)
    #   end
    def wrap(product, operation, collection = T.unsafe(nil), callback = T.unsafe(nil)); end
  end
end

module NewRelic::Agent::Datastores::MetricHelper
  class << self
    def all_suffix; end
    def instance_metric_for(product, host, port_path_or_id); end
    def metrics_for(product, operation, collection = T.unsafe(nil), generic_product = T.unsafe(nil), host = T.unsafe(nil), port_path_or_id = T.unsafe(nil)); end
    def metrics_from_sql(product, sql); end
    def operation_from_sql(sql); end
    def operation_metric_for(product, operation); end

    # Allow Transaction#with_database_metric_name to override our
    # collection and operation
    def overridden_operation_and_collection; end

    def product_operation_collection_for(product, operation, collection = T.unsafe(nil), generic_product = T.unsafe(nil)); end
    def product_rollup(product); end
    def product_suffixed_rollup(product, suffix); end
    def scoped_metric_for(product, operation, collection = T.unsafe(nil)); end

    # If the override declared a product affiliation, abide by that
    # ActiveRecord has database-specific product names, so we recognize
    # it by the generic_product it passes.
    #
    # @return [Boolean]
    def should_override?(overrides, product, generic_product); end

    def statement_metric_for(product, collection, operation); end
    def suffixed_rollup(suffix); end
    def unscoped_metrics_for(product, operation, collection = T.unsafe(nil), host = T.unsafe(nil), port_path_or_id = T.unsafe(nil)); end
  end
end

NewRelic::Agent::Datastores::MetricHelper::ALL = T.let(T.unsafe(nil), String)
NewRelic::Agent::Datastores::MetricHelper::ALL_OTHER = T.let(T.unsafe(nil), String)
NewRelic::Agent::Datastores::MetricHelper::ALL_WEB = T.let(T.unsafe(nil), String)
NewRelic::Agent::Datastores::MetricHelper::DEFAULT_PRODUCT_NAME = T.let(T.unsafe(nil), String)
NewRelic::Agent::Datastores::MetricHelper::OTHER = T.let(T.unsafe(nil), String)
NewRelic::Agent::Datastores::MetricHelper::OTHER_ROLLUP_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Datastores::MetricHelper::ROLLUP_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Datastores::MetricHelper::WEB_ROLLUP_METRIC = T.let(T.unsafe(nil), String)

module NewRelic::Agent::Deprecator
  class << self
    def deprecate(method_name, new_method_name = T.unsafe(nil), version = T.unsafe(nil)); end
  end
end

module NewRelic::Agent::DistributedTraceAttributes
  extend ::NewRelic::Agent::DistributedTraceAttributes

  # This method takes all distributed tracing intrinsics from the transaction
  # and the trace_payload, and populates them into the destination
  def copy_from_transaction(transaction, trace_payload, destination); end

  def copy_parent_attributes(transaction, trace_payload, destination); end

  # This method extracts intrinsics from the transaction_payload and
  # inserts them as intrinsics in the specified transaction_attributes
  def copy_to_attributes(transaction_payload, destination); end

  # This method extracts intrinsics from the transaction_payload and
  # inserts them into the specified destination.
  def copy_to_hash(transaction_payload, destination); end

  private

  # @return [Boolean]
  def enabled?; end
end

NewRelic::Agent::DistributedTraceAttributes::GUID_KEY = T.let(T.unsafe(nil), String)

# Intrinsic Keys
NewRelic::Agent::DistributedTraceAttributes::INTRINSIC_KEYS = T.let(T.unsafe(nil), Array)

NewRelic::Agent::DistributedTraceAttributes::PARENT_ACCOUNT_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTraceAttributes::PARENT_APP_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTraceAttributes::PARENT_SPAN_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTraceAttributes::PARENT_TRANSACTION_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTraceAttributes::PARENT_TRANSPORT_DURATION_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTraceAttributes::PARENT_TRANSPORT_TYPE_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTraceAttributes::PARENT_TYPE_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTraceAttributes::SAMPLED_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTraceAttributes::TRACE_ID_KEY = T.let(T.unsafe(nil), String)

module NewRelic::Agent::DistributedTraceMetrics
  extend ::NewRelic::Agent::DistributedTraceMetrics

  def prefix_for_metric(name, transaction, payload); end
  def record_caller_by_duration_metrics(transaction, payload); end
  def record_errors_by_caller_metrics(transaction, payload); end
  def record_metrics_for_transaction(transaction); end
  def record_transport_duration_metrics(transaction, payload); end
  def transaction_type_suffix; end

  private

  def record_unscoped_metric(transaction, prefix, duration); end
end

NewRelic::Agent::DistributedTraceMetrics::ALL_OTHER_SUFFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTraceMetrics::ALL_SUFFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTraceMetrics::ALL_WEB_SUFFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTraceMetrics::UNKNOWN_CALLER_PREFIX = T.let(T.unsafe(nil), String)

# This class contains properties related to distributed traces.
# To obtain an instance, call
# {DistributedTracing#create_distributed_trace_payload}
#
# @api public
class NewRelic::Agent::DistributedTracePayload
  extend ::NewRelic::Coerce

  # Encode this payload as a string suitable for passing via an
  # HTTP header.
  #
  # @api public
  # @return [String] Payload translated to JSON and encoded for
  #   inclusion in headers
  def http_safe; end

  # @api public
  def id; end

  # @api public
  def id=(_arg0); end

  # @api public
  def parent_account_id; end

  # @api public
  def parent_account_id=(_arg0); end

  # @api public
  def parent_app_id; end

  # @api public
  def parent_app_id=(_arg0); end

  # @api public
  def parent_type; end

  # @api public
  def parent_type=(_arg0); end

  # @api public
  def priority; end

  # @api public
  def priority=(_arg0); end

  # @api public
  def sampled; end

  # @api public
  def sampled=(_arg0); end

  # @api public
  def sampled?; end

  # Represent this payload as a raw JSON string.
  #
  # @api public
  # @return [String] Payload translated to JSON
  def text; end

  # @api public
  def timestamp; end

  # @api public
  def timestamp=(_arg0); end

  # @api public
  def trace_id; end

  # @api public
  def trace_id=(_arg0); end

  # @api public
  def transaction_id; end

  # @api public
  def transaction_id=(_arg0); end

  # @api public
  def trusted_account_key; end

  # @api public
  def trusted_account_key=(_arg0); end

  # @api public
  def version; end

  # @api public
  def version=(_arg0); end

  class << self
    # @api public
    def for_transaction(transaction); end

    # @api public
    def from_http_safe(http_safe_payload); end

    # @api public
    def from_json(serialized_payload); end

    # @api public
    # @return [Boolean]
    def major_version_matches?(payload); end

    private

    # @api public
    def assign_trusted_account_key(payload, account_id); end

    # @api public
    # @return [Boolean]
    def connected?; end

    # @api public
    def current_segment_id(transaction); end
  end
end

# @api public
NewRelic::Agent::DistributedTracePayload::DATA_KEY = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::DistributedTracePayload::ID_KEY = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::DistributedTracePayload::PARENT_ACCOUNT_ID_KEY = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::DistributedTracePayload::PARENT_APP_KEY = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::DistributedTracePayload::PARENT_TYPE = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::DistributedTracePayload::PARENT_TYPE_KEY = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::DistributedTracePayload::POUND = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::DistributedTracePayload::PRIORITY_KEY = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::DistributedTracePayload::SAMPLED_KEY = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::DistributedTracePayload::TIMESTAMP_KEY = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::DistributedTracePayload::TRACE_ID_KEY = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::DistributedTracePayload::TRUSTED_ACCOUNT_KEY = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::DistributedTracePayload::TX_KEY = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::DistributedTracePayload::VERSION = T.let(T.unsafe(nil), Array)

# Key names for serialization
#
# @api public
NewRelic::Agent::DistributedTracePayload::VERSION_KEY = T.let(T.unsafe(nil), String)

module NewRelic::Agent::DistributedTraceTransportType
  extend ::NewRelic::Agent::DistributedTraceTransportType

  def for_rack_request(request); end
  def from(value); end
end

NewRelic::Agent::DistributedTraceTransportType::ALLOWABLE_TRANSPORT_TYPES = T.let(T.unsafe(nil), Array)
NewRelic::Agent::DistributedTraceTransportType::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTraceTransportType::URL_SCHEMES = T.let(T.unsafe(nil), Hash)

# This module contains helper methods related to Distributed
# Tracing, an APM feature that ties together traces from multiple
# apps in one view.  Use it to add distributed tracing to protocols
# not already supported by the agent.
#
# @api public
module NewRelic::Agent::DistributedTracing
  extend ::NewRelic::SupportabilityHelper
  extend ::NewRelic::Agent::DistributedTracing

  # Accepts distributed tracing headers from any source that has been packaged
  # as a Ruby Hash, thereby allowing the user to manually inject distributed
  # tracing headers.  It is optimized to process +HTTP_TRACEPARENT+, +HTTP_TRACESTATE+,
  # and +HTTP_NEWRELIC+ as the given Hash keys.  which is the most common scenario
  # from Rack middleware in most Ruby applications.  However, the Hash keys are
  # case-insensitive and the "HTTP_" prefixes may also be omitted.
  #
  # Calling this method is not necessary in a typical HTTP trace as
  # distributed tracing is already handled by the agent.
  #
  # When used, invoke this method as early as possible in a transaction's life-cycle
  # as calling after the headers are already created will have no effect.
  #
  # This method accepts both W3C trace context and New Relic distributed tracing headers.
  # When both are present, only the W3C headers are utilized.  When W3C trace context
  # headers are present, New Relic headers are ignored regardless if W3C trace context
  # headers are valid and parsable.
  #
  # @api public
  # @param headers [Hash] Incoming distributed trace headers as a Ruby
  #   Hash object.  Hash keys are expected to be one of
  #   +TRACEPARENT+, +TRACESTATE+, +NEWRELIC+ and are
  #   case-insensitive, with or without "HTTP_" prefixes.
  #
  #   either as a JSON string or as a
  #   header-friendly string returned from
  #   {DistributedTracePayload#http_safe}
  # @param transport_Type [String] May be one of:  +HTTP+, +HTTPS+, +Kafka+, +JMS+,
  #   +IronMQ+, +AMQP+, +Queue+, +Other+.  Values are
  #   case sensitive.  All other values result in +Unknown+
  # @return [Transaction] if successful, +nil+ otherwise
  def accept_distributed_trace_headers(headers, transport_type = T.unsafe(nil)); end

  # Adds the Distributed Trace headers so that the downstream service can participate in a
  # distributed trace. This method should be called every time an outbound call is made
  # since the header payload contains a timestamp.
  #
  # Distributed Tracing must be enabled to use this method.
  #
  # +insert_distributed_trace_headers+ always inserts W3C trace context headers and inserts
  # New Relic distributed tracing header by default. New Relic headers may be suppressed by
  # setting +exclude_new_relic_header+ to +true+ in your configuration file.
  #
  # @api public
  # @param headers [Hash] Is a Hash to which the distributed trace headers
  #   will be inserted.
  # @return [Transaction] The transaction the headers were inserted from,
  #   or +nil+ if headers were not inserted.
  def insert_distributed_trace_headers(headers = T.unsafe(nil)); end

  private

  # @api public
  # @return [Boolean]
  def has_variant_key?(key, variants); end

  # @api public
  def variant_key_value(headers, variants); end
end

# @api public
class NewRelic::Agent::DistributedTracing::CrossAppMonitor < ::NewRelic::Agent::InboundRequestMonitor
  # @api public
  def on_finished_configuring(events); end

  # @api public
  def path_hash(txn_name, seed); end

  private

  # @api public
  def content_length_from_request(request); end

  # @api public
  def decoded_id(request); end

  # @api public
  def hash_transaction_name(identifier); end

  # @api public
  def insert_response_header(state, request_headers, response_headers); end

  # @api public
  def referring_transaction_info(state, request_headers); end

  # Expected sequence of events:
  #   :before_call will save our cross application request id to the thread
  #   :after_call will write our response headers/metrics and clean up the thread
  #
  # @api public
  def register_event_listeners(events); end

  # @api public
  def set_response_headers(transaction, response_headers, content_length); end

  # @api public
  # @return [Boolean]
  def should_process_request?(id); end
end

# @api public
NewRelic::Agent::DistributedTracing::CrossAppMonitor::CONTENT_LENGTH_HEADER_KEY = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::DistributedTracing::CrossAppMonitor::NEWRELIC_APPDATA_HEADER = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::DistributedTracing::CrossAppMonitor::NEWRELIC_ID_HEADER = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::DistributedTracing::CrossAppMonitor::NEWRELIC_ID_HEADER_KEY = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::DistributedTracing::CrossAppMonitor::NEWRELIC_TXN_HEADER = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::DistributedTracing::CrossAppMonitor::NEWRELIC_TXN_HEADER_KEY = T.let(T.unsafe(nil), String)

# @api public
class NewRelic::Agent::DistributedTracing::Monitor < ::NewRelic::Agent::InboundRequestMonitor
  # @api public
  def on_before_call(request); end

  # @api public
  def on_finished_configuring(events); end
end

class NewRelic::Agent::DistributedTracing::TraceContext
  class << self
    def create_trace_state_entry(entry_key, payload); end
    def insert(format: T.unsafe(nil), carrier: T.unsafe(nil), parent_id: T.unsafe(nil), trace_id: T.unsafe(nil), trace_flags: T.unsafe(nil), trace_state: T.unsafe(nil)); end
    def parse(format: T.unsafe(nil), carrier: T.unsafe(nil), trace_state_entry_key: T.unsafe(nil)); end

    private

    def decode_payload(payload); end
    def extract_traceparent(format, carrier); end
    def extract_tracestate(format, carrier, trace_state_entry_key); end
    def format_trace_parent(trace_id: T.unsafe(nil), parent_id: T.unsafe(nil), trace_flags: T.unsafe(nil)); end
    def trace_parent_header_for_format(format); end

    # @return [Boolean]
    def trace_parent_valid?(trace_parent); end

    def trace_state_header_for_format(format); end
  end
end

NewRelic::Agent::DistributedTracing::TraceContext::COMMA = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::EQUALS = T.let(T.unsafe(nil), String)

class NewRelic::Agent::DistributedTracing::TraceContext::HeaderData
  # @return [HeaderData] a new instance of HeaderData
  def initialize(trace_parent, trace_state_payload, trace_state_entries, trace_state_size, trace_state_vendors); end

  def parent_id; end
  def trace_id; end

  # Returns the value of attribute trace_parent.
  def trace_parent; end

  # Sets the attribute trace_parent
  #
  # @param value the value to set the attribute trace_parent to.
  def trace_parent=(_arg0); end

  def trace_state(trace_state_entry); end

  # Returns the value of attribute trace_state_payload.
  def trace_state_payload; end

  # Sets the attribute trace_state_payload
  #
  # @param value the value to set the attribute trace_state_payload to.
  def trace_state_payload=(_arg0); end

  # Returns the value of attribute trace_state_vendors.
  def trace_state_vendors; end

  # Sets the attribute trace_state_vendors
  #
  # @param value the value to set the attribute trace_state_vendors to.
  def trace_state_vendors=(_arg0); end

  private

  def join_trace_state(trace_state_entry_size); end

  class << self
    def create(trace_parent: T.unsafe(nil), trace_state_payload: T.unsafe(nil), trace_state_entries: T.unsafe(nil), trace_state_size: T.unsafe(nil), trace_state_vendors: T.unsafe(nil)); end
  end
end

NewRelic::Agent::DistributedTracing::TraceContext::INVALID_PARENT_ID = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::INVALID_TRACE_ID = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::INVALID_VERSION = T.let(T.unsafe(nil), String)

# bytes
NewRelic::Agent::DistributedTracing::TraceContext::MAX_TRACE_STATE_ENTRY_SIZE = T.let(T.unsafe(nil), Integer)

# bytes
NewRelic::Agent::DistributedTracing::TraceContext::MAX_TRACE_STATE_SIZE = T.let(T.unsafe(nil), Integer)

NewRelic::Agent::DistributedTracing::TraceContext::PARENT_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::SUPPORTABILITY_TRACE_PARENT_PARSE_EXCEPTION = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::SUPPORTABILITY_TRACE_STATE_INVALID_NR_ENTRY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::SUPPORTABILITY_TRACE_STATE_PARSE_EXCEPTION = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::TP_PARENT_ID = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::TP_TRACE_FLAGS = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::TP_TRACE_ID = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::TP_UNDEFINED_FIELDS = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::TP_VERSION = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::TRACE_FLAGS_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::TRACE_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::TRACE_PARENT_FORMAT_STRING = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::TRACE_PARENT_REGEX = T.let(T.unsafe(nil), Regexp)
NewRelic::Agent::DistributedTracing::TraceContext::UNDEFINED_FIELDS_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::VERSION = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::DistributedTracing::TraceContext::VERSION_KEY = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::ENTITY_GUID_KEY = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::ENTITY_NAME_KEY = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::ENTITY_TYPE = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::ENTITY_TYPE_KEY = T.let(T.unsafe(nil), String)

module NewRelic::Agent::EncodingNormalizer
  class << self
    def normalize_object(object); end
    def normalize_string(raw_string); end
  end
end

module NewRelic::Agent::EncodingNormalizer::EncodingNormalizer
  class << self
    def normalize(raw_string); end
  end
end

# This class collects errors from the parent application, storing
# them until they are harvested and transmitted to the server
class NewRelic::Agent::ErrorCollector
  # Returns a new error collector
  #
  # @return [ErrorCollector] a new instance of ErrorCollector
  def initialize(events); end

  def aggregated_metric_names(txn); end
  def blamed_metric_name(txn, options); end
  def create_noticed_error(exception, options); end

  # @return [Boolean]
  def disabled?; end

  def drop_buffered_data; end

  # @return [Boolean]
  def enabled?; end

  # Returns the value of attribute error_event_aggregator.
  def error_event_aggregator; end

  # an error is ignored if it is nil or if it is filtered
  #
  # @return [Boolean]
  def error_is_ignored?(error, status_code = T.unsafe(nil)); end

  # Returns the value of attribute error_trace_aggregator.
  def error_trace_aggregator; end

  # Calling instance_variable_set on a wrapped Java object in JRuby will
  # generate a warning unless that object's class has already been marked
  # as persistent, so we skip tagging of exception objects that are actually
  # wrapped Java objects on JRuby.
  #
  # See https://github.com/jruby/jruby/wiki/Persistence
  #
  # @return [Boolean]
  def exception_is_java_object?(exception); end

  # @return [Boolean]
  def exception_tagged_with?(ivar, exception); end

  def expect(errors); end

  # @return [Boolean]
  def expected?(ex, status_code = T.unsafe(nil)); end

  # extracts a stack trace from the exception for debugging purposes
  def extract_stack_trace(exception); end

  def ignore(errors); end

  # @return [Boolean]
  def ignore?(ex, status_code = T.unsafe(nil)); end

  # Checks the provided error against the error filter, if there
  # is an error filter
  #
  # @return [Boolean]
  def ignored_by_filter_proc?(error); end

  # Increments a statistic that tracks total error rate
  def increment_error_count!(state, exception, options = T.unsafe(nil)); end

  def increment_expected_error_count!(state, exception); end
  def load_error_filters; end

  # *Use sparingly for difficult to track bugs.*
  #
  # Track internal agent errors for communication back to New Relic.
  # To use, make a specific subclass of NewRelic::Agent::InternalAgentError,
  # then pass an instance of it to this method when your problem occurs.
  #
  # Limits are treated differently for these errors. We only gather one per
  # class per harvest, disregarding (and not impacting) the app error queue
  # limit.
  def notice_agent_error(exception); end

  # See NewRelic::Agent.notice_error for options and commentary
  def notice_error(exception, options = T.unsafe(nil), span_id = T.unsafe(nil)); end

  def notice_segment_error(segment, exception, options = T.unsafe(nil)); end
  def reset_error_filters; end

  # calls a method on an object, if it responds to it - used for
  # detection and soft fail-safe. Returns nil if the method does
  # not exist
  def sense_method(object, method); end

  # @return [Boolean]
  def skip_notice_error?(exception, status_code = T.unsafe(nil)); end

  def tag_exception(exception); end
  def tag_exception_using(ivar, exception); end
  def truncate_trace(trace, keep_frames = T.unsafe(nil)); end

  class << self
    def ignore_error_filter; end

    # We store the passed block in both an ivar on the class, and implicitly
    # within the body of the ignore_filter_proc method intentionally here.
    # The define_method trick is needed to get around the fact that users may
    # call 'return' from within their filter blocks, which would otherwise
    # result in a LocalJumpError.
    #
    # The raw block is also stored in an instance variable so that we can
    # return it later in its original form.
    #
    # This is all done at the class level in order to avoid the case where
    # the user sets up an ignore filter on one instance of the ErrorCollector,
    # and then that instance subsequently gets discarded during agent startup.
    # (For example, if the agent is initially disabled, and then gets enabled
    # via a call to manual_start later on.)
    def ignore_error_filter=(block); end
  end
end

NewRelic::Agent::ErrorCollector::EXCEPTION_TAG_IVAR = T.let(T.unsafe(nil), Symbol)

# Maximum possible length of the queue - defaults to 20, may be
# made configurable in the future. This is a tradeoff between
# memory and data retention
NewRelic::Agent::ErrorCollector::MAX_ERROR_QUEUE_LENGTH = T.let(T.unsafe(nil), Integer)

class NewRelic::Agent::ErrorEventAggregator < ::NewRelic::Agent::EventAggregator
  include ::NewRelic::Coerce

  def record(noticed_error, transaction_payload = T.unsafe(nil), span_id = T.unsafe(nil)); end

  private

  def create_event(noticed_error, transaction_payload, span_id); end
end

# Handles loading of ignored and expected errors from the agent configuration, and
# determining at runtime whether an exception is ignored or expected.
class NewRelic::Agent::ErrorFilter
  # @return [ErrorFilter] a new instance of ErrorFilter
  def initialize; end

  # See #ignore above.
  def expect(*args); end

  # @return [Boolean]
  def expected?(ex, status_code = T.unsafe(nil)); end

  def fetch_agent_config(cfg); end

  # A generic method for adding ignore filters manually. This is kept for compatibility
  # with the previous ErrorCollector#ignore method, and adds some flexibility for adding
  # different ignore/expected error types by examining each argument.
  def ignore(*args); end

  # @return [Boolean]
  def ignore?(ex, status_code = T.unsafe(nil)); end

  def load_all; end
  def load_from_config(setting, value = T.unsafe(nil)); end
  def reset; end

  private

  def log_filter(setting, errors); end
  def parse_status_codes(codes); end
end

class NewRelic::Agent::ErrorTraceAggregator
  # @return [ErrorTraceAggregator] a new instance of ErrorTraceAggregator
  def initialize(capacity); end

  # Synchronizes adding an error to the error queue, and checks if
  # the error queue is too long - if so, we drop the error on the
  # floor after logging a warning.
  def add_to_error_queue(noticed_error); end

  # @return [Boolean]
  def enabled?; end

  # Get the errors currently queued up.  Unsent errors are left
  # over from a previous unsuccessful attempt to send them to the server.
  def harvest!; end

  def merge!(errors); end

  # *Use sparingly for difficult to track bugs.*
  #
  # Track internal agent errors for communication back to New Relic.
  # To use, make a specific subclass of NewRelic::Agent::InternalAgentError,
  # then pass an instance of it to this method when your problem occurs.
  #
  # Limits are treated differently for these errors. We only gather one per
  # class per harvest, disregarding (and not impacting) the app error queue
  # limit.
  def notice_agent_error(exception); end

  # checks the size of the error queue to make sure we are under
  # the maximum limit, and logs a warning if we are over the limit.
  #
  # @return [Boolean]
  def over_queue_limit?(message); end

  def register_config_callbacks; end
  def reset!; end
end

class NewRelic::Agent::EventAggregator
  # @return [EventAggregator] a new instance of EventAggregator
  def initialize(events); end

  # interface method for subclasses to override to provide post harvest functionality
  def after_harvest(metadata); end

  # interface method for subclasses to override to provide post-initialization setup
  def after_initialize; end

  # @return [Boolean]
  def enabled?; end

  def harvest!; end

  # @return [Boolean]
  def has_metadata?; end

  # Merges samples from payload back into buffer and optionally adjusts the count of
  # the buffer to ensure accuracy of buffer of metadata. We want to make sure not to
  # double count samples being merged back in from a failed harvest, yet we do not
  # want to under-count samples being merged from the PipeService.
  def merge!(payload, adjust_count = T.unsafe(nil)); end

  def reset!; end

  private

  def notify_if_full; end
  def register_capacity_callback; end
  def register_enabled_callback(events); end
  def reservoir_metadata(metadata); end
  def reset_buffer!; end

  class << self
    def buffer_class(klass = T.unsafe(nil)); end
    def capacity_key(key = T.unsafe(nil)); end

    # This can be used instead of `enabled_key(s)` for more fine grained
    # control over whether an aggregator should be enabled. The enabled fn
    # will be reevaluated after configuration changes
    def enabled_fn(fn = T.unsafe(nil)); end

    # An aggregator can specify one or more keys to check to see if it is
    # enabled. Multiple keys will be &&'d and the enabled status of the
    # aggregator will be reset when agent configuration changes.
    def enabled_key(*keys); end

    # An aggregator can specify one or more keys to check to see if it is
    # enabled. Multiple keys will be &&'d and the enabled status of the
    # aggregator will be reset when agent configuration changes.
    def enabled_keys(*keys); end

    def named(named = T.unsafe(nil)); end
  end
end

class NewRelic::Agent::EventBuffer
  # @return [EventBuffer] a new instance of EventBuffer
  def initialize(capacity); end

  def <<(x); end
  def append(x); end

  # Returns the value of attribute capacity.
  def capacity; end

  def capacity=(new_capacity); end

  # @return [Boolean]
  def full?; end

  def metadata; end
  def note_dropped; end
  def num_dropped; end
  def num_seen; end
  def reset!; end
  def sample_rate; end
  def size; end
  def to_a; end
end

# Basic mechanism for the agent instance to provide agent-wide eventing.
# It is intended to keep different pieces of the app decoupled from each other.
#
# While an EventListener could be used elsewhere, it's strongly expected
# your eventing needs should be met by the agent's instance.
class NewRelic::Agent::EventListener
  # @return [EventListener] a new instance of EventListener
  def initialize; end

  def check_for_runaway_subscriptions(event); end
  def clear; end
  def notify(event, *args); end

  # Returns the value of attribute runaway_threshold.
  def runaway_threshold; end

  # Sets the attribute runaway_threshold
  #
  # @param value the value to set the attribute runaway_threshold to.
  def runaway_threshold=(_arg0); end

  def subscribe(event, &handler); end
end

class NewRelic::Agent::EventLoop
  # @return [EventLoop] a new instance of EventLoop
  def initialize; end

  def dispatch_event(event, args); end
  def fire(event, *args); end
  def fire_after(interval, event); end
  def fire_every(interval, event); end
  def fire_timer(timer); end
  def fire_timers; end
  def next_timeout; end
  def on(event, &blk); end
  def prune_timers; end
  def reschedule_timer_for_event(e); end
  def run; end
  def run_once(nonblock = T.unsafe(nil)); end
  def set_timer(timer); end
  def stop; end

  # @return [Boolean]
  def stopped?; end

  def wait_to_run(nonblock); end
  def wakeup; end
end

class NewRelic::Agent::EventLoop::Timer
  # @return [Timer] a new instance of Timer
  def initialize(interval, event, repeat = T.unsafe(nil)); end

  def advance(amount); end
  def calculate_next_fire_time; end

  # @return [Boolean]
  def due?(now = T.unsafe(nil)); end

  # Returns the value of attribute event.
  def event; end

  # @return [Boolean]
  def finished?; end

  # Returns the value of attribute interval.
  def interval; end

  # Returns the value of attribute last_fired_at.
  def last_fired_at; end

  def last_interval_start; end

  # Returns the value of attribute next_fire_time.
  def next_fire_time; end

  def reschedule; end
  def set_fired_time; end
end

# This module contains helper methods to facilitate
# instrumentation of external requests not directly supported by
# the Ruby agent. It is intended to be primarily used by authors
# of 3rd-party instrumentation.
#
# @api public
module NewRelic::Agent::External
  extend ::NewRelic::Agent::External

  # Obtain an obfuscated +String+ suitable for delivery across public networks that carries transaction
  # information from this application to a calling application which is also running a New Relic agent.
  # This +String+ can be processed by +process_response_metadata+ on the calling application.
  #
  # @api public
  # @return [String] obfuscated response metadata to send
  def get_response_metadata; end

  # Process obfuscated +String+ indentifying a calling application and transaction that is also running a
  # New Relic agent and save information in current transaction for inclusion in a trace. The +String+ is
  # generated by +get_request_metadata+ on the calling application.
  #
  # @api public
  # @param request_metadata [String] received obfuscated request metadata
  def process_request_metadata(request_metadata); end

  private

  # @api public
  def obfuscator; end
end

# @api public
NewRelic::Agent::External::NON_HTTP_CAT_CONTENT_LENGTH = T.let(T.unsafe(nil), Integer)

# @api public
NewRelic::Agent::External::NON_HTTP_CAT_ID_HEADER = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::External::NON_HTTP_CAT_SYNTHETICS_HEADER = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::External::NON_HTTP_CAT_TXN_HEADER = T.let(T.unsafe(nil), String)

# An exception that forces an agent to stop reporting until its mongrel is restarted.
#
# @api public
class NewRelic::Agent::ForceDisconnectException < ::StandardError; end

# An exception that forces an agent to restart.
#
# @api public
class NewRelic::Agent::ForceRestartException < ::StandardError
  # @api public
  def message; end
end

module NewRelic::Agent::GuidGenerator
  private

  # This method intentionally does not use SecureRandom, because it relies
  # on urandom, which raises an exception in MRI when the interpreter runs
  # out of allocated file descriptors.
  # The guids generated by this method may not be _secure_, but they are
  # random enough for our purposes.
  def generate_guid(length = T.unsafe(nil)); end

  class << self
    # This method intentionally does not use SecureRandom, because it relies
    # on urandom, which raises an exception in MRI when the interpreter runs
    # out of allocated file descriptors.
    # The guids generated by this method may not be _secure_, but they are
    # random enough for our purposes.
    def generate_guid(length = T.unsafe(nil)); end
  end
end

# @api public
NewRelic::Agent::HOSTNAME_KEY = T.let(T.unsafe(nil), String)

module NewRelic::Agent::HTTPClients; end

module NewRelic::Agent::HTTPClients::URIUtil
  class << self
    def obfuscated_uri(url); end

    # There are valid URI strings that some HTTP client libraries will
    # accept that the stdlib URI module doesn't handle. If we find that
    # Addressable is around, use that to normalize out our URL's.
    def parse_and_normalize_url(url); end

    def strip_query_string(fragment); end
  end
end

NewRelic::Agent::HTTPClients::URIUtil::QUESTION_MARK = T.let(T.unsafe(nil), String)

class NewRelic::Agent::Harvester
  # Inject target for after_fork call to avoid spawning thread in tests
  #
  # @return [Harvester] a new instance of Harvester
  def initialize(events, after_forker = T.unsafe(nil)); end

  # @return [Boolean]
  def harvest_thread_enabled?; end

  def mark_started(pid = T.unsafe(nil)); end

  # @return [Boolean]
  def needs_restart?(pid = T.unsafe(nil)); end

  def on_transaction(*_); end
  def restart_harvest_thread; end

  # @return [Boolean]
  def restart_in_children_enabled?; end

  # Returns the value of attribute starting_pid.
  def starting_pid; end

  # Sets the attribute starting_pid
  #
  # @param value the value to set the attribute starting_pid to.
  def starting_pid=(_arg0); end
end

# This class implements a min Heap. The first element is always the one with the
# lowest priority. It is a tree structure that is represented as an array. The
# relationship between between nodes in the tree and indices in the array are as
# follows:
#
# parent_index      = (child_index -  1) / 2
# left_child_index  = parent_index * 2 + 1
# right_child_index = parent_index * 2 + 2
#
# the root node is at index 0
# a node is a leaf node when its index >= length / 2
class NewRelic::Agent::Heap
  # @param items [Array] an optional array of items to intialize the heap
  # @param priority_fn [Callable] an optional priority function used to
  #   to compute the priority for an item. If it's not supplied priority
  #   will be computed using Comparable.
  # @return [Heap] a new instance of Heap
  def initialize(items = T.unsafe(nil), &priority_fn); end

  def <<(item); end
  def [](index); end
  def []=(index, value); end

  # @return [Boolean]
  def empty?; end

  def fix(index); end
  def pop; end
  def push(item); end
  def size; end
  def to_a; end

  private

  def heapify_down(parent_index); end
  def heapify_up(child_index); end

  # @return [Boolean]
  def in_range?(index); end

  def left_child_index_for(parent_index); end
  def parent_index_for(child_index); end
  def priority(index); end

  # @return [Boolean]
  def right_sibling_smaller?(lchild_index); end

  def swap(i, j); end
end

module NewRelic::Agent::Hostname
  class << self
    def get; end
    def get_dyno_prefixes; end
    def get_external(host_or_ip); end

    # Pass '-f' to the external executable 'hostname' to request the fully
    # qualified domain name (fqdn). For implementations of 'hostname' that
    # do not support '-f' (such as the one OpenBSD ships with), fall back
    # to calling 'hostname' without the '-f'. If both ways of calling
    # 'hostname' fail, or in a context where 'hostname' is not even
    # available (within an AWS Lambda function, for example), call the
    # 'get' method which uses Socket instead of an external executable.
    def get_fqdn; end

    def heroku_dyno_name_prefix(dyno_name); end

    # @return [Boolean]
    def local?(host_or_ip); end
  end
end

NewRelic::Agent::Hostname::LOCALHOST = T.let(T.unsafe(nil), Array)

class NewRelic::Agent::InboundRequestMonitor
  # @return [InboundRequestMonitor] a new instance of InboundRequestMonitor
  def initialize(events); end

  def deserialize_header(encoded_header, key); end

  # Returns the value of attribute obfuscator.
  def obfuscator; end

  def setup_obfuscator; end
end

# stub module that contains instrumentation defined in the
# instrumentation directory
module NewRelic::Agent::Instrumentation; end

# == NewRelic instrumentation for controller actions and tasks
#
# This module can also be used to capture performance information for
# background tasks and other non-web transactions, including
# detailed transaction traces and traced errors.
#
# For details on how to instrument background tasks see
# {ClassMethods#add_transaction_tracer} and
# {#perform_action_with_newrelic_trace}
#
# @api public
module NewRelic::Agent::Instrumentation::ControllerInstrumentation
  mixes_in_class_methods ::NewRelic::Agent::Instrumentation::ControllerInstrumentation::ClassMethods

  # Yield to the given block with NewRelic tracing.  Used by
  # default instrumentation on controller actions in Rails.
  # But it can also be used in custom instrumentation of controller
  # methods and background tasks.
  #
  # This is the method invoked by instrumentation added by the
  # <tt>ClassMethods#add_transaction_tracer</tt>.
  #
  # Here's a more verbose version of the example shown in
  # <tt>ClassMethods#add_transaction_tracer</tt> using this method instead of
  # #add_transaction_tracer.
  #
  # Below is a controller with an +invoke_operation+ action which
  # dispatches to more specific operation methods based on a
  # parameter (very dangerous, btw!).  With this instrumentation,
  # the +invoke_operation+ action is ignored but the operation
  # methods show up in New Relic as if they were first class controller
  # actions
  #
  #   MyController < ActionController::Base
  #     include NewRelic::Agent::Instrumentation::ControllerInstrumentation
  #     # dispatch the given op to the method given by the service parameter.
  #     def invoke_operation
  #       op = params['operation']
  #       perform_action_with_newrelic_trace(:name => op) do
  #         send op, params['message']
  #       end
  #     end
  #     # Ignore the invoker to avoid double counting
  #     newrelic_ignore :only => 'invoke_operation'
  #   end
  #
  #
  # When invoking this method explicitly as in the example above, pass in a
  # block to measure with some combination of options:
  #
  # * <tt>:category => :controller</tt> indicates that this is a
  #   controller action and will appear with all the other actions.  This
  #   is the default.
  # * <tt>:category => :task</tt> indicates that this is a
  #   background task and will show up in New Relic with other background
  #   tasks instead of in the controllers list
  # * <tt>:category => :middleware</tt> if you are instrumenting a rack
  #   middleware call.  The <tt>:name</tt> is optional, useful if you
  #   have more than one potential transaction in the #call.
  # * <tt>:category => :uri</tt> indicates that this is a
  #   web transaction whose name is a normalized URI, where  'normalized'
  #   means the URI does not have any elements with data in them such
  #   as in many REST URIs.
  # * <tt>:name => action_name</tt> is used to specify the action
  #   name used as part of the metric name
  # * <tt>:params => {...}</tt> to provide information about the context
  #   of the call, used in transaction trace display, for example:
  #   <tt>:params => { :account => @account.name, :file => file.name }</tt>
  #   These are treated similarly to request parameters in web transactions.
  #
  # Seldomly used options:
  #
  # * <tt>:class_name => aClass.name</tt> is used to override the name
  #   of the class when used inside the metric name.  Default is the
  #   current class.
  # * <tt>:path => metric_path</tt> is *deprecated* in the public API.  It
  #   allows you to set the entire metric after the category part.  Overrides
  #   all the other options.
  # * <tt>:request => Rack::Request#new(env)</tt> is used to pass in a
  #   request object that may respond to path and referer.
  #
  # @api public
  def perform_action_with_newrelic_trace(*args, &block); end

  protected

  # overrideable method to determine whether to trace an action
  # or not - you may override this in your controller and supply
  # your own logic for ignoring transactions.
  #
  # @api public
  # @return [Boolean]
  def do_not_trace?; end

  # overrideable method to determine whether to trace an action
  # for purposes of apdex measurement - you can use this to
  # ignore things like api calls or other fast non-user-facing
  # actions
  #
  # @api public
  # @return [Boolean]
  def ignore_apdex?; end

  # @api public
  # @return [Boolean]
  def ignore_enduser?; end

  # @api public
  def newrelic_request(args); end

  # @api public
  def newrelic_request_headers(request); end

  # Should be implemented in the dispatcher class
  #
  # @api public
  def newrelic_response_code; end

  private

  # Filter out a request if it matches one of our parameters for
  # ignoring it - the key is either NR_DO_NOT_TRACE_KEY or NR_IGNORE_APDEX_KEY
  #
  # @api public
  # @return [Boolean]
  def _is_filtered?(key); end

  # @api public
  def create_transaction_options(trace_options, category, state, queue_start_time); end

  # @api public
  def detect_queue_start_time(request); end

  class << self
    # @api public
    def included(clazz); end
  end
end

# @api public
module NewRelic::Agent::Instrumentation::ControllerInstrumentation::ClassMethods
  # Add transaction tracing to the given method.  This will treat
  # the given method as a main entrypoint for instrumentation, just
  # like controller actions are treated by default.  Useful especially
  # for background tasks.
  #
  # Example for background job:
  #   class Job
  #     include NewRelic::Agent::Instrumentation::ControllerInstrumentation
  #     def run(task)
  #        ...
  #     end
  #     # Instrument run so tasks show up under task.name.  Note single
  #     # quoting to defer eval to runtime.
  #     add_transaction_tracer :run, :name => '#{args[0].name}'
  #   end
  #
  # Here's an example of a controller that uses a dispatcher
  # action to invoke operations which you want treated as top
  # level actions, so they aren't all lumped into the invoker
  # action.
  #
  #   MyController < ActionController::Base
  #     include NewRelic::Agent::Instrumentation::ControllerInstrumentation
  #     # dispatch the given op to the method given by the service parameter.
  #     def invoke_operation
  #       op = params['operation']
  #       send op
  #     end
  #     # Ignore the invoker to avoid double counting
  #     newrelic_ignore :only => 'invoke_operation'
  #     # Instrument the operations:
  #     add_transaction_tracer :print
  #     add_transaction_tracer :show
  #     add_transaction_tracer :forward
  #   end
  #
  # Here's an example of how to pass contextual information into the transaction
  # so it will appear in transaction traces:
  #
  #   class Job
  #     include NewRelic::Agent::Instrumentation::ControllerInstrumentation
  #     def process(account)
  #        ...
  #     end
  #     # Include the account name in the transaction details.  Note the single
  #     # quotes to defer eval until call time.
  #     add_transaction_tracer :process, :params => '{ :account_name => args[0].name }'
  #   end
  #
  # See NewRelic::Agent::Instrumentation::ControllerInstrumentation#perform_action_with_newrelic_trace
  # for the full list of available options.
  #
  # @api public
  def add_transaction_tracer(method, options = T.unsafe(nil)); end

  # @api public
  # @return [Boolean]
  def already_added_transaction_tracer?(target, with_method_name); end

  # @api public
  def build_method_names(traced_method, punctuation); end

  # @api public
  def generate_argument_list(options); end

  # Have NewRelic ignore actions in this controller.  Specify the actions as hash options
  # using :except and :only.  If no actions are specified, all actions are ignored.
  #
  # @api public
  def newrelic_ignore(specifiers = T.unsafe(nil)); end

  # Have NewRelic omit apdex measurements on the given actions.  Typically used for
  # actions that are not user facing or that skew your overall apdex measurement.
  # Accepts :except and :only options, as with #newrelic_ignore.
  #
  # @api public
  def newrelic_ignore_apdex(specifiers = T.unsafe(nil)); end

  # @api public
  def newrelic_ignore_aspect(property, specifiers = T.unsafe(nil)); end

  # @api public
  def newrelic_ignore_enduser(specifiers = T.unsafe(nil)); end

  # @api public
  def newrelic_read_attr(attr_name); end

  # Should be monkey patched into the controller class implemented
  # with the inheritable attribute mechanism.
  #
  # @api public
  def newrelic_write_attr(attr_name, value); end

  # @api public
  def parse_punctuation(method); end
end

# This module is for importing stubs when the agent is disabled
#
# @api public
module NewRelic::Agent::Instrumentation::ControllerInstrumentation::ClassMethodsShim
  # @api public
  def newrelic_ignore(*args); end

  # @api public
  def newrelic_ignore_apdex(*args); end

  # @api public
  def newrelic_ignore_enduser(*args); end
end

# @api public
NewRelic::Agent::Instrumentation::ControllerInstrumentation::NR_DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

# @api public
NewRelic::Agent::Instrumentation::ControllerInstrumentation::NR_DO_NOT_TRACE_KEY = T.let(T.unsafe(nil), Symbol)

# @api public
NewRelic::Agent::Instrumentation::ControllerInstrumentation::NR_IGNORE_APDEX_KEY = T.let(T.unsafe(nil), Symbol)

# @api public
NewRelic::Agent::Instrumentation::ControllerInstrumentation::NR_IGNORE_ENDUSER_KEY = T.let(T.unsafe(nil), Symbol)

# @api public
module NewRelic::Agent::Instrumentation::ControllerInstrumentation::Shim
  mixes_in_class_methods ::NewRelic::Agent::Instrumentation::ControllerInstrumentation::ClassMethodsShim

  # @api public
  def new_relic_trace_controller_action(*args); end

  # @api public
  def perform_action_with_newrelic_trace(*args); end

  class << self
    # @api public
    # @private
    def included(clazz); end
  end
end

# @api public
class NewRelic::Agent::Instrumentation::ControllerInstrumentation::TransactionNamer
  class << self
    # @api public
    def class_name(traced_obj, options = T.unsafe(nil)); end

    # @api public
    def name_for(txn, traced_obj, category, options = T.unsafe(nil)); end

    # @api public
    def path_name(traced_obj, options = T.unsafe(nil)); end

    # @api public
    def prefix_for_category(txn, category = T.unsafe(nil)); end
  end
end

module NewRelic::Agent::Instrumentation::IgnoreActions
  class << self
    # @return [Boolean]
    def is_filtered?(key, klass, action_name); end
  end
end

module NewRelic::Agent::Instrumentation::Logger
  def clear_skip_instrumenting; end
  def format_message_with_tracing(severity, datetime, progname, msg); end
  def mark_skip_instrumenting; end

  # @return [Boolean]
  def skip_instrumenting?; end

  class << self
    def clear_skip_instrumenting(logger); end

    # @return [Boolean]
    def enabled?; end

    # We support setting this on loggers which might not have
    # instrumentation installed yet. This lets us disable in AgentLogger
    # and AuditLogger without them having to know the inner details.
    def mark_skip_instrumenting(logger); end
  end
end

# https://newrelic.com/docs/features/tracking-front-end-time
# Record queue time metrics based on any of three headers
# which can be set on the request.
module NewRelic::Agent::Instrumentation::QueueTime
  private

  def parse_frontend_timestamp(headers, now = T.unsafe(nil)); end
  def parse_timestamp(string); end
  def timestamp_string_from_header_value(value); end

  class << self
    def parse_frontend_timestamp(headers, now = T.unsafe(nil)); end
    def parse_timestamp(string); end
    def timestamp_string_from_header_value(value); end
  end
end

NewRelic::Agent::Instrumentation::QueueTime::ALL_QUEUE_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Instrumentation::QueueTime::CANDIDATE_HEADERS = T.let(T.unsafe(nil), Array)
NewRelic::Agent::Instrumentation::QueueTime::DIVISORS = T.let(T.unsafe(nil), Array)

# any timestamps before this are thrown out and the parser
# will try again with a larger unit (2000/1/1 UTC)
NewRelic::Agent::Instrumentation::QueueTime::EARLIEST_ACCEPTABLE_TIME = T.let(T.unsafe(nil), Float)

NewRelic::Agent::Instrumentation::QueueTime::MIDDLEWARE_START_HEADER = T.let(T.unsafe(nil), String)
NewRelic::Agent::Instrumentation::QueueTime::QUEUE_START_HEADER = T.let(T.unsafe(nil), String)
NewRelic::Agent::Instrumentation::QueueTime::REQUEST_START_HEADER = T.let(T.unsafe(nil), String)
module NewRelic::Agent::Instrumentation::Resque; end

module NewRelic::Agent::Instrumentation::Resque::Helper
  extend ::NewRelic::Agent::Instrumentation::Resque::Helper

  # @return [Boolean]
  def resque_fork_per_job?; end
end

class NewRelic::Agent::InternalAgentError < ::StandardError
  # @return [InternalAgentError] a new instance of InternalAgentError
  def initialize(msg = T.unsafe(nil)); end
end

class NewRelic::Agent::JavascriptInstrumentor
  include ::NewRelic::Coerce

  # @return [JavascriptInstrumentor] a new instance of JavascriptInstrumentor
  def initialize(event_listener); end

  def add_attributes(data, txn); end
  def add_ssl_for_http(data); end
  def append_agent_attributes!(txn, atts); end
  def append_custom_attributes!(txn, atts); end
  def browser_timing_config(state, nonce = T.unsafe(nil)); end

  # THREAD_LOCAL_ACCESS
  def browser_timing_header(nonce = T.unsafe(nil)); end

  def browser_timing_loader(nonce = T.unsafe(nil)); end
  def create_nonce(nonce = T.unsafe(nil)); end

  # NOTE: Internal prototyping may override this, so leave name stable!
  def data_for_js_agent(transaction); end

  # @return [Boolean]
  def enabled?; end

  def html_safe_if_needed(string); end

  # @return [Boolean]
  def insert_js?(state); end

  # @return [Boolean]
  def js_enabled_and_ready?; end

  def log_configuration; end

  # @return [Boolean]
  def missing_config?(key); end

  def obfuscator; end
end

NewRelic::Agent::JavascriptInstrumentor::AGENT_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::JavascriptInstrumentor::APPLICATIONID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::JavascriptInstrumentor::APPLICATION_TIME_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::JavascriptInstrumentor::ATTS_AGENT_SUBKEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::JavascriptInstrumentor::ATTS_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::JavascriptInstrumentor::ATTS_USER_SUBKEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::JavascriptInstrumentor::BEACON_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::JavascriptInstrumentor::ERROR_BEACON_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::JavascriptInstrumentor::LICENSE_KEY_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::JavascriptInstrumentor::QUEUE_TIME_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::JavascriptInstrumentor::RUM_KEY_LENGTH = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::JavascriptInstrumentor::SSL_FOR_HTTP_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::JavascriptInstrumentor::TRANSACTION_NAME_KEY = T.let(T.unsafe(nil), String)
class NewRelic::Agent::LicenseException < ::StandardError; end

# This module contains helper methods related to gathering linking
# metadata for use with logs in context.
module NewRelic::Agent::LinkingMetadata
  extend ::NewRelic::Agent::LinkingMetadata

  # @raise [ArgumentError]
  def append_service_linking_metadata(metadata); end

  # @raise [ArgumentError]
  def append_trace_linking_metadata(metadata); end
end

# This module contains helper methods related to decorating log messages
module NewRelic::Agent::LocalLogDecorator
  extend ::NewRelic::Agent::LocalLogDecorator

  def decorate(message); end

  private

  # @return [Boolean]
  def decorating_enabled?; end

  def escape_entity_name(entity_name); end
end

class NewRelic::Agent::LogEventAggregator < ::NewRelic::Agent::EventAggregator
  # @return [LogEventAggregator] a new instance of LogEventAggregator
  def initialize(events); end

  def capacity; end
  def create_event(priority, formatted_message, severity); end

  # @return [Boolean]
  def enabled?; end

  def harvest!; end
  def record(formatted_message, severity); end
  def record_batch(txn, logs); end
  def reset!; end

  private

  def after_harvest(metadata); end
  def line_metric_name_by_severity(severity); end
  def note_dropped_events(total_count, dropped_count); end
  def record_configuration_metric(format, key); end

  # To avoid paying the cost of metric recording on every line, we hold
  # these until harvest before recording them
  def record_customer_metrics; end

  def record_supportability_metrics(total_count, captured_count, dropped_count); end

  # We record once-per-connect metrics for enabled/disabled state at the
  # point we consider the configuration stable (i.e. once we've gotten SSC)
  def register_for_done_configuring(events); end

  def truncate_message(message); end

  class << self
    # Because our transmission format (MELT) is different than historical
    # agent payloads, extract the munging here to keep the service focused
    # on the general harvest + transmit instead of the format.
    #
    # Payload shape matches the publicly documented MELT format.
    # https://docs.newrelic.com/docs/logs/log-api/introduction-log-api
    #
    # We have to keep the aggregated payloads in a separate shape, though, to
    # work with the priority sampling buffers
    def payload_to_melt_format(data); end
  end
end

NewRelic::Agent::LogEventAggregator::DECORATING_ENABLED_KEY = T.let(T.unsafe(nil), Symbol)
NewRelic::Agent::LogEventAggregator::DECORATING_SUPPORTABILITY_FORMAT = T.let(T.unsafe(nil), String)
NewRelic::Agent::LogEventAggregator::DROPPED_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::LogEventAggregator::FORWARDING_ENABLED_KEY = T.let(T.unsafe(nil), Symbol)
NewRelic::Agent::LogEventAggregator::FORWARDING_SUPPORTABILITY_FORMAT = T.let(T.unsafe(nil), String)

# Per-message keys
NewRelic::Agent::LogEventAggregator::LEVEL_KEY = T.let(T.unsafe(nil), String)

# Metric keys
NewRelic::Agent::LogEventAggregator::LINES = T.let(T.unsafe(nil), String)

# 32 * 1024 bytes (32 kibibytes)
NewRelic::Agent::LogEventAggregator::MAX_BYTES = T.let(T.unsafe(nil), Integer)

NewRelic::Agent::LogEventAggregator::MESSAGE_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::LogEventAggregator::METRICS_ENABLED_KEY = T.let(T.unsafe(nil), Symbol)
NewRelic::Agent::LogEventAggregator::METRICS_SUPPORTABILITY_FORMAT = T.let(T.unsafe(nil), String)

# Config keys
NewRelic::Agent::LogEventAggregator::OVERALL_ENABLED_KEY = T.let(T.unsafe(nil), Symbol)

NewRelic::Agent::LogEventAggregator::OVERALL_SUPPORTABILITY_FORMAT = T.let(T.unsafe(nil), String)
NewRelic::Agent::LogEventAggregator::PRIORITY_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::LogEventAggregator::SEEN_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::LogEventAggregator::SENT_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::LogEventAggregator::TIMESTAMP_KEY = T.let(T.unsafe(nil), String)

module NewRelic::Agent::LogOnce
  def clear_already_logged; end
  def log_once(level, key, *msgs); end
end

NewRelic::Agent::LogOnce::NUM_LOG_ONCE_KEYS = T.let(T.unsafe(nil), Integer)

module NewRelic::Agent::LogPriority
  extend ::NewRelic::Agent::LogPriority

  def priority_for(txn); end
end

module NewRelic::Agent::Logging; end

# This class can be used as the formatter for an existing logger.  It
# decorates log messages with trace and entity metadata, and formats each
# log messages as a JSON object.
#
# It can be added to a Rails application like this:
#
#   require 'newrelic_rpm'
#
#   Rails.application.configure do
#     config.log_formatter = ::NewRelic::Agent::Logging::DecoratingFormatter.new
#   end
#
# @api public
class NewRelic::Agent::Logging::DecoratingFormatter < ::Logger::Formatter
  # @api public
  # @return [DecoratingFormatter] a new instance of DecoratingFormatter
  def initialize; end

  # @api public
  def add_key_value(message, key, value); end

  # @api public
  def app_name; end

  # @api public
  def call(severity, time, progname, msg); end

  # @api public
  def clear_tags!; end

  # @api public
  def escape(message); end
end

# @api public
NewRelic::Agent::Logging::DecoratingFormatter::CLOSING_BRACE = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Logging::DecoratingFormatter::COLON = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Logging::DecoratingFormatter::COMMA = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Logging::DecoratingFormatter::LOG_LEVEL_KEY = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Logging::DecoratingFormatter::LOG_NAME_KEY = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Logging::DecoratingFormatter::MESSAGE_KEY = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Logging::DecoratingFormatter::NEWLINE = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Logging::DecoratingFormatter::QUOTE = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Logging::DecoratingFormatter::REPLACEMENT_CHAR = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Logging::DecoratingFormatter::TIMESTAMP_KEY = T.let(T.unsafe(nil), String)

# This logger decorates logs with trace and entity metadata, and emits log
# messages formatted as JSON objects.  It extends the Logger class from
# the Ruby standard library, and accepts the same constructor parameters.
#
# It aliases the `:info` message to overwrite the `:write` method, so it
# can be used in Rack applications that expect the logger to be a file-like
# object.
#
# It can be added to an application like this:
#
#   require 'newrelic_rpm'
#
#   config.logger = NewRelic::Agent::Logging::DecoratingLogger.new "log/application.log"
#
# @api public
class NewRelic::Agent::Logging::DecoratingLogger < ::ActiveSupport::Logger
  # @api public
  # @return [DecoratingLogger] a new instance of DecoratingLogger
  def initialize(*args, **kwargs); end

  # @api public
  def write(progname = T.unsafe(nil), &block); end
end

class NewRelic::Agent::MemoryLogger
  include ::NewRelic::Agent::LogOnce

  # @return [MemoryLogger] a new instance of MemoryLogger
  def initialize; end

  def debug(*msgs, &blk); end
  def dump(logger); end
  def error(*msgs, &blk); end
  def fatal(*msgs, &blk); end
  def info(*msgs, &blk); end

  # @return [Boolean]
  def is_startup_logger?; end

  # Returns the value of attribute level.
  def level; end

  # Sets the attribute level
  #
  # @param value the value to set the attribute level to.
  def level=(_arg0); end

  def log_exception(level, e, backtrace_level = T.unsafe(nil)); end

  # Returns the value of attribute log_formatter.
  def log_formatter; end

  # Sets the attribute log_formatter
  #
  # @param value the value to set the attribute log_formatter to.
  def log_formatter=(_arg0); end

  # Returns the value of attribute messages.
  def messages; end

  # Sets the attribute messages
  #
  # @param value the value to set the attribute messages to.
  def messages=(_arg0); end

  def warn(*msgs, &blk); end
end

# This module contains class methods added to support installing custom
# metric tracers and executing for individual metrics.
#
# == Examples
#
# When the agent initializes, it extends Module with these methods.
# However if you want to use the API in code that might get loaded
# before the agent is initialized you will need to require
# this file:
#
#     require 'new_relic/agent/method_tracer'
#     class A
#       include NewRelic::Agent::MethodTracer
#       def process
#         ...
#       end
#       add_method_tracer :process
#     end
#
# To instrument a class method:
#
#     require 'new_relic/agent/method_tracer'
#     class An
#       def self.process
#         ...
#       end
#       class << self
#         include NewRelic::Agent::MethodTracer
#         add_method_tracer :process
#       end
#     end
#
# @api public
module NewRelic::Agent::MethodTracer
  mixes_in_class_methods ::NewRelic::Agent::MethodTracer::ClassMethods

  # Trace a given block with stats and keep track of the caller.
  # See NewRelic::Agent::MethodTracer::ClassMethods#add_method_tracer for a description of the arguments.
  # +metric_names+ is either a single name or an array of metric names.
  # If more than one metric is passed, the +produce_metric+ option only applies to the first.  The
  # others are always recorded.  Only the first metric is pushed onto the scope stack.
  #
  # Generally you pass an array of metric names if you want to record the metric under additional
  # categories, but generally this *should never ever be done*.  Most of the time you can aggregate
  # on the server.
  #
  # @api public
  def trace_execution_scoped(metric_names, options = T.unsafe(nil)); end

  # Trace a given block with stats assigned to the given metric_name.  It does not
  # provide scoped measurements, meaning whatever is being traced will not 'blame the
  # Controller'--that is to say appear in the breakdown chart.
  #
  # * <tt>metric_names</tt> is a single name or an array of names of metrics
  #
  # @api public
  def trace_execution_unscoped(metric_names, options = T.unsafe(nil)); end

  class << self
    # @api public
    # @private
    def extended(klass); end

    # @api public
    # @private
    def included(klass); end
  end
end

# Defines methods used at the class level, for adding instrumentation
#
# @api public
module NewRelic::Agent::MethodTracer::ClassMethods
  include ::NewRelic::Agent::MethodTracer::ClassMethods::AddMethodTracer

  # Add a method tracer to the specified method.
  #
  # By default, this will cause invocations of the traced method to be
  # recorded in transaction traces, and in a metric named after the class
  # and method. It will also make the method show up in transaction-level
  # breakdown charts and tables.
  #
  # === Overriding the metric name
  #
  # +metric_name+ is a String or Proc. If a Proc is given, it is bound to
  # the object that called the traced method. For example:
  #
  #     add_method_tracer :foo, -> { "Custom/#{self.class.name}/foo" }
  #
  # This would name the metric according to the class of the runtime
  # instance, as opposed to the class where +foo+ is defined.
  #
  # If not provided, the metric name will be <tt>Custom/ClassName/method_name</tt>.
  #
  # @api public
  # @example
  #   add_method_tracer :foo
  #
  #   # With a custom metric name
  #   add_method_tracer :foo, "Custom/MyClass/foo"
  #   add_method_tracer :bar, -> { "Custom/#{self.class.name}/bar" }
  #
  #   # Instrument foo only for custom dashboards (not in transaction
  #   # traces or breakdown charts)
  #   add_method_tracer :foo, 'Custom/foo', :push_scope => false
  #
  #   # Instrument foo in transaction traces only
  #   add_method_tracer :foo, 'Custom/foo', :metric => false
  # @option options
  # @option options
  # @option options
  # @option options
  # @param method_name [Symbol] the name of the method to trace
  # @param metric_name [String, Proc, Array] the metric name to record calls to
  #   the traced method under. This may be either a String, or a Proc
  #   to be evaluated at call-time in order to determine the metric
  #   name dynamically.
  #   This method also accepts an array of Strings/Procs, in which case the
  #   first metric given will be scoped, while the remaining metrics will be
  #   recorded as though passed with :push_scope => false. If an Array of
  #   metric names is given with :push_scope => false, all metrics will be
  #   unscoped.
  # @param options [Hash] additional options controlling how the method is
  #   traced.
  def add_method_tracer(method_name, metric_name = T.unsafe(nil), options = T.unsafe(nil)); end

  # For tests only because tracers must be removed in reverse-order
  # from when they were added, or else other tracers that were added to the same method
  # may get removed as well.
  #
  # @api public
  def remove_method_tracer(method_name); end

  private

  # @api public
  def _nr_add_method_tracer_now(method_name, metric_name, options); end

  # @api public
  def _nr_define_traced_method(method_name, scoped_metric: T.unsafe(nil), unscoped_metrics: T.unsafe(nil), code_header: T.unsafe(nil), code_footer: T.unsafe(nil), record_metrics: T.unsafe(nil), visibility: T.unsafe(nil)); end

  # See #add_method_tracer; if multiple metric names are given, the first is
  # treated as scoped, the rest unscoped. If options[:push_scope] is false,
  # all given metrics are unscoped.
  #
  # @api public
  def _nr_scoped_unscoped_metrics(metric_name, method_name, push_scope: T.unsafe(nil)); end
end

# contains methods refactored out of the #add_method_tracer method
#
# @api public
module NewRelic::Agent::MethodTracer::ClassMethods::AddMethodTracer
  # for testing only
  #
  # @api public
  def _nr_clear_traced_methods!; end

  # Default to the class where the method is defined.
  #
  # Example:
  #  Foo._nr_default_metric_name_code('bar') #=> "Custom/#{Foo.name}/bar"
  #
  # @api public
  def _nr_default_metric_name(method_name); end

  # @api public
  def _nr_derived_class_name; end

  # Returns an anonymous module that stores prepended trace methods.
  #
  # @api public
  def _nr_traced_method_module; end

  # Checks the provided options to make sure that they make
  # sense. Raises an error if the options are incorrect to
  # assist with debugging, so that errors occur at class
  # construction time rather than instrumentation run time
  #
  # @api public
  def _nr_validate_method_tracer_options(method_name, options); end

  # Checks to see if we have already traced a method with a
  # given metric by checking to see if the traced method
  # exists. Warns the user if methods are being double-traced
  # to help with debugging custom instrumentation.
  #
  # @api public
  # @return [Boolean]
  def method_traced?(method_name); end

  # Checks to see if the method we are attempting to trace
  # actually exists or not. #add_method_tracer can't do
  # anything if the method doesn't exist.
  #
  # @api public
  # @return [Boolean]
  def newrelic_method_exists?(method_name); end
end

# @api public
NewRelic::Agent::MethodTracer::ClassMethods::AddMethodTracer::ALLOWED_KEYS = T.let(T.unsafe(nil), Array)

# @api public
NewRelic::Agent::MethodTracer::ClassMethods::AddMethodTracer::DEFAULT_SETTINGS = T.let(T.unsafe(nil), Hash)

module NewRelic::Agent::MethodTracerHelpers
  extend ::NewRelic::Agent::MethodTracerHelpers

  # THREAD_LOCAL_ACCESS
  def trace_execution_scoped(metric_names, options = T.unsafe(nil)); end
end

# roughly 31 years
NewRelic::Agent::MethodTracerHelpers::MAX_ALLOWED_METRIC_DURATION = T.let(T.unsafe(nil), Integer)

class NewRelic::Agent::Monitors
  # @return [Monitors] a new instance of Monitors
  def initialize(events); end

  # Returns the value of attribute cross_app_monitor.
  def cross_app_monitor; end

  # Returns the value of attribute distributed_tracing_monitor.
  def distributed_tracing_monitor; end

  # Returns the value of attribute synthetics_monitor.
  def synthetics_monitor; end
end

class NewRelic::Agent::NewRelicService
  # @return [NewRelicService] a new instance of NewRelicService
  def initialize(license_key = T.unsafe(nil), collector = T.unsafe(nil)); end

  def agent_command_results(results); end

  # Returns the value of attribute agent_id.
  def agent_id; end

  def agent_id=(id); end
  def analytic_event_data(data); end

  # The collector wants to receive metric data in a format that's different
  # from how we store it internally, so this method handles the translation.
  def build_metric_data_array(stats_hash); end

  # The path to the certificate file used to verify the SSL
  # connection if verify_peer is enabled
  def cert_file_path; end

  def close_shared_connection; end

  # Returns the value of attribute collector.
  def collector; end

  # We do not compress if content is smaller than 64kb.  There are
  # problems with bugs in Ruby in some versions that expose us
  # to a risk of segfaults if we compress aggressively.
  def compress_request_if_needed(data, endpoint); end

  def connect(settings = T.unsafe(nil)); end
  def create_and_start_http_connection; end
  def create_http_connection; end
  def custom_event_data(data); end
  def error_data(unsent_errors); end
  def error_event_data(data); end
  def establish_shared_connection; end
  def force_restart; end
  def get_agent_commands; end

  # @return [Boolean]
  def has_shared_connection?; end

  # Return a Net::HTTP connection object to make a call to the collector.
  # We'll reuse the same handle for cases where we're using keep-alive, or
  # otherwise create a new one.
  def http_connection; end

  def log_event_data(data); end

  # Returns the value of attribute marshaller.
  def marshaller; end

  def metric_data(stats_hash); end
  def preconnect; end
  def profile_data(profile); end

  # Returns the value of attribute request_timeout.
  def request_timeout; end

  # Sets the attribute request_timeout
  #
  # @param value the value to set the attribute request_timeout to.
  def request_timeout=(_arg0); end

  # One session with the service's endpoint.  In this case the session
  # represents 1 tcp connection which may transmit multiple HTTP requests
  # via keep-alive.
  #
  # @raise [ArgumentError]
  def session(&block); end

  def session_with_keepalive(&block); end
  def session_without_keepalive(&block); end
  def set_cert_store(conn); end
  def setup_connection_for_ssl(conn); end
  def setup_connection_timeouts(conn); end
  def shutdown(time); end
  def span_event_data(data); end
  def sql_trace_data(sql_traces); end
  def ssl_cert_store; end
  def start_connection(conn); end
  def transaction_sample_data(traces); end

  # @return [Boolean]
  def valid_to_marshal?(data); end

  private

  # Raises an UnrecoverableServerException if the post_string is longer
  # than the limit configured in the control object
  #
  # @raise [UnrecoverableServerException]
  def check_post_size(post_string, endpoint); end

  # A shorthand for NewRelic::Control.instance
  def control; end

  # Decompresses the response from the server, if it is gzip
  # encoded, otherwise returns it verbatim
  def decompress_response(response); end

  def generate_remote_method_uri(method); end
  def handle_serialization_error(method, e); end

  # send a message via post to the actual server. This attempts
  # to automatically compress the data via zlib if it is large
  # enough to be worth compressing, and handles any errors the
  # server may return
  def invoke_remote(method, payload = T.unsafe(nil), options = T.unsafe(nil)); end

  def license_key; end
  def log_response(response); end
  def record_endpoint_attempts_supportability_metrics(endpoint); end

  # Per protocol 17, this metric should be recorded for all error response codes
  # that cause data to be discarded.
  def record_error_response_supportability_metrics(response_code); end

  # For these metrics, we use the following fields:
  # call_count           => number of times this remote method was invoked
  # total_call_time      => total size in bytes of payloads across all invocations
  # total_exclusive_time => total size in items (e.g. unique metrics, traces, events, etc) across all invocations
  #
  # The last field doesn't make sense for all methods (e.g. get_agent_commands),
  # so we omit it for those methods that don't really take collections
  # of items as arguments.
  def record_size_supportability_metrics(method, size_bytes, item_count); end

  def record_timing_supportability_metrics(method, start_ts, serialize_finish_ts, request_send_ts, response_check_ts); end
  def remote_method_uri(method); end
  def reset_remote_method_uris; end

  # Posts to the specified server
  #
  # Options:
  #  - :uri => the path to request on the server (a misnomer of
  #              course)
  #  - :encoding => the encoding to pass to the server
  #  - :collector => a URI object that responds to the 'name' method
  #                    and returns the name of the collector to
  #                    contact
  #  - :data => the data to send as the body of the request
  def send_request(opts); end

  # Sets the user agent for connections to the server, to
  # conform with the HTTP spec and allow for debugging. Includes
  # the ruby version and also zlib version if available since
  # that may cause corrupt compression if there is a problem.
  def user_agent; end
end

# These include Errno connection errors, and all indicate that the
# underlying TCP connection may be in a bad state.
NewRelic::Agent::NewRelicService::CONNECTION_ERRORS = T.let(T.unsafe(nil), Array)

module NewRelic::Agent::NewRelicService::Encoders; end

module NewRelic::Agent::NewRelicService::Encoders::Base64CompressedJSON
  class << self
    def encode(data, opts = T.unsafe(nil)); end
  end
end

module NewRelic::Agent::NewRelicService::Encoders::Compressed; end

module NewRelic::Agent::NewRelicService::Encoders::Compressed::Deflate
  class << self
    def encode(data, opts = T.unsafe(nil)); end
  end
end

module NewRelic::Agent::NewRelicService::Encoders::Compressed::Gzip
  class << self
    def encode(data, opts = T.unsafe(nil)); end
  end
end

NewRelic::Agent::NewRelicService::Encoders::Compressed::Gzip::BINARY = T.let(T.unsafe(nil), String)

module NewRelic::Agent::NewRelicService::Encoders::Identity
  class << self
    def encode(data, opts = T.unsafe(nil)); end
  end
end

# Marshal collector protocol with JSON when available
class NewRelic::Agent::NewRelicService::JsonMarshaller < ::NewRelic::Agent::NewRelicService::Marshaller
  # @return [JsonMarshaller] a new instance of JsonMarshaller
  def initialize; end

  def default_encoder; end
  def dump(ruby, opts = T.unsafe(nil)); end
  def format; end
  def load(data); end
  def warn_for_yajl; end

  class << self
    # @return [Boolean]
    def human_readable?; end
  end
end

NewRelic::Agent::NewRelicService::JsonMarshaller::OK_YAJL_VERSION = T.let(T.unsafe(nil), Gem::Version)

class NewRelic::Agent::NewRelicService::Marshaller
  def default_encoder; end
  def prepare(data, options = T.unsafe(nil)); end

  protected

  def return_value(data); end

  class << self
    # @return [Boolean]
    def human_readable?; end
  end
end

# Specifies the version of the agent's communication protocol with
# the NewRelic hosted site.
NewRelic::Agent::NewRelicService::PROTOCOL_VERSION = T.let(T.unsafe(nil), Integer)

module NewRelic::Agent::NewRelicService::SecurityPolicySettings
  class << self
    def preliminary_settings(security_policies); end
  end
end

NewRelic::Agent::NewRelicService::SecurityPolicySettings::EXPECTED_SECURITY_POLICIES = T.let(T.unsafe(nil), Array)

class NewRelic::Agent::NewRelicService::SecurityPolicySettings::Validator
  # @return [Validator] a new instance of Validator
  def initialize(preconnect_response); end

  def validate_matching_agent_config!; end
end

# This class is used for instrumentations that have exceptions or error classes
# not derived from Ruby's usual Exception or StandardError or in situations
# where we do not have such Exception object to work with.
class NewRelic::Agent::NoticibleError
  # @return [NoticibleError] a new instance of NoticibleError
  def initialize(class_name, message); end

  # Returns the value of attribute class_name.
  def class_name; end

  # Returns the value of attribute message.
  def message; end
end

class NewRelic::Agent::NullLogger
  def debug(*args); end
  def error(*args); end
  def fatal(*args); end
  def info(*args); end
  def method_missing(method, *args, &blk); end
  def warn(*args); end
end

class NewRelic::Agent::Obfuscator
  # RUM uses a shortened key, so just trim it up front
  #
  # @return [Obfuscator] a new instance of Obfuscator
  def initialize(key, length = T.unsafe(nil)); end

  def deobfuscate(text); end
  def encode(text); end

  # Returns the value of attribute key_bytes.
  def key_bytes; end

  def obfuscate(text); end
end

NewRelic::Agent::Obfuscator::EMPTY_KEY_BYTES = T.let(T.unsafe(nil), Array)
NewRelic::Agent::Obfuscator::PACK_FORMAT = T.let(T.unsafe(nil), String)

module NewRelic::Agent::PayloadMetricMapping
  class << self
    def append_mapped_metrics(txn_metrics, sample); end

    private

    def map_metric(metric_name, to_add = T.unsafe(nil)); end
  end
end

# this logic was extracted from TransactionEventAggregator for reuse by
# the ErrorEventAggregator
NewRelic::Agent::PayloadMetricMapping::SPEC_MAPPINGS = T.let(T.unsafe(nil), Hash)

# --
# Manages the registering and servicing of pipes used by child
# processes to report data to their parent, rather than directly
# to the collector.
module NewRelic::Agent::PipeChannelManager
  extend ::NewRelic::Agent::PipeChannelManager

  def channels; end
  def listener; end
  def register_report_channel(id); end
end

class NewRelic::Agent::PipeChannelManager::Listener
  # @return [Listener] a new instance of Listener
  def initialize; end

  def close_all_pipes; end

  # This attr_accessor intentionally provides unsynchronized access to the
  # within the Resque child process, and must be unsynchronized in order
  # to avoid a potential deadlock in which the PipeChannelManager::Listener
  # thread in the parent process is holding the @pipes_lock at the time of
  # the fork.
  def pipes; end

  # This attr_accessor intentionally provides unsynchronized access to the
  # within the Resque child process, and must be unsynchronized in order
  # to avoid a potential deadlock in which the PipeChannelManager::Listener
  # thread in the parent process is holding the @pipes_lock at the time of
  # the fork.
  def pipes=(_arg0); end

  def register_pipe(id); end

  # This attr_accessor intentionally provides unsynchronized access to the
  # within the Resque child process, and must be unsynchronized in order
  # to avoid a potential deadlock in which the PipeChannelManager::Listener
  # thread in the parent process is holding the @pipes_lock at the time of
  # the fork.
  def select_timeout; end

  # This attr_accessor intentionally provides unsynchronized access to the
  # within the Resque child process, and must be unsynchronized in order
  # to avoid a potential deadlock in which the PipeChannelManager::Listener
  # thread in the parent process is holding the @pipes_lock at the time of
  # the fork.
  def select_timeout=(_arg0); end

  def start; end

  # @return [Boolean]
  def started?; end

  def stop; end
  def stop_listener_thread; end

  # Returns the value of attribute thread.
  def thread; end

  # This attr_accessor intentionally provides unsynchronized access to the
  # within the Resque child process, and must be unsynchronized in order
  # to avoid a potential deadlock in which the PipeChannelManager::Listener
  # thread in the parent process is holding the @pipes_lock at the time of
  # the fork.
  def timeout; end

  # This attr_accessor intentionally provides unsynchronized access to the
  # within the Resque child process, and must be unsynchronized in order
  # to avoid a potential deadlock in which the PipeChannelManager::Listener
  # thread in the parent process is holding the @pipes_lock at the time of
  # the fork.
  def timeout=(_arg0); end

  def wake; end
  def wakeup; end

  protected

  def clean_up_pipes; end
  def find_pipe_for_handle(out_handle); end
  def merge_data_from_pipe(pipe_handle); end

  # @return [Boolean]
  def should_keep_listening?; end

  def unmarshal(data); end
end

# Expected initial sequence of events for Pipe usage:
#
# 1. Pipe is created in parent process (read and write ends open)
# 2. Parent process forks
# 3. An after_fork hook is invoked in the child
# 4. From after_fork hook, child closes read end of pipe, and
#    writes a ready marker on the pipe (after_fork_in_child).
# 5. The parent receives the ready marker, and closes the write end of the
#    pipe in response (after_fork_in_parent).
#
# After this sequence of steps, an exit (whether clean or not) of the
# child will result in the pipe being marked readable again, and giving an
# EOF marker (nil) when read. Note that closing of the unused ends of the
# pipe in the parent and child processes is essential in order for the EOF
# to be correctly triggered. The ready marker mechanism is used because
# there's no easy hook for after_fork in the parent process.
#
# This class provides message framing (separation of individual messages),
# but not serialization. Serialization / deserialization is the
# responsibility of clients.
#
# Message framing works like this:
#
# Each message sent across the pipe is preceded by a length tag that
# specifies the length of the message that immediately follows, in bytes.
# The length tags are serialized as unsigned big-endian long values, (4
# bytes each). This means that the maximum theoretical message size is
# 4 GB - much larger than we'd ever need or want for this application.
class NewRelic::Agent::PipeChannelManager::Pipe
  # @return [Pipe] a new instance of Pipe
  def initialize; end

  def after_fork_in_child; end
  def after_fork_in_parent; end
  def close; end

  # @return [Boolean]
  def closed?; end

  def deserialize_message_length(data); end

  # @return [Boolean]
  def eof?; end

  # Returns the value of attribute in.
  def in; end

  # Sets the attribute in
  #
  # @param value the value to set the attribute in to.
  def in=(_arg0); end

  # Returns the value of attribute last_read.
  def last_read; end

  # Returns the value of attribute out.
  def out; end

  # Sets the attribute out
  #
  # @param value the value to set the attribute out to.
  def out=(_arg0); end

  # Returns the value of attribute parent_pid.
  def parent_pid; end

  def read; end
  def serialize_message_length(data); end
  def write(data); end
end

NewRelic::Agent::PipeChannelManager::Pipe::NUM_LENGTH_BYTES = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::PipeChannelManager::Pipe::READY_MARKER = T.let(T.unsafe(nil), String)

class NewRelic::Agent::PipeService
  # @return [PipeService] a new instance of PipeService
  def initialize(channel_id); end

  # Returns the value of attribute agent_id.
  def agent_id; end

  # Sets the attribute agent_id
  #
  # @param value the value to set the attribute agent_id to.
  def agent_id=(_arg0); end

  def analytic_event_data(events); end

  # Returns the value of attribute buffer.
  def buffer; end

  # Returns the value of attribute channel_id.
  def channel_id; end

  # Returns the value of attribute collector.
  def collector; end

  # Sets the attribute collector
  #
  # @param value the value to set the attribute collector to.
  def collector=(_arg0); end

  def connect(config); end
  def custom_event_data(events); end
  def error_data(errors); end
  def error_event_data(events); end
  def get_agent_commands; end
  def log_event_data(logs); end
  def metric_data(unsent_timeslice_data); end

  # Returns the value of attribute pipe.
  def pipe; end

  # Returns the value of attribute request_timeout.
  def request_timeout; end

  # Sets the attribute request_timeout
  #
  # @param value the value to set the attribute request_timeout to.
  def request_timeout=(_arg0); end

  # Invokes the block it is passed.  This is used to implement HTTP
  # keep-alive in the NewRelicService, and is a required interface for any
  # Service class.
  def session; end

  def shutdown; end
  def span_event_data(events); end
  def sql_trace_data(sql); end
  def transaction_sample_data(transactions); end

  private

  def marshal_payload(data); end
  def write_to_pipe(endpoint, data); end
end

class NewRelic::Agent::PrioritySampledBuffer < ::NewRelic::Agent::EventBuffer
  # @return [PrioritySampledBuffer] a new instance of PrioritySampledBuffer
  def initialize(capacity); end

  # expects priority and a block, or an event as a hash with a `priority` key.
  def append(priority: T.unsafe(nil), event: T.unsafe(nil), &blk); end

  # expects priority and a block, or an event as a hash with a `priority` key.
  def append_event(priority: T.unsafe(nil), event: T.unsafe(nil), &blk); end

  def capacity=(new_capacity); end

  # Returns the value of attribute captured_lifetime.
  def captured_lifetime; end

  def decrement_lifetime_counts_by(n); end
  def heapify_items_array; end
  def metadata; end
  def sample_rate_lifetime; end

  # Returns the value of attribute seen_lifetime.
  def seen_lifetime; end

  def to_a; end

  private

  def increment_seen; end
  def priority_for(event); end
end

NewRelic::Agent::PrioritySampledBuffer::PRIORITY_KEY = T.let(T.unsafe(nil), String)

module NewRelic::Agent::RangeExtensions
  private

  # Computes the amount of overlap between range and an array of ranges.
  # For efficiency, it assumes that range intersects with each of the
  # ranges in the ranges array.
  def compute_overlap(range, ranges); end

  def intersects?(r1, r2); end
  def merge(r1, r2); end

  # Takes an array of ranges and a range which it will
  # merge into an existing range if they intersect, otherwise
  # it will append this range to the end the array.
  def merge_or_append(range, ranges); end

  class << self
    # Computes the amount of overlap between range and an array of ranges.
    # For efficiency, it assumes that range intersects with each of the
    # ranges in the ranges array.
    def compute_overlap(range, ranges); end

    # @return [Boolean]
    def intersects?(r1, r2); end

    def merge(r1, r2); end

    # Takes an array of ranges and a range which it will
    # merge into an existing range if they intersect, otherwise
    # it will append this range to the end the array.
    def merge_or_append(range, ranges); end
  end
end

class NewRelic::Agent::RulesEngine
  include ::Enumerable
  extend ::Forwardable

  # @return [RulesEngine] a new instance of RulesEngine
  def initialize(rules = T.unsafe(nil), segment_term_rules = T.unsafe(nil)); end

  def apply_rules(rules, string); end
  def clear(*args, **_arg1, &block); end
  def each(*args, **_arg1, &block); end
  def inspect(*args, **_arg1, &block); end
  def rename(original_string); end
  def size(*args, **_arg1, &block); end

  class << self
    def create_metric_rules(connect_response); end
    def create_transaction_rules(connect_response); end

    # When multiple rules share the same prefix,
    # only apply the rule with the last instance of the prefix.
    # Note that the incoming rules are in reverse order to facilitate this.
    def reject_rules_with_duplicate_prefixes!(rules); end
  end
end

NewRelic::Agent::RulesEngine::LEADING_SLASH_REGEX = T.let(T.unsafe(nil), Regexp)

class NewRelic::Agent::RulesEngine::ReplacementRule
  # @return [ReplacementRule] a new instance of ReplacementRule
  def initialize(options); end

  def <=>(other); end
  def apply(string); end
  def apply_replacement(string); end
  def apply_to_each_segment(string); end

  # Returns the value of attribute each_segment.
  def each_segment; end

  # Returns the value of attribute eval_order.
  def eval_order; end

  # Returns the value of attribute ignore.
  def ignore; end

  # Returns the value of attribute match_expression.
  def match_expression; end

  # @return [Boolean]
  def matches?(string); end

  # Returns the value of attribute replace_all.
  def replace_all; end

  # Returns the value of attribute replacement.
  def replacement; end

  # @return [Boolean]
  def terminal?; end

  # Returns the value of attribute terminate_chain.
  def terminate_chain; end
end

NewRelic::Agent::RulesEngine::SEGMENT_SEPARATOR = T.let(T.unsafe(nil), String)

class NewRelic::Agent::RulesEngine::SegmentTermsRule
  # @return [SegmentTermsRule] a new instance of SegmentTermsRule
  def initialize(options); end

  def apply(string); end
  def collapse_adjacent_placeholder_segments(segments); end

  # @return [Boolean]
  def matches?(string); end

  # Returns the value of attribute prefix.
  def prefix; end

  # @return [Boolean]
  def prefix_matches_on_segment_boundary?(string); end

  # @return [Boolean]
  def terminal?; end

  # Returns the value of attribute terms.
  def terms; end

  class << self
    # @return [Boolean]
    def valid?(rule_spec); end

    # @return [Boolean]
    def valid_prefix_segment_count?(prefix); end
  end
end

NewRelic::Agent::RulesEngine::SegmentTermsRule::ADJACENT_PLACEHOLDERS_REGEX = T.let(T.unsafe(nil), Regexp)
NewRelic::Agent::RulesEngine::SegmentTermsRule::ADJACENT_PLACEHOLDERS_REPLACEMENT = T.let(T.unsafe(nil), String)
NewRelic::Agent::RulesEngine::SegmentTermsRule::PREFIX_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::RulesEngine::SegmentTermsRule::SEGMENT_PLACEHOLDER = T.let(T.unsafe(nil), String)
NewRelic::Agent::RulesEngine::SegmentTermsRule::TERMS_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::RulesEngine::SegmentTermsRule::VALID_PREFIX_SEGMENT_COUNT = T.let(T.unsafe(nil), Integer)

# @api public
NewRelic::Agent::SPAN_ID_KEY = T.let(T.unsafe(nil), String)

# Increment a simple counter metric.
#
# +metric_name+ should follow a slash separated path convention. Application
# specific metrics should begin with "Custom/".
#
# This method is safe to use from any thread.
#
# @api public
NewRelic::Agent::SUPPORTABILITY_INCREMENT_METRIC = T.let(T.unsafe(nil), String)

class NewRelic::Agent::Sampler
  # The ID passed in here is unused by our code, but is preserved in case
  # we have clients who are defining their own subclasses of this class, and
  # expecting to be able to call super with an ID.
  #
  # @return [Sampler] a new instance of Sampler
  def initialize(id = T.unsafe(nil)); end

  # Returns the value of attribute id.
  def id; end

  def poll; end

  class << self
    # @return [Boolean]
    def enabled?; end

    # @private
    def inherited(subclass); end

    def named(new_name); end
    def sampler_classes; end

    # Returns the value of attribute shorthand_name.
    def shorthand_name; end

    # Override with check.  Called before instantiating.
    #
    # @return [Boolean]
    def supported_on_this_platform?; end
  end
end

# Exception denotes a sampler is not available and it will not be registered.
class NewRelic::Agent::Sampler::Unsupported < ::StandardError; end

class NewRelic::Agent::SamplerCollection
  include ::Enumerable

  # @return [SamplerCollection] a new instance of SamplerCollection
  def initialize(event_listener); end

  def add_sampler(sampler_class); end
  def clear; end
  def each(&blk); end

  # adds samplers to the sampler collection so that they run every
  # minute. This is dynamically recognized by any class that
  # subclasses NewRelic::Agent::Sampler
  def load_samplers; end

  def poll_samplers; end

  # @return [Boolean]
  def sampler_class_registered?(sampler_class); end
end

module NewRelic::Agent::Samplers; end

class NewRelic::Agent::Samplers::CpuSampler < ::NewRelic::Agent::Sampler
  # @return [CpuSampler] a new instance of CpuSampler
  def initialize; end

  # Returns the value of attribute last_time.
  def last_time; end

  def poll; end
  def record_system_util(value); end
  def record_systemtime(value); end
  def record_user_util(value); end
  def record_usertime(value); end

  class << self
    # @return [Boolean]
    def supported_on_this_platform?; end
  end
end

# This sampler records the status of your delayed job table once a minute.
# It assumes jobs are cleared after being run, and failed jobs are not (otherwise
# the failed job metric is useless).
#
# In earlier versions it will break out the queue length by priority.  In later
# versions of DJ where distinct queues are supported, it breaks it out by queue name.
class NewRelic::Agent::Samplers::DelayedJobSampler < ::NewRelic::Agent::Sampler
  # @raise [Unsupported]
  # @return [DelayedJobSampler] a new instance of DelayedJobSampler
  def initialize; end

  def count(query); end
  def failed_jobs; end
  def locked_jobs; end
  def poll; end
  def record_failed_jobs(value); end
  def record_locked_jobs(value); end

  private

  def queue_counts(column_name); end
  def record_counts_by(column_name, metric_node = T.unsafe(nil)); end
  def record_queue_length_metrics; end

  class << self
    # DelayedJob supports multiple backends, only some of which we can
    # handle. Check whether we think we've got what we need here.
    #
    # @return [Boolean]
    def supported_backend?; end

    # @return [Boolean]
    def supported_on_this_platform?; end
  end
end

NewRelic::Agent::Samplers::DelayedJobSampler::FAILED_QUERY = T.let(T.unsafe(nil), String)
NewRelic::Agent::Samplers::DelayedJobSampler::LOCKED_QUERY = T.let(T.unsafe(nil), String)
NewRelic::Agent::Samplers::DelayedJobSampler::QUEUE_QUERY_CONDITION = T.let(T.unsafe(nil), String)

class NewRelic::Agent::Samplers::MemorySampler < ::NewRelic::Agent::Sampler
  # @raise [Unsupported]
  # @return [MemorySampler] a new instance of MemorySampler
  def initialize; end

  def platform; end
  def poll; end

  # Returns the value of attribute sampler.
  def sampler; end

  # Sets the attribute sampler
  #
  # @param value the value to set the attribute sampler to.
  def sampler=(_arg0); end

  class << self
    def platform; end

    # @return [Boolean]
    def supported_on_this_platform?; end
  end
end

class NewRelic::Agent::Samplers::MemorySampler::Base
  # @return [Base] a new instance of Base
  def initialize; end

  # @return [Boolean]
  def can_run?; end

  def get_sample; end
end

class NewRelic::Agent::Samplers::MemorySampler::JavaHeapSampler < ::NewRelic::Agent::Samplers::MemorySampler::Base
  def get_memory; end
  def to_s; end
end

# ProcStatus
#
# A class that samples memory by reading the file /proc/$$/status, which is specific to linux
class NewRelic::Agent::Samplers::MemorySampler::ProcStatus < ::NewRelic::Agent::Samplers::MemorySampler::Base
  # Returns the amount of resident memory this process is using in MB
  def get_memory; end

  def proc_status_file; end
  def to_s; end
end

class NewRelic::Agent::Samplers::MemorySampler::ShellPS < ::NewRelic::Agent::Samplers::MemorySampler::Base
  # @return [ShellPS] a new instance of ShellPS
  def initialize(command); end

  # Returns the amount of resident memory this process is using in MB
  def get_memory; end

  def to_s; end
end

class NewRelic::Agent::Samplers::ObjectSampler < ::NewRelic::Agent::Sampler
  def poll; end

  class << self
    # @return [Boolean]
    def supported_on_this_platform?; end
  end
end

class NewRelic::Agent::Samplers::VMSampler < ::NewRelic::Agent::Sampler
  # @return [VMSampler] a new instance of VMSampler
  def initialize; end

  def on_transaction_finished(*_); end
  def poll; end

  # THREAD_LOCAL_ACCESS
  def record_delta(snapshot, key, metric, txn_count); end

  # THREAD_LOCAL_ACCESS
  def record_gauge_metric(metric_name, value); end

  # THREAD_LOCAL_ACCESS
  def record_gc_runs_metric(snapshot, txn_count); end

  def record_heap_free_metric(snapshot); end
  def record_heap_live_metric(snapshot); end
  def record_thread_count_metric(snapshot); end
  def reset_transaction_count; end
  def setup_events(event_listener); end
  def take_snapshot; end

  # Returns the value of attribute transaction_count.
  def transaction_count; end
end

NewRelic::Agent::Samplers::VMSampler::CONSTANT_INVALIDATIONS_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Samplers::VMSampler::GC_RUNS_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Samplers::VMSampler::HEAP_FREE_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Samplers::VMSampler::HEAP_LIVE_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Samplers::VMSampler::MAJOR_GC_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Samplers::VMSampler::METHOD_INVALIDATIONS_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Samplers::VMSampler::MINOR_GC_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Samplers::VMSampler::OBJECT_ALLOCATIONS_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Samplers::VMSampler::THREAD_COUNT_METRIC = T.let(T.unsafe(nil), String)

# An error while serializing data for the collector
#
# @api public
class NewRelic::Agent::SerializationError < ::StandardError; end

# Used to blow out of a periodic task without logging a an error, such as for routine
# failures.
#
# @api public
class NewRelic::Agent::ServerConnectionException < ::StandardError; end

class NewRelic::Agent::SlowSql
  # @return [SlowSql] a new instance of SlowSql
  def initialize(statement, metric_name, duration, backtrace = T.unsafe(nil), params = T.unsafe(nil)); end

  # Returns the value of attribute backtrace.
  def backtrace; end

  def base_params; end

  # Returns the value of attribute duration.
  def duration; end

  def explain; end

  # Returns the value of attribute metric_name.
  def metric_name; end

  def normalize; end
  def obfuscate; end

  # We can't serialize the explainer, so clear it before we transmit
  def prepare_to_send; end

  def sql; end

  # Returns the value of attribute statement.
  def statement; end
end

class NewRelic::Agent::SpanEventAggregator < ::NewRelic::Agent::EventAggregator
  def after_harvest(metadata); end
  def record(priority: T.unsafe(nil), event: T.unsafe(nil), &blk); end
end

NewRelic::Agent::SpanEventAggregator::SUPPORTABILITY_DISCARDED = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventAggregator::SUPPORTABILITY_TOTAL_SEEN = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventAggregator::SUPPORTABILITY_TOTAL_SENT = T.let(T.unsafe(nil), String)

module NewRelic::Agent::SpanEventPrimitive
  include ::NewRelic::Coerce
  extend ::NewRelic::Coerce
  extend ::NewRelic::Agent::SpanEventPrimitive

  # Builds a Hash of error attributes as well as the Span ID when
  # an error is present.  Otherwise, returns nil when no error present.
  def error_attributes(segment); end

  def for_datastore_segment(segment); end
  def for_external_request_segment(segment); end
  def for_segment(segment); end

  private

  def agent_attributes(segment); end

  # @return [Boolean]
  def allowed?(key); end

  def custom_attributes(segment); end
  def intrinsics_for(segment); end
  def merge_and_freeze_attributes(agent_attributes, error_attributes); end
  def milliseconds_since_epoch(segment); end
  def parent_guid(segment); end
  def truncate(value, max_size = T.unsafe(nil)); end
end

NewRelic::Agent::SpanEventPrimitive::CATEGORY_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::CLIENT = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::COMPONENT_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::DATASTORE_CATEGORY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::DB_INSTANCE_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::DB_STATEMENT_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::DURATION_KEY = T.let(T.unsafe(nil), String)

# Strings for static keys of the event structure
NewRelic::Agent::SpanEventPrimitive::ELLIPSIS = T.let(T.unsafe(nil), String)

NewRelic::Agent::SpanEventPrimitive::ENTRY_POINT_KEY = T.let(T.unsafe(nil), String)

# Strings for static values of the event structure
NewRelic::Agent::SpanEventPrimitive::EVENT_TYPE = T.let(T.unsafe(nil), String)

NewRelic::Agent::SpanEventPrimitive::GENERIC_CATEGORY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::GRANDPARENT_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::GUID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::HTTP_CATEGORY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::HTTP_METHOD_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::HTTP_STATUS_CODE_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::HTTP_URL_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::NAME_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::PARENT_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::PEER_ADDRESS_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::PEER_HOSTNAME_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::PRIORITY_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::SAMPLED_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::SPAN_KIND_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::TIMESTAMP_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::TRACE_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::TRACING_VENDORS_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::TRANSACTION_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::TRANSACTION_NAME_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::TRUSTED_PARENT_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::TYPE_KEY = T.let(T.unsafe(nil), String)

# This class contains the logic of recording slow SQL traces, which may
# represent multiple aggregated SQL queries.
#
# A slow SQL trace consists of a collection of SQL instrumented SQL queries
# that all normalize to the same text. For example, the following two
# queries would be aggregated together into a single slow SQL trace:
#
#   SELECT * FROM table WHERE id=42
#   SELECT * FROM table WHERE id=1234
#
# Each slow SQL trace keeps track of the number of times the same normalized
# query was seen, the min, max, and total time spent executing those
# queries, and an example backtrace from one of the aggregated queries.
#
# @api public
class NewRelic::Agent::SqlSampler
  # @api public
  # @return [SqlSampler] a new instance of SqlSampler
  def initialize; end

  # @api public
  def disabled; end

  # @api public
  def distributed_trace_attributes(state); end

  # @api public
  # @return [Boolean]
  def enabled?; end

  # @api public
  def harvest!; end

  # this should always be called under the @samples_lock
  #
  # @api public
  # @return [Boolean]
  def has_room?; end

  # @api public
  def merge!(sql_traces); end

  # Records an SQL query, potentially creating a new slow SQL trace, or
  # aggregating the query into an existing slow SQL trace.
  #
  # This method should be used only by gem authors wishing to extend
  # the Ruby agent to instrument new database interfaces - it should
  # generally not be called directly from application code.
  #
  # @api public
  # @deprecated Use {Datastores.notice_sql} instead.
  # @param sql [String] the SQL query being recorded
  # @param metric_name [String] is the metric name under which this query will be recorded
  # @param config [Object] is the driver configuration for the connection
  # @param duration [Float] number of seconds the query took to execute
  # @param explainer [Proc] for internal use only - 3rd-party clients must
  #   not pass this parameter.
  def notice_sql(sql, metric_name, config, duration, state = T.unsafe(nil), explainer = T.unsafe(nil), binds = T.unsafe(nil), name = T.unsafe(nil)); end

  # @api public
  def notice_sql_statement(statement, metric_name, duration); end

  # This is called when we are done with the transaction.
  #
  # @api public
  def on_finishing_transaction(state, name); end

  # @api public
  def on_start_transaction(state, uri = T.unsafe(nil)); end

  # this should always be called under the @samples_lock
  #
  # @api public
  def remove_shortest_trace; end

  # @api public
  def reset!; end

  # this should always be called under the @samples_lock
  #
  # @api public
  def save_slow_sql(transaction_sql_data); end

  # this should always be called under the @samples_lock
  #
  # @api public
  # @return [Boolean]
  def should_add_trace?(sql_item); end

  # this is for unit tests only
  #
  # @api public
  def sql_traces; end

  # only used for testing
  #
  # @api public
  def tl_transaction_data; end
end

# @api public
NewRelic::Agent::SqlSampler::MAX_SAMPLES = T.let(T.unsafe(nil), Integer)

# @api public
NewRelic::Agent::SqlSampler::PRIORITY = T.let(T.unsafe(nil), String)

class NewRelic::Agent::SqlTrace < ::NewRelic::Agent::Stats
  include ::NewRelic::Coerce

  # @return [SqlTrace] a new instance of SqlTrace
  def initialize(normalized_query, slow_sql, path, uri); end

  def aggregate(slow_sql, path, uri); end
  def aggregate_trace(trace); end

  # Returns the value of attribute database_metric_name.
  def database_metric_name; end

  # @return [Boolean]
  def need_to_explain?; end

  # @return [Boolean]
  def need_to_obfuscate?; end

  # Returns the value of attribute params.
  def params; end

  # Returns the value of attribute path.
  def path; end

  def prepare_to_send; end
  def set_primary(slow_sql, path, uri); end

  # Returns the value of attribute slow_sql.
  def slow_sql; end

  # Returns the value of attribute sql.
  def sql; end

  # Returns the value of attribute sql_id.
  def sql_id; end

  def to_collector_array(encoder); end

  # Returns the value of attribute url.
  def url; end

  private

  # need to hash the same way in every process, to be able to aggregate slow SQL traces
  def consistent_hash(string); end
end

# In an effort to not lose messages during startup, we trap them in memory
# The real logger will then dump its contents out when it arrives.
class NewRelic::Agent::StartupLogger < ::NewRelic::Agent::MemoryLogger
  include ::Singleton
  extend ::Singleton::SingletonClassMethods
end

class NewRelic::Agent::Stats
  # @return [Stats] a new instance of Stats
  def initialize; end

  def ==(other); end

  # Returns the value of attribute total_exclusive_time.
  def apdex_f; end

  # Returns the value of attribute call_count.
  # Apdex-related accessors
  def apdex_s; end

  # Returns the value of attribute total_call_time.
  def apdex_t; end

  # Returns the value of attribute call_count.
  def call_count; end

  # Sets the attribute call_count
  #
  # @param value the value to set the attribute call_count to.
  def call_count=(_arg0); end

  # increments the call_count by one
  def increment_count(value = T.unsafe(nil)); end

  # Concerned about implicit usage of inspect relying on stats format, so
  # putting back a version to get full inspection as separate method
  def inspect_full; end

  # @return [Boolean]
  def is_reset?; end

  # Returns the value of attribute max_call_time.
  def max_call_time; end

  # Sets the attribute max_call_time
  #
  # @param value the value to set the attribute max_call_time to.
  def max_call_time=(_arg0); end

  def merge(other_stats); end
  def merge!(other); end

  # Returns the value of attribute min_call_time.
  def min_call_time; end

  # Sets the attribute min_call_time
  #
  # @param value the value to set the attribute min_call_time to.
  def min_call_time=(_arg0); end

  def record(value = T.unsafe(nil), aux = T.unsafe(nil), &blk); end
  def record_apdex(bucket, apdex_t); end

  # record a single data point into the statistical gatherer.  The gatherer
  # will aggregate all data points collected over a specified period and upload
  # its data to the NewRelic server
  def record_data_point(value, exclusive_time = T.unsafe(nil)); end

  def reset; end

  # Returns the value of attribute sum_of_squares.
  def sum_of_squares; end

  # Sets the attribute sum_of_squares
  #
  # @param value the value to set the attribute sum_of_squares to.
  def sum_of_squares=(_arg0); end

  def to_json(*_); end
  def to_s; end

  # Returns the value of attribute total_call_time.
  def total_call_time; end

  # Sets the attribute total_call_time
  #
  # @param value the value to set the attribute total_call_time to.
  def total_call_time=(_arg0); end

  # Returns the value of attribute total_exclusive_time.
  def total_exclusive_time; end

  # Sets the attribute total_exclusive_time
  #
  # @param value the value to set the attribute total_exclusive_time to.
  def total_exclusive_time=(_arg0); end

  # record a single data point into the statistical gatherer.  The gatherer
  # will aggregate all data points collected over a specified period and upload
  # its data to the NewRelic server
  def trace_call(value, exclusive_time = T.unsafe(nil)); end

  protected

  # @return [Boolean]
  def min_time_less?(other); end
end

# This class handles all the statistics gathering for the agent
class NewRelic::Agent::StatsEngine
  # @return [StatsEngine] a new instance of StatsEngine
  def initialize; end

  def apply_rules_to_metric_data(rules_engine, stats_hash); end

  # For use by test code only.
  def clear_stats; end

  def coerce_to_metric_spec_array(metric_names_or_specs, scope); end
  def harvest!; end

  # merge data from previous harvests into this stats engine
  def merge!(other_stats_hash); end

  def merge_transaction_metrics!(txn_metrics, scope); end

  # Returns the value of attribute metric_rules.
  def metric_rules; end

  # Sets the attribute metric_rules
  #
  # @param value the value to set the attribute metric_rules to.
  def metric_rules=(_arg0); end

  def record_scoped_and_unscoped_metrics(state, scoped_metric, summary_metrics = T.unsafe(nil), value = T.unsafe(nil), aux = T.unsafe(nil), &blk); end
  def record_unscoped_metrics(state, metric_names, value = T.unsafe(nil), aux = T.unsafe(nil), &blk); end
  def reset!; end

  # Like tl_record_unscoped_metrics, but records a scoped metric as well.
  #
  # This is an internal method, subject to change at any time. Client apps
  # and gems should use the public API (NewRelic::Agent.record_metric)
  # instead.
  #
  # The given scoped_metric will be recoded as both a scoped *and* an
  # unscoped metric. The summary_metrics will be recorded as unscoped
  # metrics only.
  #
  # If called during a transaction, all metrics will be attached to the
  # Transaction, and not merged into the global set of metrics until the
  # end of the transaction.
  #
  # If called outside of a transaction, only the *unscoped* metrics will
  # be recorded, directly into the global set of metrics (under a lock).
  #
  # @api private
  def tl_record_scoped_and_unscoped_metrics(scoped_metric, summary_metrics = T.unsafe(nil), value = T.unsafe(nil), aux = T.unsafe(nil), &blk); end

  # Helper for recording a straight value into the count
  def tl_record_supportability_metric_count(metric, value); end

  # Update the unscoped metrics given in metric_names.
  # metric_names may be either a single name, or an array of names.
  #
  # This is an internal method, subject to change at any time. Client apps
  # and gems should use the public API (NewRelic::Agent.record_metric)
  # instead.
  #
  # There are four ways to use this method:
  #
  # 1. With a numeric value, it will update the Stats objects associated
  #    with the given metrics by calling record_data_point(value, aux).
  #    aux will be treated in this case as the exclusive time associated
  #    with the call being recorded.
  #
  # 2. With a value of :apdex_s, :apdex_t, or :apdex_f, it will treat the
  #    associated stats as an Apdex metric, updating it to reflect the
  #    occurrence of a transaction falling into the given category.
  #    The aux value in this case should be the apdex threshold used in
  #    bucketing the request.
  #
  # 3. If a block is given, value and aux will be ignored, and instead the
  #    Stats object associated with each named unscoped metric will be
  #    yielded to the block for customized update logic.
  #
  # 4. If value is a Stats instance, it will be merged into the Stats
  #    associated with each named unscoped metric.
  #
  # If this method is called during a transaction, the metrics will be
  # attached to the Transaction, and not merged into the global set until
  # the end of the transaction.
  #
  # Otherwise, the metrics will be recorded directly into the global set
  # of metrics, under a lock.
  #
  # @api private
  def tl_record_unscoped_metrics(metric_names, value = T.unsafe(nil), aux = T.unsafe(nil), &blk); end

  # For use by test code only.
  def to_h; end

  # All access to the @stats_hash ivar should be funnelled through this
  # method to ensure thread-safety.
  def with_stats_lock; end
end

module NewRelic::Agent::StatsEngine::GCProfiler
  class << self
    def gc_metric_name; end
    def init; end
    def record_delta(start_snapshot, end_snapshot); end

    # THREAD_LOCAL_ACCESS
    def record_gc_metric(call_count, elapsed); end

    def reset; end
    def take_snapshot; end
  end
end

class NewRelic::Agent::StatsEngine::GCProfiler::CoreGCProfiler
  def call_count; end
  def call_time_s; end

  # When using GC::Profiler, it's important to periodically call
  # GC::Profiler.clear in order to avoid unbounded growth in the number
  # of GC records that are stored. However, we actually do this
  # internally within MonotonicGCProfiler on calls to #total_time_s,
  # so the reset here is a no-op.
  def reset; end

  class << self
    # @return [Boolean]
    def enabled?; end
  end
end

class NewRelic::Agent::StatsEngine::GCProfiler::GCSnapshot < ::Struct
  # Returns the value of attribute gc_call_count
  #
  # @return [Object] the current value of gc_call_count
  def gc_call_count; end

  # Sets the attribute gc_call_count
  #
  # @param value [Object] the value to set the attribute gc_call_count to.
  # @return [Object] the newly set value
  def gc_call_count=(_); end

  # Returns the value of attribute gc_time_s
  #
  # @return [Object] the current value of gc_time_s
  def gc_time_s; end

  # Sets the attribute gc_time_s
  #
  # @param value [Object] the value to set the attribute gc_time_s to.
  # @return [Object] the newly set value
  def gc_time_s=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

NewRelic::Agent::StatsEngine::GCProfiler::GC_OTHER = T.let(T.unsafe(nil), String)
NewRelic::Agent::StatsEngine::GCProfiler::GC_ROLLUP = T.let(T.unsafe(nil), String)
NewRelic::Agent::StatsEngine::GCProfiler::GC_WEB = T.let(T.unsafe(nil), String)

class NewRelic::Agent::StatsEngine::GCProfiler::RailsBenchProfiler
  def call_count; end
  def call_time_s; end
  def reset; end

  class << self
    # @return [Boolean]
    def enabled?; end
  end
end

class NewRelic::Agent::StatsHash
  # @return [StatsHash] a new instance of StatsHash
  def initialize(started_at = T.unsafe(nil)); end

  def ==(other); end
  def [](key); end
  def each; end

  # @return [Boolean]
  def empty?; end

  def handle_stats_lookup_error(key, hash, error); end

  # Returns the value of attribute harvested_at.
  def harvested_at; end

  # Sets the attribute harvested_at
  #
  # @param value the value to set the attribute harvested_at to.
  def harvested_at=(_arg0); end

  def marshal_dump; end
  def marshal_load(data); end
  def merge!(other); end
  def merge_or_insert(target, name, stats); end
  def merge_transaction_metrics!(txn_metrics, scope); end
  def record(metric_specs, value = T.unsafe(nil), aux = T.unsafe(nil), &blk); end
  def size; end

  # Returns the value of attribute started_at.
  def started_at; end

  # Sets the attribute started_at
  #
  # @param value the value to set the attribute started_at to.
  def started_at=(_arg0); end

  def to_h; end
end

class NewRelic::Agent::StatsHash::StatsHashLookupError < ::NewRelic::Agent::InternalAgentError
  # @return [StatsHashLookupError] a new instance of StatsHashLookupError
  def initialize(original_error, hash, metric_spec); end
end

class NewRelic::Agent::SyntheticsEventAggregator < ::NewRelic::Agent::EventAggregator
  def record(event); end

  private

  def after_harvest(metadata); end
  def record_dropped_synthetics(metadata); end
end

NewRelic::Agent::SyntheticsEventAggregator::TIMESTAMP = T.let(T.unsafe(nil), String)

class NewRelic::Agent::SyntheticsMonitor < ::NewRelic::Agent::InboundRequestMonitor
  # THREAD_LOCAL_ACCESS
  def on_before_call(request); end

  def on_finished_configuring(events); end

  class << self
    # @return [Boolean]
    def is_supported_version?(incoming_payload); end

    # @return [Boolean]
    def is_trusted?(incoming_payload); end

    # @return [Boolean]
    def is_valid_payload?(incoming_payload); end

    def reject_messaging_synthetics_header(headers); end
  end
end

NewRelic::Agent::SyntheticsMonitor::EXPECTED_PAYLOAD_LENGTH = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::SyntheticsMonitor::SUPPORTED_VERSION = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::SyntheticsMonitor::SYNTHETICS_HEADER_KEY = T.let(T.unsafe(nil), String)

module NewRelic::Agent::SystemInfo
  class << self
    def boot_id; end

    # @return [Boolean]
    def bsd?; end

    def clear_processor_info; end

    # @return [Boolean]
    def darwin?; end

    def docker_container_id; end
    def get_processor_info; end
    def ip_addresses; end

    # @return [Boolean]
    def linux?; end

    def num_logical_processors; end
    def num_physical_cores; end
    def num_physical_packages; end
    def os_version; end
    def parse_cgroup_ids(cgroup_info); end
    def parse_cpuinfo(cpuinfo); end
    def parse_docker_container_id(cgroup_info); end
    def parse_linux_meminfo_in_mib(meminfo); end

    # A File.read against /(proc|sysfs)/* can hang with some older Linuxes.
    # See https://bugzilla.redhat.com/show_bug.cgi?id=604887, RUBY-736, and
    # https://github.com/opscode/ohai/commit/518d56a6cb7d021b47ed3d691ecf7fba7f74a6a7
    # for details on why we do it this way.
    def proc_try_read(path); end

    def processor_arch; end
    def ram_in_mib; end
    def ruby_os_identifier; end
    def sysctl_value(name); end
  end
end

# @api public
NewRelic::Agent::TRACE_ID_KEY = T.let(T.unsafe(nil), String)

module NewRelic::Agent::Threading; end

class NewRelic::Agent::Threading::AgentThread
  class << self
    def backing_thread_class; end
    def backing_thread_class=(clazz); end

    # THREAD_LOCAL_ACCESS
    def bucket_thread(thread, profile_agent_code); end

    def create(label, &blk); end

    # Simplifies testing if we don't directly use ::Thread.list, so keep
    # the accessor for it here on AgentThread to use and stub.
    def list; end

    def scrub_backtrace(thread, profile_agent_code); end
  end
end

class NewRelic::Agent::Threading::BacktraceBase
  # @return [BacktraceBase] a new instance of BacktraceBase
  def initialize; end

  def add_child(child); end
  def add_child_unless_present(child); end

  # Returns the value of attribute children.
  def children; end

  def find_child(raw_line); end
end

class NewRelic::Agent::Threading::BacktraceNode < ::NewRelic::Agent::Threading::BacktraceBase
  include ::NewRelic::Coerce

  # @return [BacktraceNode] a new instance of BacktraceNode
  def initialize(line); end

  def ==(other); end

  # Returns the value of attribute as_array.
  def as_array; end

  def complete_array_conversion; end

  # Returns the value of attribute depth.
  def depth; end

  # Sets the attribute depth
  #
  # @param value the value to set the attribute depth to.
  def depth=(_arg0); end

  def dump_string(indent = T.unsafe(nil)); end

  # Returns the value of attribute file.
  def file; end

  # Returns the value of attribute line_no.
  def line_no; end

  def mark_for_array_conversion; end

  # Returns the value of attribute method.
  def method; end

  # Returns [filename, method, line number]
  def parse_backtrace_frame(frame); end

  # Returns the value of attribute raw_line.
  def raw_line; end

  # Returns the value of attribute runnable_count.
  def runnable_count; end

  # Sets the attribute runnable_count
  #
  # @param value the value to set the attribute runnable_count to.
  def runnable_count=(_arg0); end
end

class NewRelic::Agent::Threading::BacktraceRoot < ::NewRelic::Agent::Threading::BacktraceBase
  # @return [BacktraceRoot] a new instance of BacktraceRoot
  def initialize; end

  def ==(other); end
  def aggregate(backtrace); end
  def as_array; end
  def dump_string; end

  # Returns the value of attribute flattened.
  def flattened; end
end

class NewRelic::Agent::Threading::BacktraceService
  # @return [BacktraceService] a new instance of BacktraceService
  def initialize(event_listener = T.unsafe(nil)); end

  # If our overhead % exceeds the threshold, bump the next poll period
  # relative to how much larger our overhead is than allowed
  def adjust_polling_time(now, poll_start); end

  # This method is expected to be called with @lock held.
  def aggregate_backtraces(backtraces, name, start, duration, bucket, thread); end

  # This method is expected to be called with @lock held.
  def aggregate_global_backtrace(backtrace, bucket, thread); end

  # @return [Boolean]
  def allowed_bucket?(bucket); end

  # Returns the value of attribute buffer.
  def buffer; end

  # This method is expected to be called with @lock held.
  def buffer_backtrace_for_thread(thread, timestamp, backtrace, bucket); end

  # Returns the value of attribute effective_polling_period.
  def effective_polling_period; end

  def effective_polling_period=(new_period); end

  # This method is expected to be called with @lock held.
  def find_effective_polling_period; end

  def harvest(transaction_name); end

  # This method is expected to be called with @lock held.
  #
  # @return [Boolean]
  def need_backtrace?(bucket); end

  def on_transaction_finished(payload); end

  # Returns the value of attribute overhead_percent_threshold.
  def overhead_percent_threshold; end

  def poll; end

  # Returns the value of attribute profile_agent_code.
  def profile_agent_code; end

  # Sets the attribute profile_agent_code
  #
  # @param value the value to set the attribute profile_agent_code to.
  def profile_agent_code=(_arg0); end

  # This method is expected to be called with @lock held.
  def profiles; end

  def record_polling_time(now, poll_start); end
  def record_skew(poll_start); end
  def record_supportability_metrics(now, poll_start); end

  # Public interface
  #
  # @return [Boolean]
  def running?; end

  # This method is expected to be called with @lock held.
  def sample_thread(thread); end

  # This method is expected to be called with @lock held.
  #
  # @return [Boolean]
  def should_buffer?(bucket); end

  # This method is expected to be called with @lock held.
  #
  # @return [Boolean]
  def should_profile_agent_code?; end

  def start; end

  # This method is expected to be called with @lock held
  def stop; end

  def subscribe(transaction_name, command_arguments = T.unsafe(nil)); end

  # @return [Boolean]
  def subscribed?(transaction_name); end

  def unsubscribe(transaction_name); end
  def update_values_from_profiles; end

  # This method is expected to be called with @lock held
  #
  # @return [Boolean]
  def watching_for_transaction?; end

  # Returns the value of attribute worker_loop.
  def worker_loop; end

  # Returns the value of attribute worker_thread.
  def worker_thread; end

  # Sets the attribute worker_thread
  #
  # @param value the value to set the attribute worker_thread to.
  def worker_thread=(_arg0); end

  class << self
    # Because of Resque's forking, we don't poll thread backtraces for it.
    # To accomplish that would require starting a new backtracing thread in
    # each forked worker, and merging profiles across the pipe channel.
    #
    # @return [Boolean]
    def is_resque?; end

    # @return [Boolean]
    def is_supported?; end
  end
end

NewRelic::Agent::Threading::BacktraceService::ALL_TRANSACTIONS = T.let(T.unsafe(nil), String)
NewRelic::Agent::Threading::BacktraceService::MAX_BUFFER_LENGTH = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::Threading::MAX_THREAD_PROFILE_DEPTH = T.let(T.unsafe(nil), Integer)

class NewRelic::Agent::Threading::ThreadProfile
  include ::NewRelic::Coerce

  # @return [ThreadProfile] a new instance of ThreadProfile
  def initialize(command_arguments = T.unsafe(nil)); end

  def aggregate(backtrace, bucket, thread); end

  # Returns the value of attribute backtrace_count.
  def backtrace_count; end

  # Returns the value of attribute command_arguments.
  def command_arguments; end

  # THREAD_LOCAL_ACCESS
  def convert_N_trace_nodes_to_arrays(count_to_keep); end

  # Returns the value of attribute created_at.
  def created_at; end

  # Returns the value of attribute duration.
  def duration; end

  # @return [Boolean]
  def empty?; end

  # Returns the value of attribute failure_count.
  def failure_count; end

  # Returns the value of attribute finished_at.
  def finished_at; end

  # Sets the attribute finished_at
  #
  # @param value the value to set the attribute finished_at to.
  def finished_at=(_arg0); end

  def generate_traces; end
  def increment_poll_count; end

  # Returns the value of attribute poll_count.
  def poll_count; end

  # Returns the value of attribute profile_agent_code.
  def profile_agent_code; end

  # Returns the value of attribute profile_id.
  def profile_id; end

  def requested_period; end

  # Returns the value of attribute sample_period.
  def sample_period; end

  def to_collector_array(encoder); end
  def to_log_description; end

  # Returns the value of attribute traces.
  def traces; end

  def unique_thread_count; end
end

NewRelic::Agent::Threading::ThreadProfile::THREAD_PROFILER_NODES = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::Threading::UNKNOWN_LINE_NUMBER = T.let(T.unsafe(nil), Integer)

class NewRelic::Agent::TimestampSampledBuffer < ::NewRelic::Agent::PrioritySampledBuffer
  private

  def priority_for(event); end
end

NewRelic::Agent::TimestampSampledBuffer::TIMESTAMP_KEY = T.let(T.unsafe(nil), String)

class NewRelic::Agent::TraceContextPayload
  extend ::NewRelic::Coerce

  # @return [TraceContextPayload] a new instance of TraceContextPayload
  def initialize(version, parent_type_id, parent_account_id, parent_app_id, id, transaction_id, sampled, priority, timestamp); end

  # Returns the value of attribute id.
  def id; end

  # Sets the attribute id
  #
  # @param value the value to set the attribute id to.
  def id=(_arg0); end

  # Returns the value of attribute parent_account_id.
  def parent_account_id; end

  # Sets the attribute parent_account_id
  #
  # @param value the value to set the attribute parent_account_id to.
  def parent_account_id=(_arg0); end

  # Returns the value of attribute parent_app_id.
  def parent_app_id; end

  # Sets the attribute parent_app_id
  #
  # @param value the value to set the attribute parent_app_id to.
  def parent_app_id=(_arg0); end

  def parent_type; end

  # Returns the value of attribute parent_type_id.
  def parent_type_id; end

  # Sets the attribute parent_type_id
  #
  # @param value the value to set the attribute parent_type_id to.
  def parent_type_id=(_arg0); end

  # Returns the value of attribute priority.
  def priority; end

  # Sets the attribute priority
  #
  # @param value the value to set the attribute priority to.
  def priority=(_arg0); end

  # Returns the value of attribute sampled.
  def sampled; end

  # Sets the attribute sampled
  #
  # @param value the value to set the attribute sampled to.
  def sampled=(_arg0); end

  # Returns the value of attribute sampled.
  def sampled?; end

  # Returns the value of attribute timestamp.
  def timestamp; end

  # Sets the attribute timestamp
  #
  # @param value the value to set the attribute timestamp to.
  def timestamp=(_arg0); end

  def to_s; end

  # Returns the value of attribute transaction_id.
  def transaction_id; end

  # Sets the attribute transaction_id
  #
  # @param value the value to set the attribute transaction_id to.
  def transaction_id=(_arg0); end

  # @return [Boolean]
  def valid?; end

  # Returns the value of attribute version.
  def version; end

  # Sets the attribute version
  #
  # @param value the value to set the attribute version to.
  def version=(_arg0); end

  class << self
    def create(version: T.unsafe(nil), parent_type: T.unsafe(nil), parent_account_id: T.unsafe(nil), parent_app_id: T.unsafe(nil), id: T.unsafe(nil), transaction_id: T.unsafe(nil), sampled: T.unsafe(nil), priority: T.unsafe(nil), timestamp: T.unsafe(nil)); end
    def from_s(payload_string); end

    private

    def handle_invalid_payload(error: T.unsafe(nil), message: T.unsafe(nil)); end
    def now_ms; end
  end
end

NewRelic::Agent::TraceContextPayload::DELIMITER = T.let(T.unsafe(nil), String)
NewRelic::Agent::TraceContextPayload::FALSE_CHAR = T.let(T.unsafe(nil), String)
NewRelic::Agent::TraceContextPayload::PARENT_TYPE = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::TraceContextPayload::PARENT_TYPES = T.let(T.unsafe(nil), Array)
NewRelic::Agent::TraceContextPayload::SUPPORTABILITY_PARSE_EXCEPTION = T.let(T.unsafe(nil), String)
NewRelic::Agent::TraceContextPayload::TRUE_CHAR = T.let(T.unsafe(nil), String)
NewRelic::Agent::TraceContextPayload::VERSION = T.let(T.unsafe(nil), Integer)

# This class helps you interact with the current transaction (if
# it exists), start new transactions/segments, etc.
#
# @api public
class NewRelic::Agent::Tracer
  class << self
    # @api public
    def accept_distributed_trace_payload(payload); end

    # Will potentially capture and notice an error at the
    # segment that was executing when error occurred.
    # if passed +segment+ is something that doesn't
    # respond to +notice_segment_error+ then this method
    # is effectively just a yield to the given &block
    #
    # @api public
    def capture_segment_error(segment); end

    # @api public
    def clear_state; end

    # @api public
    def create_distributed_trace_payload; end

    # Returns the currently active segment in the transaction in
    # progress for this thread, or +nil+ if no segment or
    # transaction exists.
    #
    # @api public
    def current_segment; end

    # Returns the id of the current span, or +nil+ if none exists.
    #
    # @api public
    def current_span_id; end

    # Returns the trace_id of the current_transaction, or +nil+ if
    # none exists.
    #
    # @api public
    def current_trace_id; end

    # Returns the transaction in progress for this thread, or
    # +nil+ if none exists.
    #
    # @api public
    def current_transaction; end

    # Runs the given block of code in a transaction.
    #
    # @api public
    # @param name [String] reserved for New Relic internal use
    # @param partial_name [String] a meaningful name for this
    #   transaction (e.g., +blogs/index+); the Ruby agent will add a
    #   New-Relic-specific prefix
    # @param category [Symbol] +:web+ for web transactions or
    #   +:background+ for background transactions
    # @param options [Hash] reserved for New Relic internal use
    def in_transaction(name: T.unsafe(nil), partial_name: T.unsafe(nil), category: T.unsafe(nil), options: T.unsafe(nil)); end

    # Returns a boolean indicating whether the current_transaction
    # is sampled, or +nil+ if there is no current transaction.
    #
    # @api public
    # @return [Boolean]
    def sampled?; end

    # Returns the id of the current span, or +nil+ if none exists.
    #
    # @api public
    def span_id; end

    # Creates and starts a datastore segment used to time
    # datastore operations.
    #
    # @api public
    # @param product [String] the datastore name for use in metric
    #   naming, e.g. "FauxDB"
    # @param operation [String] the name of the operation
    #   (e.g. "select"), often named after the method that's being
    #   instrumented.
    # @param collection [optional, String] the collection name for use in
    #   statement-level metrics (i.e. table or model name)
    # @param host [optional, String] the host this database
    #   instance is running on
    # @param database_name [optional, String] the name of this
    #   database
    # @param start_time [optional, Time] a +Time+ instance
    #   denoting the start time of the segment. Value is set by
    #   AbstractSegment#start if not given.
    # @param parent [optional, Segment] Use for the rare cases
    #   (such as async) where the parent segment should be something
    #   other than the current segment
    # @param port_path_or_id [optional, String] TCP port, file
    #   path, UNIX domain socket, or other connection-related info
    # @return [DatastoreSegment] the newly created segment; you
    #   _must_ call +finish+ on it at the end of the code you're
    #   tracing
    def start_datastore_segment(product: T.unsafe(nil), operation: T.unsafe(nil), collection: T.unsafe(nil), host: T.unsafe(nil), port_path_or_id: T.unsafe(nil), database_name: T.unsafe(nil), start_time: T.unsafe(nil), parent: T.unsafe(nil)); end

    # Creates and starts an external request segment using the
    # given library, URI, and procedure. This is used to time
    # external calls made over HTTP.
    #
    # @api public
    # @param library [String] a string of the class name of the library used to
    #   make the external call, for example, 'Net::HTTP'.
    # @param uri [String, URI] indicates the URI to which the
    #   external request is being made. The URI should begin with the protocol,
    #   for example, 'https://github.com'.
    # @param procedure [String] the HTTP method being used for the external
    #   request as a string, for example, 'GET'.
    # @param start_time [optional, Time] a +Time+ instance
    #   denoting the start time of the segment. Value is set by
    #   AbstractSegment#start if not given.
    # @param parent [optional, Segment] Use for the rare cases
    #   (such as async) where the parent segment should be something
    #   other than the current segment
    # @return [ExternalRequestSegment] the newly created segment;
    #   you _must_ call +finish+ on it at the end of the code
    #   you're tracing
    def start_external_request_segment(library:, uri:, procedure:, start_time: T.unsafe(nil), parent: T.unsafe(nil)); end

    # For New Relic internal use only.
    #
    # @api public
    def start_message_broker_segment(action:, library:, destination_type:, destination_name:, headers: T.unsafe(nil), parameters: T.unsafe(nil), start_time: T.unsafe(nil), parent: T.unsafe(nil)); end

    # Creates and starts a general-purpose segment used to time
    # arbitrary code.
    #
    # @api public
    # @param name [String] full name of the segment; the agent
    #   will not add a prefix. Third-party users should begin the
    #   name with +Custom/+; e.g.,
    #   +Custom/UserMailer/send_welcome_email+
    # @param unscoped_metrics [optional, String, Array] additional
    #   unscoped metrics to record using this segment's timing
    #   information
    # @param start_time [optional, Time] a +Time+ instance
    #   denoting the start time of the segment. Value is set by
    #   AbstractSegment#start if not given.
    # @param parent [optional, Segment] Use for the rare cases
    #   (such as async) where the parent segment should be something
    #   other than the current segment
    # @return [Segment] the newly created segment; you _must_ call
    #   +finish+ on it at the end of the code you're tracing
    def start_segment(name:, unscoped_metrics: T.unsafe(nil), start_time: T.unsafe(nil), parent: T.unsafe(nil)); end

    # Takes name or partial_name and a category.
    # Returns a transaction instance or nil
    #
    # @api public
    def start_transaction(category:, name: T.unsafe(nil), partial_name: T.unsafe(nil), **options); end

    # Starts a segment on the current transaction (if one exists)
    # or starts a new transaction otherwise.
    #
    # @api public
    # @param name [String] reserved for New Relic internal use
    # @param partial_name [String] a meaningful name for this
    #   transaction (e.g., +blogs/index+); the Ruby agent will add a
    #   New-Relic-specific prefix
    # @param category [Symbol] +:web+ for web transactions or
    #   +:task+ for background transactions
    # @param options [Hash] reserved for New Relic internal use
    # @return [Object, #finish] an object that responds to
    #   +finish+; you _must_ call +finish+ on it at the end of the
    #   code you're tracing
    def start_transaction_or_segment(category:, name: T.unsafe(nil), partial_name: T.unsafe(nil), options: T.unsafe(nil)); end

    # @api public
    def state; end

    # This method should only be used by Tracer for access to the
    # current thread's state or to provide read-only accessors for other threads
    #
    # If ever exposed, this requires additional synchronization
    #
    # @api public
    def state_for(thread); end

    # @api public
    def tl_clear; end

    # @api public
    def tl_get; end

    # This method should only be used by Tracer for access to the
    # current thread's state or to provide read-only accessors for other threads
    #
    # If ever exposed, this requires additional synchronization
    #
    # @api public
    def tl_state_for(thread); end

    # Returns the trace_id of the current_transaction, or +nil+ if
    # none exists.
    #
    # @api public
    def trace_id; end

    # Returns +true+ unless called from within an
    # +NewRelic::Agent.disable_all_tracing+ block.
    #
    # @api public
    # @return [Boolean]
    def tracing_enabled?; end

    # Returns a boolean indicating whether the current_transaction
    # is sampled, or +nil+ if there is no current transaction.
    #
    # @api public
    # @return [Boolean]
    def transaction_sampled?; end

    private

    # @api public
    def log_error(method_name, exception); end

    # @api public
    def start_and_add_segment(segment, parent = T.unsafe(nil)); end
  end
end

# This is THE location to store thread local information during a transaction
# Need a new piece of data? Add a method here, NOT a new thread local variable.
#
# @api public
class NewRelic::Agent::Tracer::State
  # @api public
  # @return [State] a new instance of State
  def initialize; end

  # Current transaction stack
  #
  # @api public
  def current_transaction; end

  # @api public
  # @return [Boolean]
  def is_execution_traced?; end

  # @api public
  # @return [Boolean]
  def is_sql_recorded?; end

  # @api public
  def pop_traced; end

  # @api public
  def push_traced(should_trace); end

  # TT's and SQL
  #
  # @api public
  def record_sql; end

  # TT's and SQL
  #
  # @api public
  def record_sql=(_arg0); end

  # This starts the timer for the transaction.
  #
  # @api public
  def reset(transaction = T.unsafe(nil)); end

  # Sql Sampler Transaction Data
  #
  # @api public
  def sql_sampler_transaction_data; end

  # Sql Sampler Transaction Data
  #
  # @api public
  def sql_sampler_transaction_data=(_arg0); end

  # @api public
  # @return [Boolean]
  def tracing_enabled?; end

  # Execution tracing on current thread
  #
  # @api public
  def untraced; end

  # Execution tracing on current thread
  #
  # @api public
  def untraced=(_arg0); end
end

# This class represents a single transaction (usually mapping to one
# web request or background job invocation) instrumented by the Ruby agent.
#
# @api public
class NewRelic::Agent::Transaction
  include ::NewRelic::Agent::Transaction::Tracing

  # @api public
  # @return [Transaction] a new instance of Transaction
  def initialize(category, options); end

  # Call this to ensure that the current transaction trace is not saved
  # To fully ignore all metrics and errors, use ignore! instead.
  #
  # @api public
  def abort_transaction!; end

  # @api public
  def add_agent_attribute(key, value, default_destinations); end

  # @api public
  def add_custom_attributes(p); end

  # @api public
  def add_log_event(event); end

  # @api public
  def apdex_bucket(duration, current_apdex_t); end

  # A Time instance used for calculating the apdex score, which
  # might end up being @start, or it might be further upstream if
  # we can find a request header for the queue entry time
  #
  # @api public
  def apdex_start; end

  # A Time instance used for calculating the apdex score, which
  # might end up being @start, or it might be further upstream if
  # we can find a request header for the queue entry time
  #
  # @api public
  def apdex_start=(_arg0); end

  # @api public
  def apdex_t; end

  # @api public
  def append_apdex_perf_zone(payload); end

  # @api public
  def append_synthetics_to(payload); end

  # @api public
  def assign_agent_attributes; end

  # @api public
  def assign_intrinsics; end

  # @api public
  def assign_segment_dt_attributes; end

  # @api public
  def attributes; end

  # @api public
  def background_summary_metrics; end

  # @api public
  def best_name; end

  # @api public
  def calculate_gc_time; end

  # This method returns transport_duration in seconds. Transport duration
  # is stored in milliseconds on the payload, but it's needed in seconds
  # for metrics and intrinsics.
  #
  # @api public
  def calculate_transport_duration(distributed_trace_payload); end

  # @api public
  def category; end

  # @api public
  def commit!(outermost_node_name); end

  # @api public
  def cpu_burn; end

  # @api public
  def create_initial_segment; end

  # @api public
  def create_nested_segment(category, options); end

  # @api public
  def create_segment(name); end

  # @api public
  def default_name=(name); end

  # @api public
  def distributed_tracer; end

  # @api public
  def duration; end

  # @api public
  def end_time; end

  # @api public
  def exceptions; end

  # @api public
  def exceptions=(_arg0); end

  # @api public
  def filtered_params; end

  # @api public
  def filtered_params=(_arg0); end

  # @api public
  def finish; end

  # @api public
  def freeze_name_and_execute_if_not_ignored; end

  # @api public
  def gc_start_snapshot; end

  # @api public
  def generate_payload; end

  # @api public
  def guid; end

  # @api public
  # @return [Boolean]
  def had_error_affecting_apdex?; end

  # @api public
  def http_response_code; end

  # @api public
  def http_response_code=(_arg0); end

  # @api public
  def ignore!; end

  # @api public
  # @return [Boolean]
  def ignore?; end

  # @api public
  def ignore_apdex!; end

  # @api public
  # @return [Boolean]
  def ignore_apdex?; end

  # @api public
  def ignore_enduser!; end

  # @api public
  # @return [Boolean]
  def ignore_enduser?; end

  # @api public
  # @return [Boolean]
  def ignore_trace?; end

  # @api public
  # @return [Boolean]
  def include_guid?; end

  # @api public
  # @return [Boolean]
  def influences_transaction_name?(category); end

  # @api public
  def initial_segment; end

  # This transaction-local hash may be used as temprory storage by
  # instrumentation that needs to pass data from one instrumentation point
  # to another.
  #
  # For example, if both A and B are instrumented, and A calls B
  # but some piece of state needed by the instrumentation at B is only
  # available at A, the instrumentation at A may write into the hash, call
  # through, and then remove the key afterwards, allowing the
  # instrumentation at B to read the value in between.
  #
  # Keys should be symbols, and care should be taken to not generate key
  # names dynamically, and to ensure that keys are removed upon return from
  # the method that creates them.
  #
  # @api public
  def instrumentation_state; end

  # @api public
  # @return [Boolean]
  def is_synthetics_request?; end

  # @api public
  def jruby_cpu_burn; end

  # @api public
  def jruby_cpu_start; end

  # @api public
  def jruby_cpu_start=(_arg0); end

  # @api public
  def log_frozen_name(name); end

  # @api public
  def logs; end

  # @api public
  def merge_metrics; end

  # @api public
  def merge_request_parameters(params); end

  # @api public
  def merge_untrusted_agent_attributes(attributes, prefix, default_destinations); end

  # @api public
  def metrics; end

  # @api public
  # @return [Boolean]
  def name_frozen?; end

  # @api public
  # @return [Boolean]
  def needs_middleware_summary_metrics?(name); end

  # @api public
  def nest_initial_segment; end

  # @api public
  def nesting_max_depth; end

  # @api public
  def normal_cpu_burn; end

  # Do not call this.  Invoke the class method instead.
  #
  # @api public
  def notice_error(error, options = T.unsafe(nil)); end

  # @api public
  def overridden_name=(name); end

  # @api public
  def parent_span_id; end

  # @api public
  def parent_span_id=(_arg0); end

  # @api public
  def payload; end

  # @api public
  def priority; end

  # @api public
  def priority=(_arg0); end

  # @api public
  def process_cpu_start; end

  # @api public
  def process_cpu_start=(_arg0); end

  # End common interface
  #
  # @api public
  def promoted_transaction_name(name); end

  # @api public
  def queue_time; end

  # Fields for tracking synthetics requests
  #
  # @api public
  def raw_synthetics_header; end

  # Fields for tracking synthetics requests
  #
  # @api public
  def raw_synthetics_header=(_arg0); end

  # @api public
  def record_apdex; end

  # @api public
  def record_apdex_metrics(rollup_metric, transaction_prefix, current_apdex_t); end

  # @api public
  def record_exceptions; end

  # @api public
  def record_log_events; end

  # @api public
  def record_queue_time; end

  # The summary metrics recorded by this method all end up with a duration
  # equal to the transaction itself, and an exclusive time of zero.
  #
  # @api public
  def record_summary_metrics(outermost_node_name); end

  # @api public
  def record_transaction_event; end

  # @api public
  # @return [Boolean]
  def recording_web_transaction?; end

  # @api public
  def referer; end

  # @api public
  def request_path; end

  # @api public
  def request_port; end

  # @api public
  def response_content_length; end

  # @api public
  def response_content_length=(_arg0); end

  # @api public
  def response_content_type; end

  # @api public
  def response_content_type=(_arg0); end

  # @api public
  def sampled=(_arg0); end

  # @api public
  # @return [Boolean]
  def sampled?; end

  # @api public
  def segments; end

  # This event is fired when the transaction is fully completed. The metric
  # values and sampler can't be successfully modified from this event.
  #
  # @api public
  def send_transaction_finished_event; end

  # @api public
  def set_default_transaction_name(name, category); end

  # @api public
  def set_overriding_transaction_name(name, category); end

  # @api public
  # @return [Boolean]
  def similar_category?(category); end

  # @api public
  def start; end

  # A Time instance for the start time, never nil
  #
  # @api public
  def start_time; end

  # A Time instance for the start time, never nil
  #
  # @api public
  def start_time=(_arg0); end

  # reference to the transaction state managing this transaction
  #
  # @api public
  def state; end

  # reference to the transaction state managing this transaction
  #
  # @api public
  def state=(_arg0); end

  # @api public
  def summary_metrics; end

  # @api public
  def synthetics_account_id; end

  # @api public
  def synthetics_job_id; end

  # @api public
  def synthetics_monitor_id; end

  # Fields for tracking synthetics requests
  #
  # @api public
  def synthetics_payload; end

  # Fields for tracking synthetics requests
  #
  # @api public
  def synthetics_payload=(_arg0); end

  # @api public
  def synthetics_resource_id; end

  # @api public
  def synthetics_version; end

  # @api public
  def threshold; end

  # @api public
  def trace_id; end

  # @api public
  def trace_id=(value); end

  # For common interface with Trace
  #
  # @api public
  def transaction_name; end

  # @api public
  def transaction_specific_apdex_t; end

  # Populated with the trace sample once this transaction is completed.
  #
  # @api public
  def transaction_trace; end

  # @api public
  # @return [Boolean]
  def user_defined_rules_ignore?; end

  # @api public
  # @return [Boolean]
  def web_category?(category); end

  # @api public
  def with_database_metric_name(model, method, product = T.unsafe(nil)); end

  private

  # @api public
  def agent; end

  # @api public
  def jruby_cpu_time; end

  # @api public
  def process_cpu; end

  # @api public
  def sql_sampler; end

  # @api public
  def transaction_sampler; end

  class << self
    # discards the currently saved transaction information
    #
    # @api public
    def abort_transaction!; end

    # @api public
    def add_agent_attribute(key, value, default_destinations); end

    # @api public
    def apdex_bucket(duration, failed, apdex_t); end

    # @api public
    def merge_untrusted_agent_attributes(attributes, prefix, default_destinations); end

    # @api public
    def name_from_partial(partial_name, category); end

    # @api public
    def nested_transaction_name(name); end

    # See NewRelic::Agent.notice_error for options and commentary
    #
    # @api public
    def notice_error(e, options = T.unsafe(nil)); end

    # Returns truthy if the current in-progress transaction is considered a
    # a web transaction (as opposed to, e.g., a background transaction).
    #
    # @api public
    # @return [Boolean]
    def recording_web_transaction?; end

    # THREAD_LOCAL_ACCESS
    #
    # @api public
    def set_default_transaction_name(partial_name, category = T.unsafe(nil)); end

    # THREAD_LOCAL_ACCESS
    #
    # @api public
    def set_overriding_transaction_name(partial_name, category = T.unsafe(nil)); end

    # @api public
    def start_new_transaction(state, category, options); end

    # Return the currently active transaction, or nil.
    #
    # @api public
    def tl_current; end
  end
end

# @api public
NewRelic::Agent::Transaction::ACTION_CABLE_PREFIX = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Transaction::APDEX_ALL_METRIC = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Transaction::APDEX_F = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Transaction::APDEX_METRIC = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Transaction::APDEX_OTHER_METRIC = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Transaction::APDEX_OTHER_TXN_METRIC_PREFIX = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Transaction::APDEX_S = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Transaction::APDEX_T = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Transaction::APDEX_TXN_METRIC_PREFIX = T.let(T.unsafe(nil), String)

class NewRelic::Agent::Transaction::AbstractSegment
  # @return [AbstractSegment] a new instance of AbstractSegment
  def initialize(name = T.unsafe(nil), start_time = T.unsafe(nil)); end

  # Returns the value of attribute children_time.
  def children_time; end

  # Sets the attribute children_time
  #
  # @param value the value to set the attribute children_time to.
  def children_time=(_arg0); end

  def children_time_ranges; end

  # @return [Boolean]
  def children_time_ranges?; end

  # @return [Boolean]
  def concurrent_children?; end

  # This class is the base class for all segments. It is reponsible for
  # timing, naming, and defining lifecycle callbacks. One of the more
  # complex responsibilites of this class is computing exclusive duration.
  # One of the reasons for this complexity is that exclusive time will be
  # computed using time ranges or by recording an aggregate value for
  # a segments children time. The reason for this is that computing
  # exclusive duration using time ranges is expensive and it's only
  # necessary if a segment's children run concurrently, or a segment ends
  # after its parent. We will use the optimized exclusive duration
  # calculation in all other cases.
  def duration; end

  # This class is the base class for all segments. It is reponsible for
  # timing, naming, and defining lifecycle callbacks. One of the more
  # complex responsibilites of this class is computing exclusive duration.
  # One of the reasons for this complexity is that exclusive time will be
  # computed using time ranges or by recording an aggregate value for
  # a segments children time. The reason for this is that computing
  # exclusive duration using time ranges is expensive and it's only
  # necessary if a segment's children run concurrently, or a segment ends
  # after its parent. We will use the optimized exclusive duration
  # calculation in all other cases.
  def end_time; end

  # This class is the base class for all segments. It is reponsible for
  # timing, naming, and defining lifecycle callbacks. One of the more
  # complex responsibilites of this class is computing exclusive duration.
  # One of the reasons for this complexity is that exclusive time will be
  # computed using time ranges or by recording an aggregate value for
  # a segments children time. The reason for this is that computing
  # exclusive duration using time ranges is expensive and it's only
  # necessary if a segment's children run concurrently, or a segment ends
  # after its parent. We will use the optimized exclusive duration
  # calculation in all other cases.
  def exclusive_duration; end

  def finalize; end
  def finish; end

  # @return [Boolean]
  def finished?; end

  # This class is the base class for all segments. It is reponsible for
  # timing, naming, and defining lifecycle callbacks. One of the more
  # complex responsibilites of this class is computing exclusive duration.
  # One of the reasons for this complexity is that exclusive time will be
  # computed using time ranges or by recording an aggregate value for
  # a segments children time. The reason for this is that computing
  # exclusive duration using time ranges is expensive and it's only
  # necessary if a segment's children run concurrently, or a segment ends
  # after its parent. We will use the optimized exclusive duration
  # calculation in all other cases.
  def guid; end

  def inspect; end

  # Returns the value of attribute name.
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  def name=(_arg0); end

  def notice_error(exception, options = T.unsafe(nil)); end

  # Returns the value of attribute noticed_error.
  def noticed_error; end

  def noticed_error_attributes; end
  def params; end

  # @return [Boolean]
  def params?; end

  # Returns the value of attribute parent.
  def parent; end

  # Sets the attribute parent
  #
  # @param value the value to set the attribute parent to.
  def parent=(_arg0); end

  # Sets the attribute record_metrics
  #
  # @param value the value to set the attribute record_metrics to.
  def record_metrics=(_arg0); end

  # @return [Boolean]
  def record_metrics?; end

  # Sets the attribute record_on_finish
  #
  # @param value the value to set the attribute record_on_finish to.
  def record_on_finish=(_arg0); end

  # @return [Boolean]
  def record_on_finish?; end

  # Sets the attribute record_scoped_metric
  #
  # @param value the value to set the attribute record_scoped_metric to.
  def record_scoped_metric=(_arg0); end

  # @return [Boolean]
  def record_scoped_metric?; end

  def set_noticed_error(noticed_error); end
  def start; end

  # This class is the base class for all segments. It is reponsible for
  # timing, naming, and defining lifecycle callbacks. One of the more
  # complex responsibilites of this class is computing exclusive duration.
  # One of the reasons for this complexity is that exclusive time will be
  # computed using time ranges or by recording an aggregate value for
  # a segments children time. The reason for this is that computing
  # exclusive duration using time ranges is expensive and it's only
  # necessary if a segment's children run concurrently, or a segment ends
  # after its parent. We will use the optimized exclusive duration
  # calculation in all other cases.
  def start_time; end

  def time_range; end

  # Returns the value of attribute transaction.
  def transaction; end

  # Sets the attribute transaction
  #
  # @param value the value to set the attribute transaction to.
  def transaction=(_arg0); end

  # callback for subclasses to override
  def transaction_assigned; end

  # Returns the value of attribute transaction_name.
  def transaction_name; end

  # Sets the attribute transaction_name
  #
  # @param value the value to set the attribute transaction_name to.
  def transaction_name=(_arg0); end

  protected

  def child_complete(segment); end
  def child_start(segment); end

  # When a child segment completes after its parent, we need to propagate
  # the information about the descendant further up the tree so that
  # ancestors can properly account for exclusive time. Once we've reached
  # an ancestor whose end time is greater than or equal to the descendant's
  # we can stop the propagation. We pass along the direct child so we can
  # make any corrections needed for exclusive time calculation.
  def descendant_complete(child, descendant); end

  # Sets the attribute range_recorded
  #
  # @param value the value to set the attribute range_recorded to.
  def range_recorded=(_arg0); end

  # @return [Boolean]
  def range_recorded?; end

  private

  def force_finish; end
  def metric_cache; end
  def record_child_time(child); end
  def record_child_time_as_number(child); end
  def record_child_time_as_range(child); end
  def record_exclusive_duration; end

  # @raise [NotImplementedError]
  def record_metrics; end

  def run_complete_callbacks; end

  # callback for subclasses to override
  def segment_complete; end

  def transaction_state; end
end

NewRelic::Agent::Transaction::AbstractSegment::INSPECT_IGNORE = T.let(T.unsafe(nil), Array)

# @api public
NewRelic::Agent::Transaction::CONTROLLER_PREFIX = T.let(T.unsafe(nil), String)

class NewRelic::Agent::Transaction::DatastoreSegment < ::NewRelic::Agent::Transaction::Segment
  # @return [DatastoreSegment] a new instance of DatastoreSegment
  def initialize(product, operation, collection = T.unsafe(nil), host = T.unsafe(nil), port_path_or_id = T.unsafe(nil), database_name = T.unsafe(nil), start_time = T.unsafe(nil)); end

  # @api private
  def _notice_sql(sql, config = T.unsafe(nil), explainer = T.unsafe(nil), binds = T.unsafe(nil), name = T.unsafe(nil)); end

  # Returns the value of attribute collection.
  def collection; end

  # Returns the value of attribute database_name.
  def database_name; end

  # Sets the attribute database_name
  #
  # @param value the value to set the attribute database_name to.
  def database_name=(_arg0); end

  # Returns the value of attribute host.
  def host; end

  # Returns the value of attribute nosql_statement.
  def nosql_statement; end

  # Method for simplifying attaching non-SQL data statements to a
  # transaction. For instance, Mongo or CQL queries, Memcached or Redis
  # keys would all be appropriate data to attach as statements.
  #
  # Data passed to this method is NOT obfuscated by New Relic, so please
  # ensure that user information is obfuscated if the agent setting
  # `transaction_tracer.record_sql` is set to `obfuscated`
  #
  # @note THERE ARE SECURITY CONCERNS WHEN CAPTURING STATEMENTS!
  #   This method will properly ignore statements when the user has turned
  #   off capturing queries, but it is not able to obfuscate arbitrary data!
  #   To prevent exposing user information embedded in captured queries,
  #   please ensure all data passed to this method is safe to transmit to
  #   New Relic.
  # @param nosql_statement [String] text of the statement to capture.
  def notice_nosql_statement(nosql_statement); end

  def notice_sql(sql); end

  # Returns the value of attribute operation.
  def operation; end

  # Returns the value of attribute port_path_or_id.
  def port_path_or_id; end

  # Returns the value of attribute product.
  def product; end

  def record_metrics; end

  # Returns the value of attribute record_sql.
  def record_sql; end

  # Sets the attribute record_sql
  #
  # @param value the value to set the attribute record_sql to.
  def record_sql=(_arg0); end

  def set_instance_info(host = T.unsafe(nil), port_path_or_id = T.unsafe(nil)); end

  # Returns the value of attribute sql_statement.
  def sql_statement; end

  private

  def add_backtrace_parameter; end
  def add_database_name_parameter; end
  def add_instance_parameters; end
  def notice_sql_statement; end
  def notice_statement; end
  def record_span_event; end

  # @return [Boolean]
  def record_sql?; end

  def segment_complete; end
end

NewRelic::Agent::Transaction::DatastoreSegment::NEWLINE = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DatastoreSegment::UNKNOWN = T.let(T.unsafe(nil), String)

class NewRelic::Agent::Transaction::DistributedTracer
  include ::NewRelic::Agent::CrossAppTracing
  include ::NewRelic::Agent::Transaction::DistributedTracing
  include ::NewRelic::Coerce
  include ::NewRelic::Agent::Transaction::TraceContext

  # @return [DistributedTracer] a new instance of DistributedTracer
  def initialize(transaction); end

  def accept_incoming_request(request, transport_type = T.unsafe(nil)); end
  def accept_incoming_transport_type(request, transport_type); end
  def accept_transport_type_from_api(value); end
  def append_payload(payload); end
  def assign_intrinsics; end
  def caller_transport_type; end
  def consume_message_headers(headers, tracer_state, transport_type); end
  def insert_cat_headers(headers); end
  def insert_distributed_trace_header(headers); end
  def insert_headers(headers); end
  def log_request_headers(headers, direction = T.unsafe(nil)); end
  def parent_guid; end

  # Returns the value of attribute parent_transaction_id.
  def parent_transaction_id; end

  # Sets the attribute parent_transaction_id
  #
  # @param value the value to set the attribute parent_transaction_id to.
  def parent_transaction_id=(_arg0); end

  def record_metrics; end

  # Returns the value of attribute transaction.
  def transaction; end

  private

  def accept_cross_app_payload(headers, tracer_state); end
  def consume_message_cross_app_tracing_headers(headers, tracer_state); end
  def consume_message_distributed_tracing_headers(headers, transport_type); end
  def consume_message_synthetics_headers(headers); end
  def deobfuscate(message); end
end

module NewRelic::Agent::Transaction::DistributedTracing
  def accept_distributed_trace_payload(payload); end
  def accept_distributed_tracing_incoming_request(request); end
  def create_distributed_trace_payload; end

  # Returns the value of attribute distributed_trace_payload.
  def distributed_trace_payload; end

  # Sets the attribute distributed_trace_payload
  #
  # @param value the value to set the attribute distributed_trace_payload to.
  def distributed_trace_payload=(_arg0); end

  # Sets the attribute distributed_trace_payload_created
  #
  # @param value the value to set the attribute distributed_trace_payload_created to.
  def distributed_trace_payload_created=(_arg0); end

  # @return [Boolean]
  def distributed_trace_payload_created?; end

  private

  def assign_payload_and_sampling_params(payload); end
  def check_payload_ignored(payload); end
  def check_payload_present(payload); end
  def check_required_fields_present(payload); end
  def check_trusted_account(payload); end
  def check_valid_version(payload); end
  def decode_payload(payload); end
end

NewRelic::Agent::Transaction::DistributedTracing::ACCEPT_EXCEPTION_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DistributedTracing::ACCEPT_PARSE_EXCEPTION_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DistributedTracing::ACCEPT_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DistributedTracing::ACCEPT_SUCCESS_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DistributedTracing::CREATE_EXCEPTION_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DistributedTracing::CREATE_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DistributedTracing::CREATE_SUCCESS_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DistributedTracing::IGNORE_ACCEPT_AFTER_CREATE_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DistributedTracing::IGNORE_ACCEPT_MAJOR_VERSION_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DistributedTracing::IGNORE_ACCEPT_NULL_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DistributedTracing::IGNORE_ACCEPT_UNTRUSTED_ACCOUNT_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DistributedTracing::IGNORE_MULTIPLE_ACCEPT_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DistributedTracing::IGNORE_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DistributedTracing::LBRACE = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DistributedTracing::NEWRELIC_TRACE_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DistributedTracing::NULL_PAYLOAD = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DistributedTracing::SUPPORTABILITY_DISTRIBUTED_TRACE = T.let(T.unsafe(nil), String)

# This class represents an external segment in a transaction trace.
#
# @api public
class NewRelic::Agent::Transaction::ExternalRequestSegment < ::NewRelic::Agent::Transaction::Segment
  # @api public
  # @return [ExternalRequestSegment] a new instance of ExternalRequestSegment
  def initialize(library, uri, procedure, start_time = T.unsafe(nil)); end

  # This method adds New Relic request headers to a given request made to an
  # external API and checks to see if a host header is used for the request.
  # If a host header is used, it updates the segment name to match the host
  # header.
  #
  # object (must belong to a subclass of NewRelic::Agent::HTTPClients::AbstractRequest)
  #
  # @api public
  # @param request [NewRelic::Agent::HTTPClients::AbstractRequest] the request
  def add_request_headers(request); end

  # @api public
  # @return [Boolean]
  def cross_app_request?; end

  # @api public
  def cross_process_id; end

  # @api public
  def cross_process_transaction_name; end

  # Obtain an obfuscated +String+ suitable for delivery across public networks that identifies this application
  # and transaction to another application which is also running a New Relic agent. This +String+ can be processed
  # by +process_request_metadata+ on the receiving application.
  #
  # @api public
  # @return [String] obfuscated request metadata to send
  def get_request_metadata; end

  # @api public
  def host; end

  # @api public
  def http_status_code; end

  # @api public
  def library; end

  # @api public
  def name; end

  # @api public
  def procedure; end

  # @api public
  def process_response_headers(response); end

  # Process obfuscated +String+ sent from a called application that is also running a New Relic agent and
  # save information in current transaction for inclusion in a trace. This +String+ is generated by
  # +get_response_metadata+ on the receiving application.
  #
  # @api public
  # @param response_metadata [String] received obfuscated response metadata
  def process_response_metadata(response_metadata); end

  # This method extracts app data from an external response if present. If
  # a valid cross-app ID is found, the name of the segment is updated to
  # reflect the cross-process ID and transaction name.
  #
  # @api public
  # @param response [Hash] a hash of response headers
  def read_response_headers(response); end

  # @api public
  def record_metrics; end

  # @api public
  def transaction_guid; end

  # @api public
  def uri; end

  private

  # @api public
  def add_unscoped_metrics; end

  # @api public
  def insert_synthetics_header(request, header); end

  # @api public
  def obfuscator; end

  # @api public
  def process_host_header(request); end

  # @api public
  def record_span_event; end

  # @api public
  def segment_complete; end

  # Only sets the http_status_code if response.status_code is non-empty value
  #
  # @api public
  def set_http_status_code(response); end

  # @api public
  def suffixed_rollup_metric; end

  # @api public
  def update_segment_name; end
end

# @api public
NewRelic::Agent::Transaction::ExternalRequestSegment::APP_DATA_KEY = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Transaction::ExternalRequestSegment::EXTERNAL_ALL = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Transaction::ExternalRequestSegment::EXTERNAL_ALL_OTHER = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Transaction::ExternalRequestSegment::EXTERNAL_ALL_WEB = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Transaction::ExternalRequestSegment::MISSING_STATUS_CODE = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Transaction::ExternalRequestSegment::NR_SYNTHETICS_HEADER = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Transaction::GRAPE_PREFIX = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Transaction::JRUBY_CPU_TIME_ERROR = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Transaction::MESSAGE_PREFIX = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Transaction::MIDDLEWARE_PREFIX = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Transaction::MIDDLEWARE_SUMMARY_METRICS = T.let(T.unsafe(nil), Array)

class NewRelic::Agent::Transaction::MessageBrokerSegment < ::NewRelic::Agent::Transaction::Segment
  # @return [MessageBrokerSegment] a new instance of MessageBrokerSegment
  def initialize(action:, library:, destination_type:, destination_name:, headers: T.unsafe(nil), parameters: T.unsafe(nil), start_time: T.unsafe(nil)); end

  # Returns the value of attribute action.
  def action; end

  # Returns the value of attribute destination_name.
  def destination_name; end

  # Returns the value of attribute destination_type.
  def destination_type; end

  # Returns the value of attribute headers.
  def headers; end

  # Returns the value of attribute library.
  def library; end

  def name; end
  def transaction_assigned; end
end

NewRelic::Agent::Transaction::MessageBrokerSegment::ACTIONS = T.let(T.unsafe(nil), Hash)
NewRelic::Agent::Transaction::MessageBrokerSegment::CONSUME = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::MessageBrokerSegment::DESTINATION_TYPES = T.let(T.unsafe(nil), Array)
NewRelic::Agent::Transaction::MessageBrokerSegment::EXCHANGE = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::MessageBrokerSegment::METRIC_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::MessageBrokerSegment::NAMED = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::MessageBrokerSegment::PRODUCE = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::MessageBrokerSegment::PURGE = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::MessageBrokerSegment::QUEUE = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::MessageBrokerSegment::SLASH = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::MessageBrokerSegment::TEMP = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::MessageBrokerSegment::TOPIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::MessageBrokerSegment::TYPES = T.let(T.unsafe(nil), Hash)
NewRelic::Agent::Transaction::MessageBrokerSegment::UNKNOWN = T.let(T.unsafe(nil), String)

# for nested transactions
#
# @api public
NewRelic::Agent::Transaction::NESTED_TRANSACTION_PREFIX = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Transaction::OTHER_SUMMARY_METRIC = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Transaction::OTHER_TRANSACTION_PREFIX = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Transaction::QUEUE_TIME_METRIC = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Transaction::RACK_PREFIX = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Transaction::RAKE_PREFIX = T.let(T.unsafe(nil), String)

class NewRelic::Agent::Transaction::RequestAttributes
  # @return [RequestAttributes] a new instance of RequestAttributes
  def initialize(request); end

  # Returns the value of attribute accept.
  def accept; end

  def assign_agent_attributes(txn); end

  # Returns the value of attribute content_length.
  def content_length; end

  # Returns the value of attribute content_type.
  def content_type; end

  # Returns the value of attribute host.
  def host; end

  # Returns the value of attribute port.
  def port; end

  # Returns the value of attribute referer.
  def referer; end

  # Returns the value of attribute request_method.
  def request_method; end

  # Returns the value of attribute request_path.
  def request_path; end

  # Returns the value of attribute user_agent.
  def user_agent; end

  private

  def attribute_from_env(request, key); end
  def attribute_from_request(request, attribute_method); end
  def content_length_from_request(request); end
  def path_from_request(request); end
  def port_from_request(request); end

  # Make a safe attempt to get the referer from a request object, generally successful when
  # it's a Rack request.
  def referer_from_request(request); end
end

NewRelic::Agent::Transaction::RequestAttributes::HTTP_ACCEPT_HEADER_KEY = T.let(T.unsafe(nil), String)

# In practice we expect req to be a Rack::Request or ActionController::AbstractRequest
# (for older Rails versions).  But anything that responds to path can be passed to
# perform_action_with_newrelic_trace.
#
# We don't expect the path to include a query string, however older test helpers for
# rails construct the PATH_INFO enviroment variable improperly and we're generally
# being defensive.
NewRelic::Agent::Transaction::RequestAttributes::ROOT_PATH = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Transaction::SINATRA_PREFIX = T.let(T.unsafe(nil), String)

class NewRelic::Agent::Transaction::Segment < ::NewRelic::Agent::Transaction::AbstractSegment
  # @return [Segment] a new instance of Segment
  def initialize(name = T.unsafe(nil), unscoped_metrics = T.unsafe(nil), start_time = T.unsafe(nil)); end

  def add_agent_attribute(key, value, default_destinations = T.unsafe(nil)); end
  def add_custom_attributes(p); end
  def attributes; end

  # unscoped_metrics can be nil, a string, or array. we do this to save
  # object allocations. if allocations weren't important then we would
  # initialize it as an array that would be empty, have one item, or many items.
  def custom_transaction_attributes; end

  def merge_untrusted_agent_attributes(agent_attributes, prefix, default_destinations); end

  # unscoped_metrics can be nil, a string, or array. we do this to save
  # object allocations. if allocations weren't important then we would
  # initialize it as an array that would be empty, have one item, or many items.
  def unscoped_metrics; end

  private

  def append_unscoped_metric(metric); end
  def record_metrics; end
  def record_span_event; end
  def segment_complete; end

  class << self
    def merge_untrusted_agent_attributes(attributes, prefix, default_destinations); end
  end
end

class NewRelic::Agent::Transaction::SlowestSampleBuffer < ::NewRelic::Agent::Transaction::TransactionSampleBuffer
  # @return [Boolean]
  def allow_sample?(sample); end

  def capacity; end
end

NewRelic::Agent::Transaction::SlowestSampleBuffer::CAPACITY = T.let(T.unsafe(nil), Integer)

class NewRelic::Agent::Transaction::SyntheticsSampleBuffer < ::NewRelic::Agent::Transaction::TransactionSampleBuffer
  # @return [Boolean]
  def allow_sample?(sample); end

  def capacity; end
  def truncate_samples; end
end

# @api public
NewRelic::Agent::Transaction::TASK_PREFIX = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Transaction::TRANSACTION_NAMING_SOURCES = T.let(T.unsafe(nil), Array)

class NewRelic::Agent::Transaction::Trace
  # @return [Trace] a new instance of Trace
  def initialize(start_time); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Sets the attribute attributes
  #
  # @param value the value to set the attribute attributes to.
  def attributes=(_arg0); end

  def attributes_for_tracer_destination; end
  def collect_explain_plans!; end
  def count_nodes; end
  def create_node(time_since_start, metric_name = T.unsafe(nil)); end
  def duration; end
  def each_node(&block); end

  # Iterates recursively over each node in the entire transaction
  # sample tree while keeping track of nested nodes
  def each_node_with_nest_tracking(&block); end

  # Returns the value of attribute finished.
  def finished; end

  # Sets the attribute finished
  #
  # @param value the value to set the attribute finished to.
  def finished=(_arg0); end

  # Returns the value of attribute guid.
  def guid; end

  # Sets the attribute guid
  #
  # @param value the value to set the attribute guid to.
  def guid=(_arg0); end

  # Returns the value of attribute node_count.
  def node_count; end

  # Sets the attribute node_count
  #
  # @param value the value to set the attribute node_count to.
  def node_count=(_arg0); end

  def prepare_sql_for_transmission!; end
  def prepare_to_send!; end

  # Returns the value of attribute profile.
  def profile; end

  # Sets the attribute profile
  #
  # @param value the value to set the attribute profile to.
  def profile=(_arg0); end

  # Returns the value of attribute root_node.
  def root_node; end

  def sample_id; end

  # Returns the value of attribute start_time.
  def start_time; end

  def strip_sql!; end
  def synthetics_resource_id; end

  # Returns the value of attribute threshold.
  def threshold; end

  # Sets the attribute threshold
  #
  # @param value the value to set the attribute threshold to.
  def threshold=(_arg0); end

  def to_collector_array(encoder); end
  def to_s_compact; end
  def trace_tree(attributes_hash); end

  # Returns the value of attribute transaction_name.
  def transaction_name; end

  # Sets the attribute transaction_name
  #
  # @param value the value to set the attribute transaction_name to.
  def transaction_name=(_arg0); end
end

NewRelic::Agent::Transaction::Trace::AGENT_ATTRIBUTES_KEY = T.let(T.unsafe(nil), String)
class NewRelic::Agent::Transaction::Trace::FinishedTraceError < ::StandardError; end
NewRelic::Agent::Transaction::Trace::INTRINSIC_ATTRIBUTES_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::Trace::ROOT = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::Trace::USER_ATTRIBUTES_KEY = T.let(T.unsafe(nil), String)

module NewRelic::Agent::Transaction::TraceBuilder
  extend ::NewRelic::Agent::Transaction::TraceBuilder

  def build_trace(transaction); end

  private

  def copy_attributes(transaction, trace); end
  def create_trace_node(transaction, segment, parent); end

  # recursively builds a transaction trace from the flat list of segments
  def process_segments(transaction, segment, parent, relationship_map); end
end

module NewRelic::Agent::Transaction::TraceContext
  include ::NewRelic::Coerce

  def accept_trace_context(header_data); end
  def assign_trace_state_payload; end
  def create_trace_state; end
  def create_trace_state_payload; end

  # @return [Boolean]
  def ignore_trace_context?; end

  def insert_trace_context_header(header, format = T.unsafe(nil)); end

  # Returns the value of attribute trace_context_header_data.
  def trace_context_header_data; end

  # Sets the attribute trace_context_header_data
  #
  # @param value the value to set the attribute trace_context_header_data to.
  def trace_context_header_data=(_arg0); end

  # @return [Boolean]
  def trace_context_inserted?; end

  # @return [Boolean]
  def trace_parent_header_present?(request); end

  # Returns the value of attribute trace_state_payload.
  def trace_state_payload; end

  private

  def accept_trace_context_incoming_request(request); end
end

NewRelic::Agent::Transaction::TraceContext::ACCEPT_EXCEPTION_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::TraceContext::ACCEPT_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::TraceContext::ACCEPT_SUCCESS_METRIC = T.let(T.unsafe(nil), String)

module NewRelic::Agent::Transaction::TraceContext::AccountHelpers
  extend ::NewRelic::Agent::Transaction::TraceContext::AccountHelpers

  def trace_state_entry_key; end
end

NewRelic::Agent::Transaction::TraceContext::CREATE_EXCEPTION_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::TraceContext::CREATE_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::TraceContext::CREATE_SUCCESS_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::TraceContext::IGNORE_ACCEPT_AFTER_CREATE_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::TraceContext::IGNORE_MULTIPLE_ACCEPT_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::TraceContext::INVALID_TRACESTATE_PAYLOAD_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::TraceContext::NO_NR_ENTRY_TRACESTATE_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::TraceContext::SUPPORTABILITY_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::TraceContext::TRACESTATE_PREFIX = T.let(T.unsafe(nil), String)

class NewRelic::Agent::Transaction::TraceNode
  # @return [TraceNode] a new instance of TraceNode
  def initialize(metric_name, relative_start, relative_end = T.unsafe(nil), params = T.unsafe(nil), parent = T.unsafe(nil)); end

  def [](key); end
  def []=(key, value); end
  def children; end

  # Sets the attribute children
  #
  # @param value the value to set the attribute children to.
  def children=(_arg0); end

  def count_nodes; end

  # return the total duration of this node
  def duration; end

  # call the provided block for this node and each
  # of the called nodes
  def each_node(&block); end

  # call the provided block for this node and each
  # of the called nodes while keeping track of nested nodes
  def each_node_with_nest_tracking(&block); end

  # sets the final timestamp on a node to indicate the exit
  # point of the node
  def end_trace(timestamp); end

  # Returns the value of attribute entry_timestamp.
  def entry_timestamp; end

  # return the duration of this node without
  # including the time in the called nodes
  def exclusive_duration; end

  # The exit timestamp will be relative except for the outermost sample which will
  # have a timestamp.
  def exit_timestamp; end

  # The exit timestamp will be relative except for the outermost sample which will
  # have a timestamp.
  def exit_timestamp=(_arg0); end

  def explain_sql; end

  # Returns the value of attribute metric_name.
  def metric_name; end

  # Sets the attribute metric_name
  #
  # @param value the value to set the attribute metric_name to.
  def metric_name=(_arg0); end

  def obfuscated_sql; end
  def params; end

  # Sets the attribute params
  #
  # @param value the value to set the attribute params to.
  def params=(_arg0); end

  # Returns the value of attribute parent_node.
  def parent_node; end

  def parent_node=(s); end
  def path_string; end
  def select_allowed_params(params); end
  def to_array; end
  def to_debug_str(depth); end
  def to_s; end
  def to_s_compact; end
end

NewRelic::Agent::Transaction::TraceNode::UNKNOWN_NODE_NAME = T.let(T.unsafe(nil), String)

module NewRelic::Agent::Transaction::Tracing
  def add_segment(segment, parent = T.unsafe(nil)); end

  # Sets the attribute async
  #
  # @param value the value to set the attribute async to.
  def async=(_arg0); end

  # @return [Boolean]
  def async?; end

  # Returns the value of attribute current_segment.
  def current_segment; end

  def segment_complete(segment); end
  def segment_limit; end
  def total_time; end

  # Sets the attribute total_time
  #
  # @param value the value to set the attribute total_time to.
  def total_time=(_arg0); end

  private

  def finalize_segments; end
  def record_total_time_metrics; end
end

NewRelic::Agent::Transaction::Tracing::OTHER_TRANSACTION_TOTAL_TIME = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::Tracing::WEB_TRANSACTION_TOTAL_TIME = T.let(T.unsafe(nil), String)

class NewRelic::Agent::Transaction::TransactionSampleBuffer
  # @return [TransactionSampleBuffer] a new instance of TransactionSampleBuffer
  def initialize; end

  # @return [Boolean]
  def allow_sample?(sample); end

  # Capacity is the desired number of samples a buffer will hold. This
  # can be user dictated via config if a feature wants.
  #
  # This value will be forcibly capped by the max_capacity
  #
  # @raise [NotImplementedError]
  def capacity; end

  # @return [Boolean]
  def enabled?; end

  # @return [Boolean]
  def full?; end

  def harvest_samples; end

  # Apply hard upper limit to the capacity to prevent users from
  # consuming too much memory buffering TT's.
  #
  # A typical buffer should NOT override this method (although we do for
  # odd things like dev-mode)
  def max_capacity; end

  def reset!; end

  # Returns the value of attribute samples.
  def samples; end

  def store(sample); end
  def store_previous(previous_samples); end

  # Our default truncation strategy is to keep max_capacity
  # worth of the longest samples. Override this method for alternate
  # behavior.
  #
  # This doesn't use the more convenient #last and #sort_by to avoid
  # additional array allocations (and abundant alliteration)
  def truncate_samples; end

  def truncate_samples_if_needed; end

  # When pushing a scope different sample buffers potentially want to
  # know about what's happening to annotate the incoming nodes
  def visit_node(*_arg0); end

  private

  # If a buffer needs to modify an added sample, override this method.
  # Bounds checking, allowing samples and truncation belongs elsewhere.
  def add_sample(sample); end
end

NewRelic::Agent::Transaction::TransactionSampleBuffer::NO_SAMPLES = T.let(T.unsafe(nil), Array)
NewRelic::Agent::Transaction::TransactionSampleBuffer::SINGLE_BUFFER_MAX = T.let(T.unsafe(nil), Integer)

# @api public
NewRelic::Agent::Transaction::WEB_SUMMARY_METRIC = T.let(T.unsafe(nil), String)

# @api public
NewRelic::Agent::Transaction::WEB_TRANSACTION_CATEGORIES = T.let(T.unsafe(nil), Array)

module NewRelic::Agent::TransactionErrorPrimitive
  extend ::NewRelic::Agent::TransactionErrorPrimitive

  def append_cat(payload, sample); end
  def append_synthetics(payload, sample); end
  def create(noticed_error, payload, span_id); end
  def intrinsic_attributes_for(noticed_error, payload, span_id); end
end

NewRelic::Agent::TransactionErrorPrimitive::DURATION_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionErrorPrimitive::ERROR_CLASS_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionErrorPrimitive::ERROR_EXPECTED_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionErrorPrimitive::ERROR_MESSAGE_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionErrorPrimitive::GUID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionErrorPrimitive::NAME_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionErrorPrimitive::PORT_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionErrorPrimitive::PRIORITY_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionErrorPrimitive::REFERRING_TRANSACTION_GUID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionErrorPrimitive::SAMPLED_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionErrorPrimitive::SAMPLE_TYPE = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionErrorPrimitive::SPAN_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionErrorPrimitive::SYNTHETICS_JOB_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionErrorPrimitive::SYNTHETICS_MONITOR_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionErrorPrimitive::SYNTHETICS_RESOURCE_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionErrorPrimitive::TIMESTAMP_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionErrorPrimitive::TYPE_KEY = T.let(T.unsafe(nil), String)

class NewRelic::Agent::TransactionEventAggregator < ::NewRelic::Agent::EventAggregator
  def record(priority: T.unsafe(nil), event: T.unsafe(nil), &blk); end

  private

  def after_harvest(metadata); end

  # THREAD_LOCAL_ACCESS
  def record_sampling_rate(metadata); end
end

module NewRelic::Agent::TransactionEventPrimitive
  include ::NewRelic::Coerce
  extend ::NewRelic::Coerce
  extend ::NewRelic::Agent::TransactionEventPrimitive

  def create(payload); end

  private

  def agent_attributes(attributes); end
  def append_cat_alternate_path_hashes(sample, payload); end
  def append_optional_attributes(sample, payload); end
  def custom_attributes(attributes); end
  def optionally_append(sample_key, payload_key, sample, payload); end
end

NewRelic::Agent::TransactionEventPrimitive::APDEX_PERF_ZONE_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionEventPrimitive::CAT_ALTERNATE_PATH_HASHES_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionEventPrimitive::CAT_PATH_HASH_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionEventPrimitive::CAT_REFERRING_PATH_HASH_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionEventPrimitive::COMMA = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionEventPrimitive::DURATION_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionEventPrimitive::ERROR_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionEventPrimitive::GUID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionEventPrimitive::NAME_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionEventPrimitive::PRIORITY_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionEventPrimitive::REFERRING_TRANSACTION_GUID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionEventPrimitive::SAMPLED_KEY = T.let(T.unsafe(nil), String)

# The type field of the sample
NewRelic::Agent::TransactionEventPrimitive::SAMPLE_TYPE = T.let(T.unsafe(nil), String)

NewRelic::Agent::TransactionEventPrimitive::SYNTHETICS_JOB_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionEventPrimitive::SYNTHETICS_MONITOR_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionEventPrimitive::SYNTHETICS_RESOURCE_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionEventPrimitive::TIMESTAMP_KEY = T.let(T.unsafe(nil), String)

# Strings for static keys of the sample structure
NewRelic::Agent::TransactionEventPrimitive::TYPE_KEY = T.let(T.unsafe(nil), String)

# This is responsibile for recording transaction events and managing
# the relationship between events generated from synthetics requests
# vs normal requests.
class NewRelic::Agent::TransactionEventRecorder
  # @return [TransactionEventRecorder] a new instance of TransactionEventRecorder
  def initialize(events); end

  def create_event(payload); end
  def drop_buffered_data; end
  def record(payload); end

  # @return [Boolean]
  def synthetics_event?(payload); end

  # Returns the value of attribute synthetics_event_aggregator.
  def synthetics_event_aggregator; end

  # Returns the value of attribute transaction_event_aggregator.
  def transaction_event_aggregator; end
end

class NewRelic::Agent::TransactionMetrics
  # @return [TransactionMetrics] a new instance of TransactionMetrics
  def initialize; end

  def [](key); end
  def _record_metrics(names, value, aux, target, &blk); end
  def each_scoped; end
  def each_unscoped; end

  # @return [Boolean]
  def has_key?(key); end

  # As a general rule, when recording a scoped metric, the corresponding
  # unscoped metric should always be recorded as well.
  #
  # As an optimization, scoped metrics are representated within this class
  # only by their entries in the @scoped Hash, and it's up to clients to
  # propagate them into unscoped metrics as well when instances of this
  # class are merged into the global metric store.
  def record_scoped_and_unscoped(names, value = T.unsafe(nil), aux = T.unsafe(nil), &blk); end

  def record_unscoped(names, value = T.unsafe(nil), aux = T.unsafe(nil), &blk); end
end

NewRelic::Agent::TransactionMetrics::DEFAULT_PROC = T.let(T.unsafe(nil), Proc)

# This class contains the logic for recording and storing transaction
# traces (sometimes referred to as 'transaction samples').
#
# A transaction trace is a detailed timeline of the events that happened
# during the processing of a single transaction, including database calls,
# template rendering calls, and other instrumented method calls.
#
# @api public
class NewRelic::Agent::TransactionSampler
  # @api public
  # @return [TransactionSampler] a new instance of TransactionSampler
  def initialize; end

  # @api public
  def count; end

  # @api public
  # @return [Boolean]
  def enabled?; end

  # Gather transaction traces that we'd like to transmit to the server.
  #
  # @api public
  def harvest!; end

  # @api public
  def harvest_from_sample_buffers; end

  # @api public
  def last_sample; end

  # @api public
  def merge!(previous); end

  # @api public
  def on_finishing_transaction(txn); end

  # @api public
  def prepare_samples(samples); end

  # reset samples without rebooting the web server (used by dev mode)
  #
  # @api public
  def reset!; end

  # @api public
  def store_sample(sample); end
end

class NewRelic::Agent::TransactionSqlData
  # @return [TransactionSqlData] a new instance of TransactionSqlData
  def initialize; end

  # Returns the value of attribute guid.
  def guid; end

  # Returns the value of attribute path.
  def path; end

  def set_transaction_info(uri, guid); end
  def set_transaction_name(name); end

  # Returns the value of attribute sql_data.
  def sql_data; end

  # Returns the value of attribute uri.
  def uri; end
end

NewRelic::Agent::TransactionState = NewRelic::Agent::Tracer

module NewRelic::Agent::TransactionTimeAggregator
  private

  def harvest!(timestamp = T.unsafe(nil)); end
  def reset!(timestamp = T.unsafe(nil)); end
  def transaction_start(timestamp = T.unsafe(nil)); end
  def transaction_stop(timestamp = T.unsafe(nil), starting_thread_id = T.unsafe(nil)); end

  class << self
    def harvest!(timestamp = T.unsafe(nil)); end
    def reset!(timestamp = T.unsafe(nil)); end
    def transaction_start(timestamp = T.unsafe(nil)); end
    def transaction_stop(timestamp = T.unsafe(nil), starting_thread_id = T.unsafe(nil)); end

    private

    def current_thread; end

    # @return [Boolean]
    def in_transaction?(thread_id = T.unsafe(nil)); end

    def log_missing_elapsed_transaction_time; end
    def record_elapsed_transaction_time_until(timestamp, thread_id = T.unsafe(nil)); end
    def set_transaction_start_time(timestamp, thread_id = T.unsafe(nil)); end

    # @raise [ArgumentError]
    def split_transaction_at_harvest(timestamp, thread_id = T.unsafe(nil)); end

    def thread_by_id(thread_id); end

    # @return [Boolean]
    def thread_is_alive?(thread_id); end

    def transaction_time_in_thread(timestamp, thread_id, entry); end
  end
end

NewRelic::Agent::TransactionTimeAggregator::INSTANCE_BUSY_METRIC = T.let(T.unsafe(nil), String)

class NewRelic::Agent::TransactionTimeAggregator::TransactionStats < ::Struct
  # Returns the value of attribute elapsed_transaction_time
  #
  # @return [Object] the current value of elapsed_transaction_time
  def elapsed_transaction_time; end

  # Sets the attribute elapsed_transaction_time
  #
  # @param value [Object] the value to set the attribute elapsed_transaction_time to.
  # @return [Object] the newly set value
  def elapsed_transaction_time=(_); end

  # Returns the value of attribute transaction_started_at
  #
  # @return [Object] the current value of transaction_started_at
  def transaction_started_at; end

  # Sets the attribute transaction_started_at
  #
  # @param value [Object] the value to set the attribute transaction_started_at to.
  # @return [Object] the newly set value
  def transaction_started_at=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# placeholder name used when we cannot determine a transaction's name
#
# @api public
NewRelic::Agent::UNKNOWN_METRIC = T.let(T.unsafe(nil), String)

# An unrecoverable client-side error that prevents the agent from continuing
#
# @api public
class NewRelic::Agent::UnrecoverableAgentException < ::NewRelic::Agent::ServerConnectionException; end

# When a post is either too large or poorly formatted we should
# drop it and not try to resend
#
# @api public
class NewRelic::Agent::UnrecoverableServerException < ::NewRelic::Agent::ServerConnectionException; end

module NewRelic::Agent::Utilization; end

class NewRelic::Agent::Utilization::AWS < ::NewRelic::Agent::Utilization::Vendor
  class << self
    def imds_token; end
  end
end

NewRelic::Agent::Utilization::AWS::IMDS_BASE_URL = T.let(T.unsafe(nil), String)
NewRelic::Agent::Utilization::AWS::IMDS_KEYS = T.let(T.unsafe(nil), Array)
NewRelic::Agent::Utilization::AWS::IMDS_TOKEN_TTL_SECS = T.let(T.unsafe(nil), String)
NewRelic::Agent::Utilization::AWS::TOKEN_OPEN_TIMEOUT_SECS = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::Utilization::AWS::TOKEN_READ_TIMEOUT_SECS = T.let(T.unsafe(nil), Integer)
class NewRelic::Agent::Utilization::Azure < ::NewRelic::Agent::Utilization::Vendor; end

class NewRelic::Agent::Utilization::GCP < ::NewRelic::Agent::Utilization::Vendor
  def prepare_response(response); end
  def trim_leading(value); end
end

NewRelic::Agent::Utilization::GCP::MACH_TYPE = T.let(T.unsafe(nil), String)
NewRelic::Agent::Utilization::GCP::SLASH = T.let(T.unsafe(nil), String)
NewRelic::Agent::Utilization::GCP::ZONE = T.let(T.unsafe(nil), String)

class NewRelic::Agent::Utilization::PCF < ::NewRelic::Agent::Utilization::Vendor
  def detect; end

  # @return [Boolean]
  def pcf_keys_present?; end
end

class NewRelic::Agent::Utilization::Vendor
  # @return [Vendor] a new instance of Vendor
  def initialize; end

  def detect; end
  def endpoint; end
  def headers; end
  def key_transforms; end
  def keys; end

  # Returns the value of attribute metadata.
  def metadata; end

  def vendor_name; end

  private

  def normalize(value); end
  def prepare_response(response); end
  def process_response(response); end
  def record_supportability_metric; end
  def request_metadata; end
  def transform_key(key); end

  # @return [Boolean]
  def valid_chars?(value); end

  # @return [Boolean]
  def valid_length?(value); end

  class << self
    def endpoint(endpoint = T.unsafe(nil)); end
    def headers(headers = T.unsafe(nil)); end
    def key_transforms(key_transforms = T.unsafe(nil)); end
    def keys(keys = T.unsafe(nil)); end
    def processed_headers; end
    def vendor_name(vendor_name = T.unsafe(nil)); end
  end
end

NewRelic::Agent::Utilization::Vendor::SUCCESS = T.let(T.unsafe(nil), String)
NewRelic::Agent::Utilization::Vendor::VALID_CHARS = T.let(T.unsafe(nil), Regexp)

class NewRelic::Agent::UtilizationData
  def append_boot_id(collector_hash); end
  def append_configured_values(collector_hash); end
  def append_docker_info(collector_hash); end
  def append_full_hostname(collector_hash); end
  def append_ip_address(collector_hash); end
  def append_kubernetes_info(collector_hash); end
  def append_vendor_info(collector_hash); end
  def config_hash; end
  def configured_hostname; end

  # this is slightly ugly, but if a string value is passed in
  # for the env var: NEW_RELIC_UTILIZATION_LOGICAL_PROCESSORS the
  # coercion from EnvironmentSource will turn that into a numerical 0,
  # which is not a reasonable value for logical_processes and should
  # not be sent up
  def configured_logical_processors; end

  # see comment above as the situation is the same for:
  # NEW_RELIC_UTILIZATION_TOTAL_RAM_MIB
  def configured_total_ram_mib; end

  def container_id; end
  def cpu_count; end
  def fqdn; end
  def hostname; end
  def ip_addresses; end
  def ram_in_mib; end
  def to_collector_hash; end
end

NewRelic::Agent::UtilizationData::KUBERNETES_SERVICE_HOST = T.let(T.unsafe(nil), String)
NewRelic::Agent::UtilizationData::METADATA_VERSION = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::UtilizationData::VENDORS = T.let(T.unsafe(nil), Hash)

module NewRelic::Agent::VM
  class << self
    def create_vm; end
    def snapshot; end
    def vm; end
  end
end

class NewRelic::Agent::VM::JRubyVM
  def gather_stats(snap); end
  def snapshot; end

  # @return [Boolean]
  def supports?(key); end
end

class NewRelic::Agent::VM::MonotonicGCProfiler
  # @return [MonotonicGCProfiler] a new instance of MonotonicGCProfiler
  def initialize; end

  def total_time_s; end
end

class NewRelic::Agent::VM::MriVM
  def gather_gc_stats(snap); end
  def gather_gc_time(snap); end
  def gather_ruby_vm_stats(snap); end
  def gather_stats(snap); end
  def gather_thread_stats(snap); end
  def snapshot; end

  # @return [Boolean]
  def supports?(key); end
end

class NewRelic::Agent::VM::Snapshot
  # @return [Snapshot] a new instance of Snapshot
  def initialize; end

  # Returns the value of attribute constant_cache_invalidations.
  def constant_cache_invalidations; end

  # Sets the attribute constant_cache_invalidations
  #
  # @param value the value to set the attribute constant_cache_invalidations to.
  def constant_cache_invalidations=(_arg0); end

  # Returns the value of attribute gc_runs.
  def gc_runs; end

  # Sets the attribute gc_runs
  #
  # @param value the value to set the attribute gc_runs to.
  def gc_runs=(_arg0); end

  # Returns the value of attribute gc_total_time.
  def gc_total_time; end

  # Sets the attribute gc_total_time
  #
  # @param value the value to set the attribute gc_total_time to.
  def gc_total_time=(_arg0); end

  # Returns the value of attribute heap_free.
  def heap_free; end

  # Sets the attribute heap_free
  #
  # @param value the value to set the attribute heap_free to.
  def heap_free=(_arg0); end

  # Returns the value of attribute heap_live.
  def heap_live; end

  # Sets the attribute heap_live
  #
  # @param value the value to set the attribute heap_live to.
  def heap_live=(_arg0); end

  # Returns the value of attribute major_gc_count.
  def major_gc_count; end

  # Sets the attribute major_gc_count
  #
  # @param value the value to set the attribute major_gc_count to.
  def major_gc_count=(_arg0); end

  # Returns the value of attribute method_cache_invalidations.
  def method_cache_invalidations; end

  # Sets the attribute method_cache_invalidations
  #
  # @param value the value to set the attribute method_cache_invalidations to.
  def method_cache_invalidations=(_arg0); end

  # Returns the value of attribute minor_gc_count.
  def minor_gc_count; end

  # Sets the attribute minor_gc_count
  #
  # @param value the value to set the attribute minor_gc_count to.
  def minor_gc_count=(_arg0); end

  # Returns the value of attribute taken_at.
  def taken_at; end

  # Sets the attribute taken_at
  #
  # @param value the value to set the attribute taken_at to.
  def taken_at=(_arg0); end

  # Returns the value of attribute thread_count.
  def thread_count; end

  # Sets the attribute thread_count
  #
  # @param value the value to set the attribute thread_count to.
  def thread_count=(_arg0); end

  # Returns the value of attribute total_allocated_object.
  def total_allocated_object; end

  # Sets the attribute total_allocated_object
  #
  # @param value the value to set the attribute total_allocated_object to.
  def total_allocated_object=(_arg0); end
end

# A worker loop executes a set of registered tasks on a single thread.
# A task is a proc or block with a specified call period in seconds.
class NewRelic::Agent::WorkerLoop
  # Optional argument :duration (in seconds) for how long the worker loop runs
  # or :limit (integer) for max number of iterations
  #
  # @return [WorkerLoop] a new instance of WorkerLoop
  def initialize(opts = T.unsafe(nil)); end

  # Returns the value of attribute iterations.
  def iterations; end

  # a simple accessor for @should_run
  #
  # @return [Boolean]
  def keep_running?; end

  # Returns the value of attribute period.
  def period; end

  # Sets the attribute period
  #
  # @param value the value to set the attribute period to.
  def period=(_arg0); end

  # Returns the value of attribute propagate_errors.
  def propagate_errors; end

  # Sets the attribute propagate_errors
  #
  # @param value the value to set the attribute propagate_errors to.
  def propagate_errors=(_arg0); end

  # Run infinitely, calling the registered tasks at their specified
  # call periods.  The caller is responsible for creating the thread
  # that runs this worker loop.  This will run the task immediately.
  def run(period = T.unsafe(nil), &block); end

  # Executes the block given to the worker loop, and handles errors.
  def run_task; end

  def schedule_next_invocation; end

  # Reset state that is changed by running the worker loop
  def setup(period, task); end

  # Sets @should_run to false. Returns false
  def stop; end

  # @return [Boolean]
  def under_duration?; end

  # @return [Boolean]
  def under_limit?; end
end

NewRelic::CANDIDATE_NEWRELIC_KEYS = T.let(T.unsafe(nil), Array)
NewRelic::CONNECT_RETRY_PERIODS = T.let(T.unsafe(nil), Array)

# This class is used by NewRelic::Agent.set_sql_obfuscator to chain multiple
# obfuscation blocks when not using the default :replace action
class NewRelic::ChainedCall
  # @return [ChainedCall] a new instance of ChainedCall
  def initialize(block1, block2); end

  def call(sql); end
end

module NewRelic::Coerce
  private

  # Use when you plan to perform a boolean check using the integer 1
  # for true and the integer 0 for false
  # String values will be converted to 0
  def boolean_int!(value); end

  def float(value, context = T.unsafe(nil)); end
  def float!(value, precision = T.unsafe(nil)); end

  # We really don't want to send bad values to the collector, and it doesn't
  # accept types like Rational that have occasionally slipped into our data.
  #
  # These non-bang methods are intended to safely coerce things into the form we want,
  # to provide documentation of expected types on to_collector_array methods,
  # and to log failures if totally invalid data gets into outgoing data
  def int(value, context = T.unsafe(nil)); end

  def int!(value); end
  def int_or_nil(value, context = T.unsafe(nil)); end
  def log_failure(value, type, context, error); end
  def scalar(val); end
  def string(value, context = T.unsafe(nil)); end
  def value_or_nil(value); end

  class << self
    # Use when you plan to perform a boolean check using the integer 1
    # for true and the integer 0 for false
    # String values will be converted to 0
    def boolean_int!(value); end

    def float(value, context = T.unsafe(nil)); end
    def float!(value, precision = T.unsafe(nil)); end

    # We really don't want to send bad values to the collector, and it doesn't
    # accept types like Rational that have occasionally slipped into our data.
    #
    # These non-bang methods are intended to safely coerce things into the form we want,
    # to provide documentation of expected types on to_collector_array methods,
    # and to log failures if totally invalid data gets into outgoing data
    def int(value, context = T.unsafe(nil)); end

    def int!(value); end
    def int_or_nil(value, context = T.unsafe(nil)); end
    def log_failure(value, type, context, error); end
    def scalar(val); end
    def string(value, context = T.unsafe(nil)); end
    def value_or_nil(value); end
  end
end

module NewRelic::CollectionHelper
  # Transform parameter hash into a hash whose values are strictly
  # strings
  def normalize_params(params); end

  private

  # Convert any kind of object to a short string.
  def flatten(object); end

  def truncate(string, len = T.unsafe(nil)); end
end

NewRelic::CollectionHelper::DEFAULT_ARRAY_TRUNCATION_SIZE = T.let(T.unsafe(nil), Integer)
NewRelic::CollectionHelper::DEFAULT_TRUNCATION_SIZE = T.let(T.unsafe(nil), Integer)
class NewRelic::CommandExecutableNotFoundError < ::StandardError; end
class NewRelic::CommandRunFailedError < ::StandardError; end

# The Control is a singleton responsible for the startup and
# initialization sequence.  The initializer uses a LocalEnvironment to
# detect the framework and instantiates the framework specific
# subclass.
#
# The Control also implements some of the public API for the agent.
class NewRelic::Control
  include ::NewRelic::Control::ServerMethods
  include ::NewRelic::Control::Instrumentation
  include ::NewRelic::Control::InstanceMethods
  extend ::NewRelic::Control::ClassMethods
end

# class-level methods for lazy creation of NewRelic::Control and
# NewRelic::LocalEnvironment instances.
module NewRelic::Control::ClassMethods
  def camelize(snake_case_name); end

  # Access the Control singleton, lazy initialized.  Default will instantiate a new
  # instance or pass false to defer
  def instance(create = T.unsafe(nil)); end

  # Loads the specified framework class from the
  # NewRelic::Control::Frameworks module
  def load_framework_class(framework); end

  # nb this does not 'load test' the framework, it loads the 'test framework'
  def load_test_framework; end

  # Access the LocalEnvironment singleton, lazy initialized
  def local_env; end

  # Create the concrete class for environment specific behavior
  def new_instance; end

  # The root directory for the plugin or gem
  def newrelic_root; end

  # clear out memoized Control and LocalEnv instances
  def reset; end
end

# Contains subclasses of NewRelic::Control that are used when
# starting the agent within an application. Framework-specific
# logic should be included here, as documented within the Control
# abstract parent class
module NewRelic::Control::Frameworks; end

# Contains methods that relate to the runtime usage of the control
# object. Note that these are subject to override in the
# NewRelic::Control::Framework classes that are actually instantiated
module NewRelic::Control::InstanceMethods
  def initialize(local_env, config_file_override = T.unsafe(nil)); end

  # for backward compatibility with the old config interface
  def [](key); end

  def app; end
  def configure_agent(env, options); end
  def determine_env(options); end
  def dispatcher; end

  # The env is the setting used to identify which section of the newrelic.yml
  # to load.  This defaults to a framework specific value, such as ENV['RAILS_ENV']
  # but can be overridden as long as you set it before calling #init_plugin
  def env=(_arg0); end

  def framework; end
  def handle_invalid_security_settings; end

  # Initialize the plugin/gem and start the agent.  This does the
  # necessary configuration based on the framework environment and
  # determines whether or not to start the agent.  If the agent is
  # not going to be started then it loads the agent shim which has
  # stubs for all the external api.
  #
  # This may be invoked multiple times, as long as you don't attempt
  # to uninstall the agent after it has been started.
  #
  # If the plugin is initialized and it determines that the agent is
  # not enabled, it will skip starting it and install the shim.  But
  # if you later call this with <tt>:agent_enabled => true</tt>,
  # then it will install the real agent and start it.
  #
  # What determines whether the agent is launched is the result of
  # calling agent_enabled?  This will indicate whether the
  # instrumentation should/will be installed.  If we're in a mode
  # where tracers are not installed then we should not start the
  # agent.
  #
  # Subclasses are not allowed to override, but must implement
  # init_config({}) which is called one or more times.
  def init_plugin(options = T.unsafe(nil)); end

  # The local environment contains all the information we report
  # to the server about what kind of application this is, what
  # gems and plugins it uses, and many other kinds of
  # machine-dependent information useful in debugging
  def local_env; end

  # Delegates to the class method newrelic_root, implemented by
  # each subclass
  def newrelic_root; end

  # @return [Boolean]
  def security_settings_valid?; end

  def settings; end

  # Install the real agent into the Agent module, and issue the start command.
  def start_agent; end

  protected

  def root; end
  def stdout; end
end

# Contains methods that relate to adding and executing files that
# contain instrumentation for the Ruby Agent
module NewRelic::Control::Instrumentation
  # Add instrumentation.  Don't call this directly.  Use NewRelic::Agent#add_instrumentation.
  # This will load the file synchronously if we've already loaded the default
  # instrumentation, otherwise instrumentation files specified
  # here will be deferred until all instrumentation is run
  #
  # This happens after the agent has loaded and all dependencies
  # are ready to be instrumented
  def add_instrumentation(pattern); end

  # Signals the agent that it's time to actually load the
  # instrumentation files. May be overridden by subclasses
  def install_instrumentation; end

  def install_shim; end

  # Adds a list of files in Dir.glob format
  # (e.g. '/app/foo/**/*_instrumentation.rb')
  # This requires the files within a rescue block, so that any
  # errors within instrumentation files do not affect the overall
  # agent or application in which it runs.
  def load_instrumentation_files(pattern); end

  private

  def _install_instrumentation; end
end

# Structs holding info for the remote server and proxy server
class NewRelic::Control::Server < ::Struct
  def to_s; end
end

# Contains methods that deal with connecting to the server
module NewRelic::Control::ServerMethods
  # the server we should contact for api requests, like uploading
  # deployments and the like
  def api_server; end

  def server; end
  def server_from_host(hostname = T.unsafe(nil)); end
end

module NewRelic::DelayedJobInjection
  extend ::NewRelic::DelayedJobInjection

  # Returns the value of attribute worker_name.
  def worker_name; end

  # Sets the attribute worker_name
  #
  # @param value the value to set the attribute worker_name to.
  def worker_name=(_arg0); end
end

NewRelic::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
NewRelic::EMPTY_HASH = T.let(T.unsafe(nil), Hash)
NewRelic::EMPTY_STR = T.let(T.unsafe(nil), String)

# The EnvironmentReport is responsible for analyzing the application's
# environment and generating the data for the Environment Report in New
# Relic's interface.
#
# It contains useful system information like Ruby version, OS, loaded gems,
# etc.
#
# Additional logic can be registered by using the EnvironmentReport.report_on
# hook.
class NewRelic::EnvironmentReport
  # Generate the report based on the class level logic.
  #
  # @return [EnvironmentReport] a new instance of EnvironmentReport
  def initialize; end

  def [](key); end
  def []=(key, value); end

  # end reporting logic
  def data; end

  def to_a; end

  class << self
    def registered_reporters; end

    # allow the logic to be swapped out in tests
    def registered_reporters=(logic); end

    # This is the main interface for registering logic that should be included
    # in the Environment Report. For example:
    #
    # EnvironmentReport.report_on "Day of week" do
    #   Time.now.strftime("%A")
    # end
    #
    # The passed blocks will be run in EnvironmentReport instances on #initialize.
    #
    # Errors raised in passed blocks will be handled and logged at debug, so it
    # is safe to report on things that may not work in certain environments.
    #
    # The blocks should only return strings or arrays full of strings.  Falsey
    # values will be ignored.
    def report_on(key, &block); end
  end
end

NewRelic::FORMAT_NON_RACK = T.let(T.unsafe(nil), Integer)
NewRelic::FORMAT_RACK = T.let(T.unsafe(nil), Integer)
NewRelic::HTTP = T.let(T.unsafe(nil), String)
NewRelic::HTTPS = T.let(T.unsafe(nil), String)
NewRelic::HTTP_NEWRELIC_KEY = T.let(T.unsafe(nil), String)
NewRelic::HTTP_TRACEPARENT_KEY = T.let(T.unsafe(nil), String)
NewRelic::HTTP_TRACESTATE_KEY = T.let(T.unsafe(nil), String)

# A singleton for shared generic helper methods
module NewRelic::Helper
  extend ::NewRelic::Helper

  # Confirm a string is correctly encoded,
  # If not force the encoding to ASCII-8BIT (binary)
  def correctly_encoded(string); end

  # TODO: Open3 defers the actual excecution of a binary to Process.spawn,
  #       which will raise an Errno::ENOENT exception for a file that
  #       cannot be found. We might want to take the time to evaluate
  #       relying on that Process.spawn behavior instead of checking for
  #       existence ourselves. We'd need to see what it does, how efficient
  #       it is, if it differs in functionality between Ruby versions and
  #       operating systems, etc.
  #
  # @return [Boolean]
  def executable_in_path?(executable); end

  def instance_method_visibility(klass, method_name); end

  # @return [Boolean]
  def instance_methods_include?(klass, method_name); end

  def run_command(command); end
  def time_to_millis(time); end
end

module NewRelic::LanguageSupport
  extend ::NewRelic::LanguageSupport

  # @return [Boolean]
  def bundled_gem?(gem_name); end

  # @return [Boolean]
  def can_fork?; end

  def constantize(const_name); end

  # @return [Boolean]
  def gc_profiler_enabled?; end

  # @return [Boolean]
  def gc_profiler_usable?; end

  # @return [Boolean]
  def jruby?; end

  # @return [Boolean]
  def object_space_usable?; end
end

# This class is responsible for determining the 'dispatcher' in use by the
# current process. The dispatcher might be a recognized web server such as
# unicorn or passenger, a background job processor such as resque or sidekiq,
# or nil for unknown.
#
# Dispatcher detection is best-effort, and serves two purposes:
#
# 1. For some dispatchers, we need to apply specific workarounds in order for
#    the agent to work correctly.
# 2. When reading logs, since multiple processes on a given host might write
#    into the same log, it's useful to be able to identify what kind of
#    process a given PID mapped to.
#
# Overriding the dispatcher is possible via the NEW_RELIC_DISPATCHER
# environment variable, but this should not generally be necessary unless
# you're on a dispatcher that falls into category 1 above, and our detection
# logic isn't working correctly.
#
# If the environment can't be determined, it will be set to nil.
#
# NewRelic::LocalEnvironment should be accessed through NewRelic::Control#env (via the NewRelic::Control singleton).
class NewRelic::LocalEnvironment
  # @return [LocalEnvironment] a new instance of LocalEnvironment
  def initialize; end

  def discovered_dispatcher; end
  def executable; end

  # Runs through all the objects in ObjectSpace to find the first one that
  # match the provided class
  def find_class_in_object_space(klass); end

  # outputs a human-readable description
  def to_s; end

  private

  def check_for_delayed_job; end
  def check_for_fastcgi; end
  def check_for_glassfish; end
  def check_for_litespeed; end

  # this case covers starting by mongrel_rails
  def check_for_mongrel; end

  def check_for_passenger; end
  def check_for_puma; end
  def check_for_rainbows; end
  def check_for_resque; end
  def check_for_sidekiq; end
  def check_for_thin; end
  def check_for_torquebox; end
  def check_for_trinidad; end
  def check_for_unicorn; end
  def check_for_webrick; end
  def discover_dispatcher; end

  # @return [Boolean]
  def jruby_rack?; end
end

NewRelic::MAX_RETRY_PERIOD = T.let(T.unsafe(nil), Integer)
NewRelic::MIN_RETRY_PERIOD = T.let(T.unsafe(nil), Integer)

# columns for a mysql explain plan
NewRelic::MYSQL_EXPLAIN_COLUMNS = T.let(T.unsafe(nil), Array)

class NewRelic::MetricData
  include ::NewRelic::Coerce

  # @return [MetricData] a new instance of MetricData
  def initialize(metric_spec, stats); end

  # @return [Boolean]
  def eql?(o); end

  def hash; end
  def inspect; end

  # a NewRelic::MetricSpec object
  def metric_spec; end

  # assigns a new metric spec, and retains the old metric spec as
  def metric_spec=(new_spec); end

  def original_spec; end

  # the actual statistics object
  def stats; end

  # the actual statistics object
  def stats=(_arg0); end

  def to_collector_array(encoder = T.unsafe(nil)); end
  def to_json(*a); end
  def to_s; end
end

# this struct uniquely defines a metric, optionally inside
# the call scope of another metric
class NewRelic::MetricSpec
  # @return [MetricSpec] a new instance of MetricSpec
  def initialize(metric_name = T.unsafe(nil), metric_scope = T.unsafe(nil)); end

  def <=>(o); end
  def ==(o); end

  # @return [Boolean]
  def eql?(o); end

  def hash; end
  def inspect; end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute scope.
  def scope; end

  def to_json(*a); end
  def to_s; end
end

NewRelic::MetricSpec::EMPTY_SCOPE = T.let(T.unsafe(nil), String)
NewRelic::MetricSpec::LENGTH_RANGE = T.let(T.unsafe(nil), Range)

# the maximum length of a metric name or metric scope
NewRelic::MetricSpec::MAX_LENGTH = T.let(T.unsafe(nil), Integer)

NewRelic::NEWRELIC_KEY = T.let(T.unsafe(nil), String)

# This class encapsulates an error that was noticed by New Relic in a managed app.
class NewRelic::NoticedError
  include ::NewRelic::Coerce
  extend ::NewRelic::CollectionHelper

  # @return [NoticedError] a new instance of NoticedError
  def initialize(path, exception, timestamp = T.unsafe(nil), expected = T.unsafe(nil)); end

  def ==(other); end
  def agent_attributes; end
  def append_attributes(outgoing_params, outgoing_key, source_attributes); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Sets the attribute attributes
  #
  # @param value the value to set the attribute attributes to.
  def attributes=(_arg0); end

  # Returns the value of attribute attributes_from_notice_error.
  def attributes_from_notice_error; end

  # Sets the attribute attributes_from_notice_error
  #
  # @param value the value to set the attribute attributes_from_notice_error to.
  def attributes_from_notice_error=(_arg0); end

  def base_parameters; end
  def build_agent_attributes(merged_attributes); end
  def build_error_attributes; end
  def build_intrinsic_attributes; end
  def custom_attributes; end

  # Returns the value of attribute exception_class_name.
  def exception_class_name; end

  # Sets the attribute exception_class_name
  #
  # @param value the value to set the attribute exception_class_name to.
  def exception_class_name=(_arg0); end

  # Returns the value of attribute exception_id.
  def exception_id; end

  # Returns the value of attribute expected.
  def expected; end

  # Sets the attribute expected
  #
  # @param value the value to set the attribute expected to.
  def expected=(_arg0); end

  def extract_class_name_and_message_from(exception); end

  # Returns the value of attribute file_name.
  def file_name; end

  # Sets the attribute file_name
  #
  # @param value the value to set the attribute file_name to.
  def file_name=(_arg0); end

  def intrinsic_attributes; end

  # Returns the value of attribute is_internal.
  def is_internal; end

  # Returns the value of attribute line_number.
  def line_number; end

  # Sets the attribute line_number
  #
  # @param value the value to set the attribute line_number to.
  def line_number=(_arg0); end

  def merge_custom_attributes_from_notice_error(merged_attributes); end
  def merge_custom_attributes_from_transaction(merged_attributes); end

  # We can get custom attributes from two sources--the transaction, which we
  # hold in @attributes, or passed options to notice_error which show up in
  # in our Attributes class for consistent handling
  def merged_custom_attributes(merged_attributes); end

  # Returns the value of attribute message.
  def message; end

  # Sets the attribute message
  #
  # @param value the value to set the attribute message to.
  def message=(_arg0); end

  # Returns the value of attribute path.
  def path; end

  # Sets the attribute path
  #
  # @param value the value to set the attribute path to.
  def path=(_arg0); end

  # Note that we process attributes lazily and store the result. This is because
  # there is a possibility that a noticed error will be discarded and not sent back
  # as a traced error or TransactionError.
  def processed_attributes; end

  # Returns the value of attribute request_port.
  def request_port; end

  # Sets the attribute request_port
  #
  # @param value the value to set the attribute request_port to.
  def request_port=(_arg0); end

  # Returns the value of attribute request_uri.
  def request_uri; end

  # Sets the attribute request_uri
  #
  # @param value the value to set the attribute request_uri to.
  def request_uri=(_arg0); end

  # Returns the value of attribute stack_trace.
  def stack_trace; end

  # Sets the attribute stack_trace
  #
  # @param value the value to set the attribute stack_trace to.
  def stack_trace=(_arg0); end

  # Returns the value of attribute timestamp.
  def timestamp; end

  # Sets the attribute timestamp
  #
  # @param value the value to set the attribute timestamp to.
  def timestamp=(_arg0); end

  def to_collector_array(encoder = T.unsafe(nil)); end

  class << self
    def passes_message_allowlist(exception_class); end
  end
end

NewRelic::NoticedError::AGENT_ATTRIBUTES = T.let(T.unsafe(nil), String)
NewRelic::NoticedError::DESTINATION = T.let(T.unsafe(nil), Integer)
NewRelic::NoticedError::ERROR_CLASS_KEY = T.let(T.unsafe(nil), String)
NewRelic::NoticedError::ERROR_EXPECTED_KEY = T.let(T.unsafe(nil), String)
NewRelic::NoticedError::ERROR_MESSAGE_KEY = T.let(T.unsafe(nil), String)
NewRelic::NoticedError::ERROR_PREFIX_KEY = T.let(T.unsafe(nil), String)
NewRelic::NoticedError::INTRINSIC_ATTRIBUTES = T.let(T.unsafe(nil), String)
NewRelic::NoticedError::NIL_ERROR_MESSAGE = T.let(T.unsafe(nil), String)
NewRelic::NoticedError::STRIPPED_EXCEPTION_REPLACEMENT_MESSAGE = T.let(T.unsafe(nil), String)
NewRelic::NoticedError::UNKNOWN_ERROR_CLASS_NAME = T.let(T.unsafe(nil), String)
NewRelic::NoticedError::USER_ATTRIBUTES = T.let(T.unsafe(nil), String)
NewRelic::PRIORITY_PRECISION = T.let(T.unsafe(nil), Integer)
class NewRelic::Railtie < ::Rails::Railtie; end

module NewRelic::SupportabilityHelper
  def record_api_supportability_metric(method_name); end

  # @return [Boolean]
  def valid_api_argument_class?(arg, name, klass); end
end

# pre-instantiate these strings as they may be used multiple times per
# transaction, just to eke out a bit less performance hit
NewRelic::SupportabilityHelper::API_SUPPORTABILITY_METRICS = T.let(T.unsafe(nil), Hash)

NewRelic::SupportabilityHelper::API_SUPPORTABILITY_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::TRACEPARENT_KEY = T.let(T.unsafe(nil), String)
NewRelic::TRACESTATE_KEY = T.let(T.unsafe(nil), String)
NewRelic::UNKNOWN = T.let(T.unsafe(nil), String)
module NewRelic::VERSION; end
NewRelic::VERSION::MAJOR = T.let(T.unsafe(nil), Integer)
NewRelic::VERSION::MINOR = T.let(T.unsafe(nil), Integer)
NewRelic::VERSION::STRING = T.let(T.unsafe(nil), String)
NewRelic::VERSION::TINY = T.let(T.unsafe(nil), Integer)
