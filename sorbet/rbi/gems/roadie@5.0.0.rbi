# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `roadie` gem.
# Please instead update this file by running `bin/tapioca gem roadie`.

module Roadie; end

# This module can be included in your own code to help you implement the
# standard behavior for asset providers.
#
# It helps you by declaring {#find_stylesheet!} in the terms of #find_stylesheet in your own class.
module Roadie::AssetProvider
  def find_stylesheet!(name); end
end

# The asset scanner's main usage is finding and/or extracting styles from a
# DOM tree. Referenced styles will be found using the provided asset
# provider.
#
# Any style declaration tagged with +data-roadie-ignore+ will be ignored,
# except for having the attribute itself removed.
#
# @api private
class Roadie::AssetScanner
  # @api private
  # @param dom [Nokogiri::HTML::Document]
  # @param normal_asset_provider [#find_stylesheet!]
  # @param external_asset_provider [#find_stylesheet!]
  # @return [AssetScanner] a new instance of AssetScanner
  def initialize(dom, normal_asset_provider, external_asset_provider); end

  # @api private
  def dom; end

  # @api private
  def external_asset_provider; end

  # Looks for all non-ignored stylesheets, removes their references from the
  # DOM and then returns them.
  #
  # This will mutate the DOM tree.
  #
  # The order of the array corresponds with the document order in the DOM.
  #
  # @api private
  # @return [Enumerable<Stylesheet>] every extracted stylesheet
  # @see #find_css
  def extract_css; end

  # Looks for all non-ignored stylesheets and returns them.
  #
  # This method will *not* mutate the DOM and is safe to call multiple times.
  #
  # The order of the array corresponds with the document order in the DOM.
  #
  # @api private
  # @return [Enumerable<Stylesheet>] every found stylesheet
  # @see #extract_css
  def find_css; end

  # @api private
  def normal_asset_provider; end

  private

  # @api private
  def clean_css(css); end

  # @api private
  def read_link_element(element); end

  # @api private
  def read_style_element(element); end

  # @api private
  def read_stylesheet(element); end

  # @api private
  # @return [Boolean]
  def should_find_external?; end
end

# Cleans out stupid CDATA and/or HTML comments from the style text
# TinyMCE causes this, allegedly
#
# @api private
Roadie::AssetScanner::CLEANING_MATCHER = T.let(T.unsafe(nil), Regexp)

# @api private
Roadie::AssetScanner::STYLE_ELEMENT_QUERY = T.let(T.unsafe(nil), String)

# The {CachedProvider} wraps another provider (or {ProviderList}) and caches
# the response from it.
#
# The default cache store is a instance-specific hash that lives for the
# entire duration of the instance. If you want to share hash between
# instances, pass your own hash-like object. Just remember to not allow this
# cache to grow without bounds, which a shared hash would do.
#
# Not found assets are not cached currently, but it's possible to extend this
# class in the future if there is a need for it. Remember this if you have
# providers with very slow failures.
#
# The cache store must accept {Roadie::Stylesheet} instances, and return such
# instances when fetched. It must respond to `#[name]` and `#[name]=` to
# retrieve and set entries, respectively. The `#[name]=` method also needs to
# return the instance again.
#
# @api public
# @example Global cache
#   Application.asset_cache = Hash.new
#   slow_provider = MyDatabaseProvider.new(Application)
#   provider = Roadie::CachedProvider.new(slow_provider, Application.asset_cache)
# @example Custom cache store
#   class MyRoadieMemcacheStore
#   def initialize(memcache)
#   @memcache = memcache
#   end
#
#   def [](path)
#   css = memcache.read("assets/#{path}/css")
#   if css
#   name = memcache.read("assets/#{path}/name") || "cached #{path}"
#   Roadie::Stylesheet.new(name, css)
#   end
#   end
#
#   def []=(path, stylesheet)
#   memcache.write("assets/#{path}/css", stylesheet.to_s)
#   memcache.write("assets/#{path}/name", stylesheet.name)
#   stylesheet # You need to return the set Stylesheet
#   end
#   end
class Roadie::CachedProvider
  # @api public
  # @param upstream [an asset provider] The wrapped asset provider
  # @param cache [#[], #[]=] The cache store to use.
  # @return [CachedProvider] a new instance of CachedProvider
  def initialize(upstream, cache = T.unsafe(nil)); end

  # The cache store used by this instance.
  #
  # @api public
  def cache; end

  # @api public
  def find_stylesheet(name); end

  # @api public
  def find_stylesheet!(name); end

  private

  # @api public
  def cache_fetch(name); end
end

# Raised when an asset provider cannot find a stylesheet.
#
# If you are writing your own asset provider, make sure to raise this in the
# +#find_stylesheet!+ method.
#
# @see AssetProvider
class Roadie::CssNotFound < ::Roadie::Error
  # @return [CssNotFound] a new instance of CssNotFound
  def initialize(css_name:, message: T.unsafe(nil), provider: T.unsafe(nil)); end

  # The name of the stylesheet that cannot be found
  def css_name; end

  # Extra message
  def extra_message; end

  # Provider used when finding
  def provider; end

  protected

  def error_row; end

  private

  def build_message; end
end

class Roadie::Deduplicator
  # @return [Deduplicator] a new instance of Deduplicator
  def initialize(input); end

  def apply; end

  private

  def calculate_latest_occurance; end

  # @return [Boolean]
  def has_duplicates?; end

  # Returns the value of attribute input.
  def input; end

  # Returns the value of attribute latest_occurance.
  def latest_occurance; end

  def strip_out_duplicates; end

  class << self
    def apply(input); end
  end
end

# The main entry point for Roadie. A document represents a working unit and
# is built with the input HTML and the configuration options you need.
#
# A Document must never be used from two threads at the same time. Reusing
# Documents is discouraged.
#
# Stylesheets are added to the HTML from three different sources:
# 1. Stylesheets inside the document ( +<style>+ elements)
# 2. Stylesheets referenced by the DOM ( +<link>+ elements)
# 3. The internal stylesheet (see {#add_css})
#
# The internal stylesheet is used last and gets the highest priority. The
# rest is used in the same order as browsers are supposed to use them.
#
# The execution methods are {#transform} and {#transform_partial}.
#
# @attr before_transformation [#call] Callback to call just before {#transform}ation begins. Will be called with the parsed DOM tree and the {Document} instance.
# @attr after_transformation [#call] Callback to call just before {#transform}ation is completed. Will be called with the current DOM tree and the {Document} instance.
class Roadie::Document
  # @param html [String] the input HTML
  # @return [Document] a new instance of Document
  def initialize(html); end

  # Append additional CSS to the document's internal stylesheet.
  #
  # @param new_css [String]
  def add_css(new_css); end

  # Callback to call just before {#transform}ation is completed. Will be called with the current DOM tree and the {Document} instance.
  #
  # @return [#call] the current value of after_transformation
  def after_transformation; end

  # Callback to call just before {#transform}ation is completed. Will be called with the current DOM tree and the {Document} instance.
  #
  # @param value [#call] the value to set the attribute after_transformation to.
  # @return [#call] the newly set value
  def after_transformation=(_arg0); end

  # Returns the value of attribute asset_providers.
  def asset_providers; end

  # Assign new normal asset providers. The supplied list will be wrapped in a {ProviderList} using {ProviderList.wrap}.
  def asset_providers=(list); end

  # Callback to call just before {#transform}ation begins. Will be called with the parsed DOM tree and the {Document} instance.
  #
  # @return [#call] the current value of before_transformation
  def before_transformation; end

  # Callback to call just before {#transform}ation begins. Will be called with the parsed DOM tree and the {Document} instance.
  #
  # @param value [#call] the value to set the attribute before_transformation to.
  # @return [#call] the newly set value
  def before_transformation=(_arg0); end

  # Returns the value of attribute external_asset_providers.
  def external_asset_providers; end

  # Assign new external asset providers. The supplied list will be wrapped in a {ProviderList} using {ProviderList.wrap}.
  def external_asset_providers=(list); end

  # Returns the value of attribute html.
  def html; end

  # Should CSS that cannot be inlined be kept in a new `<style>` element in `<head>`?
  def keep_uninlinable_css; end

  # Should CSS that cannot be inlined be kept in a new `<style>` element in `<head>`?
  def keep_uninlinable_css=(_arg0); end

  # Merge media queries to increase performance and reduce email size if enabled.
  # This will change specificity in some cases, like for example:
  #   @media(max-width: 600px) { .col-6 { display: block; } }
  #   @media(max-width: 400px) { .col-12 { display: inline-block; } }
  #   @media(max-width: 600px) { .col-12 { display: block; } }
  # will become
  #   @media(max-width: 600px) { .col-6 { display: block; } .col-12 { display: block; } }
  #   @media(max-width: 400px) { .col-12 { display: inline-block; } }
  # which would change the styling on the page
  def merge_media_queries; end

  # Merge media queries to increase performance and reduce email size if enabled.
  # This will change specificity in some cases, like for example:
  #   @media(max-width: 600px) { .col-6 { display: block; } }
  #   @media(max-width: 400px) { .col-12 { display: inline-block; } }
  #   @media(max-width: 600px) { .col-12 { display: block; } }
  # will become
  #   @media(max-width: 600px) { .col-6 { display: block; } .col-12 { display: block; } }
  #   @media(max-width: 400px) { .col-12 { display: inline-block; } }
  # which would change the styling on the page
  def merge_media_queries=(_arg0); end

  # The mode to generate markup in. Valid values are `:html` (default) and `:xhtml`.
  def mode; end

  # Change the mode. The mode affects how the resulting markup is generated.
  #
  # Valid modes:
  #   `:html` (default)
  #   `:xhtml`
  #   `:xml`
  def mode=(mode); end

  # Transform the input HTML as a full document and returns the processed
  # HTML.
  #
  # Before the transformation begins, the {#before_transformation} callback
  # will be called with the parsed HTML tree and the {Document} instance, and
  # after all work is complete the {#after_transformation} callback will be
  # invoked in the same way.
  #
  # Most of the work is delegated to other classes. A list of them can be
  # seen below.
  #
  # @return [String] the transformed HTML
  # @see MarkupImprover MarkupImprover (improves the markup of the DOM)
  # @see Inliner Inliner (inlines the stylesheets)
  # @see UrlRewriter UrlRewriter (rewrites URLs and makes them absolute)
  # @see #transform_partial Transforms partial documents (fragments)
  def transform; end

  # Transform the input HTML as a HTML fragment/partial and returns the
  # processed HTML.
  #
  # Before the transformation begins, the {#before_transformation} callback
  # will be called with the parsed HTML tree and the {Document} instance, and
  # after all work is complete the {#after_transformation} callback will be
  # invoked in the same way.
  #
  # The main difference between this and {#transform} is that this does not
  # treat the HTML as a full document and does not try to fix it by adding
  # doctypes, {<head>} elements, etc.
  #
  # Most of the work is delegated to other classes. A list of them can be
  # seen below.
  #
  # @return [String] the transformed HTML
  # @see Inliner Inliner (inlines the stylesheets)
  # @see UrlRewriter UrlRewriter (rewrites URLs and makes them absolute)
  # @see #transform Transforms full documents
  def transform_partial; end

  # URL options. If none are given no URL rewriting will take place.
  #
  # @see UrlGenerator#initialize
  def url_options; end

  # URL options. If none are given no URL rewriting will take place.
  #
  # @see UrlGenerator#initialize
  def url_options=(_arg0); end

  private

  def callback(callable, dom); end
  def improve(dom); end
  def inline(dom, options = T.unsafe(nil)); end
  def make_url_rewriter; end
  def remove_ignore_markers(dom); end
  def rewrite_urls(dom); end
  def serialize_document(dom); end
  def stylesheet; end
end

Roadie::Document::VALID_MODES = T.let(T.unsafe(nil), Array)

# Base class for all Roadie errors. Rescue this if you want to catch errors
# from Roadie.
#
# If Roadie raises an error that does not inherit this class, please report
# it as a bug.
class Roadie::Error < ::RuntimeError; end

# Asset provider that looks for files on your local filesystem.
#
# It will be locked to a specific path and it will not access files above
# that directory.
class Roadie::FilesystemProvider
  # @return [FilesystemProvider] a new instance of FilesystemProvider
  def initialize(path = T.unsafe(nil)); end

  # @return [Stylesheet, nil]
  def find_stylesheet(name); end

  # @raise InsecurePathError
  # @return [Stylesheet]
  def find_stylesheet!(name); end

  def inspect; end

  # Returns the value of attribute path.
  def path; end

  def to_s; end

  private

  # @raise [InsecurePathError]
  def build_file_path(name); end
end

# Raised when FilesystemProvider is asked to access a file that lies above
# the base path.
class Roadie::FilesystemProvider::InsecurePathError < ::Roadie::Error; end

# The Inliner inlines stylesheets to the elements of the DOM.
#
# Inlining means that {StyleBlock}s and a DOM tree are combined:
#
# ```css
# a { color: red; } # StyleBlock
# ```
# ```html
# <a href="/"></a>  # DOM
# ```
#
# becomes
#
# ```html
# <a href="/" style="color:red"></a>
# ```
#
# @api private
class Roadie::Inliner
  # @api private
  # @param stylesheets [Array<Stylesheet>] the stylesheets to use in the inlining
  # @param dom [Nokogiri::HTML::Document]
  # @return [Inliner] a new instance of Inliner
  def initialize(stylesheets, dom); end

  # Start the inlining, mutating the DOM tree.
  #
  # @api private
  # @option options
  # @option options
  # @option options
  # @param options [Hash] a customizable set of options
  # @return [nil]
  def inline(options = T.unsafe(nil)); end

  protected

  # @api private
  def dom; end

  # @api private
  def stylesheets; end

  private

  # Adds unlineable styles in the specified part of the document
  # either the head or in the document
  #
  # @api private
  # @param parent [Symbol] Where to put the styles
  # @param blocks [Array<StyleBlock>] Non-inlineable style blocks
  # @param merge_media_queries [Boolean] Whether to group media queries
  def add_uninlinable_styles(parent, blocks, merge_media_queries); end

  # @api private
  def apply_element_style(element, builder); end

  # @api private
  def apply_style_map(style_map); end

  # @api private
  def consume_stylesheets; end

  # @api private
  def create_style_element(style_blocks, parent, merge_media_queries); end

  # @api private
  def each_style_block; end

  # @api private
  def elements_matching_selector(stylesheet, selector); end

  # @api private
  def find_head; end

  # @api private
  def selector_elements(stylesheet, block); end

  # Some users might prefer to not group rules within media queries because
  # it will result in rules getting reordered.
  # e.g.
  #
  # ```css
  # @media(max-width: 600px) { .col-6 { display: block; } }
  # @media(max-width: 400px) { .col-12 { display: inline-block; } }
  # @media(max-width: 600px) { .col-12 { display: block; } }
  # ````
  #
  # will become
  #
  # ```css
  # @media(max-width: 600px) { .col-6 { display: block; } .col-12 { display: block; } }
  # @media(max-width: 400px) { .col-12 { display: inline-block; } }
  # ```
  #
  #
  # which would change the styling on the page
  # (before it would've yielded display: block; for .col-12 at max-width: 600px
  # and now it yields inline-block;)
  #
  # If merge_media_queries is set to false,
  # we will generate `style_blocks.size` media queries, potentially
  # causing performance issues.
  #
  # @api private
  # @param style_blocks [Array<StyleBlock>] All style blocks
  # @return [Array<String>]
  def styles_in_individual_media_queries(style_blocks); end

  # For performance reasons, we should group styles with the same media types within
  # one media query instead of creating thousands of media queries.
  # https://github.com/artifex404/media-queries-benchmark
  #
  # Example result:
  #
  # ```ruby
  # ["@media(max-width: 600px) { .col-12 { display: block; } }"]
  # ```
  #
  # @api private
  # @param style_blocks [Array<StyleBlock>] Style blocks that could not be inlined
  # @return [Array<String>]
  def styles_in_shared_media_queries(style_blocks); end
end

# StyleMap is a map between a DOM element and {StyleAttributeBuilder}. Basically,
# it's an accumulator for properties, scoped on specific elements.
#
# @api private
class Roadie::Inliner::StyleMap
  # @api private
  # @return [StyleMap] a new instance of StyleMap
  def initialize; end

  # @api private
  def add(elements, new_properties); end

  # @api private
  def each_element(&block); end
end

# Raised when Roadie encounters an invalid URL which cannot be parsed by
# Ruby's +URI+ class.
#
# This could be a hint that something in your HTML or CSS is broken.
class Roadie::InvalidUrlPath < ::Roadie::Error
  # @return [InvalidUrlPath] a new instance of InvalidUrlPath
  def initialize(given_path, cause = T.unsafe(nil)); end

  # The original error, raised from +URI+.
  def cause; end
end

# Class that improves the markup of a HTML DOM tree
#
# This class will improve the following aspects of the DOM:
# * A HTML5 doctype will be added if missing, other doctypes will be left as-is.
# * Basic HTML elements will be added if missing.
#   * `<html>`
#   * `<head>`
#   * `<body>`
#   * `<meta>` declaring charset and content-type (text/html)
#
# @api private
class Roadie::MarkupImprover
  # The original HTML must also be passed in in order to handle the doctypes
  # since a +Nokogiri::HTML::Document+ will always have a doctype, no matter if
  # the original source had it or not. Reading the raw HTML is the only way to
  # determine if we want to add a HTML5 doctype or not.
  #
  # @api private
  # @return [MarkupImprover] a new instance of MarkupImprover
  def initialize(dom, original_html); end

  # @api private
  # @return [nil] passed DOM will be mutated
  def improve; end

  protected

  # @api private
  def dom; end

  private

  # @api private
  # @return [Boolean]
  def content_type_meta_element_missing?; end

  # @api private
  def create_head_element(parent); end

  # @api private
  def ensure_declared_charset(parent); end

  # @api private
  def ensure_doctype_present; end

  # @api private
  def ensure_head_element_present; end

  # @api private
  def ensure_html_element_present; end

  # @api private
  def make_content_type_element; end
end

# External asset provider that downloads stylesheets from some other server
# using Ruby's built-in {Net::HTTP} library.
#
# You can pass a whitelist of hosts that downloads are allowed on.
#
# @api public
# @example Allowing all downloads
#   provider = Roadie::NetHttpProvider.new
# @example Only allowing your own app domains
#   provider = Roadie::NetHttpProvider.new(
#   whitelist: ["myapp.com", "assets.myapp.com", "www.myapp.com"]
#   )
class Roadie::NetHttpProvider
  # @api public
  # @option options
  # @param options [Hash] a customizable set of options
  # @return [NetHttpProvider] a new instance of NetHttpProvider
  def initialize(options = T.unsafe(nil)); end

  # @api public
  def find_stylesheet(url); end

  # @api public
  def find_stylesheet!(url); end

  # @api public
  def inspect; end

  # @api public
  def to_s; end

  # @api public
  def whitelist; end

  private

  # @api public
  # @return [Boolean]
  def access_granted_to?(host); end

  # @api public
  def download(url); end

  # @api public
  def get_response(uri); end

  # @api public
  def host_set(hosts); end

  # @api public
  def response_body(response); end

  # @api public
  def truncate(string); end

  # @api public
  def validate_host(host); end
end

# An asset provider that returns empty stylesheets for any name.
#
# Use it to ignore missing assets or in your tests when you need a provider
# but you do not care what it contains or that it is even referenced at all.
class Roadie::NullProvider
  def find_stylesheet(name); end
  def find_stylesheet!(name); end
  def inspect; end
  def to_s; end

  private

  def empty_stylesheet; end
end

# Null Object for the URL rewriter role.
#
# Used whenever client does not pass any URL options and no URL rewriting
# should take place.
#
# @api private
class Roadie::NullUrlRewriter
  # @api private
  # @return [NullUrlRewriter] a new instance of NullUrlRewriter
  def initialize(generator = T.unsafe(nil)); end

  # @api private
  def transform_css(css); end

  # @api private
  def transform_dom(dom); end
end

# This provider acts a bit like a pipeline in normal UNIX parlour by enabling
# you to make changes to the requested path. Some uses of this include:
#
#   * Convert absolute URLs into local filesystem paths.
#   * Convert between external DNS name into internal naming.
#   * Changing path structure of filenames.
#   * Removing digests from filenames.
#   * Handle query string logic.
#   * Skipping known-bad paths.
#
# There might be other useful things you could use it for. The basic premise
# is that a path is sent in to this provider, maybe modified and then passed
# on to the "upstream" provider (or {ProviderList}).
#
# If the block returns {nil} or {false}, the upstream provider will not be
# invoked and it will be treated as "not found". This makes it possible to
# use this provider as a filter only.
#
# @api public
# @example Simple regex
#   provider = Roadie::PathRewriterProvider.new(other_provider) { |path|
#   path.gsub(/-[a-f0-9]+\.css$/, '.css')
#   }
# @example Filtering assets
#   # Only assets containing "email" in the path will be considered by other_provider
#   only_email_provider = Roadie::PathRewriterProvider.new(other_provider) { |path|
#   path =~ /email/ ? path : nil
#   }
# @example Handling "external" app assets as local assets
#   document.external_asset_providers = [
#   # Look for assets from "myapp.com" just like if we just specified a local path
#   Roadie::PathRewriterProvider.new(document.asset_providers) { |url|
#   uri = URI.parse(url)
#   uri.path if uri.host == "myapp.com"
#   },
#   # Any other asset should be downloaded like normal
#   Roadie::NetHttpProvider.new
#   ]
class Roadie::PathRewriterProvider
  # @api public
  # @return [PathRewriterProvider] a new instance of PathRewriterProvider
  def initialize(provider, &filter); end

  # @api public
  def filter; end

  # @api public
  def find_stylesheet(path); end

  # @api public
  def find_stylesheet!(path); end

  # @api public
  def provider; end
end

# An asset provider that just composes a list of other asset providers.
#
# Give it a list of providers and they will all be tried in order.
#
# {ProviderList} behaves like an Array, *and* an asset provider, and can be coerced into an array.
class Roadie::ProviderList
  include ::Enumerable
  extend ::Forwardable

  # @return [ProviderList] a new instance of ProviderList
  def initialize(providers); end

  # @see Array#<<
  def <<(*args, **_arg1, &block); end

  # @see Array#each
  def each(*args, **_arg1, &block); end

  # @see Array#empty?
  def empty?(*args, **_arg1, &block); end

  # @return [Stylesheet, nil]
  def find_stylesheet(name); end

  # Tries to find the given stylesheet and raises an {ProvidersFailed} error
  # if no provider could find the asset.
  #
  # @raise [ProvidersFailed]
  # @return [Stylesheet]
  def find_stylesheet!(name); end

  # @see Array#last
  def last(*args, **_arg1, &block); end

  # @see Array#pop
  def pop(*args, **_arg1, &block); end

  # @see Array#push
  def push(*args, **_arg1, &block); end

  # @see Array#shift
  def shift(*args, **_arg1, &block); end

  # @see Array#size
  def size(*args, **_arg1, &block); end

  # ProviderList can be coerced to an array. This makes Array#flatten work
  # with it, among other things.
  def to_ary; end

  def to_s; end

  # @see Array#unshift
  def unshift(*args, **_arg1, &block); end

  class << self
    # Returns a new empty list.
    def empty; end

    # Wrap a single provider, or a list of providers into a {ProviderList}.
    #
    # @overload wrap
    # @overload wrap
    # @overload wrap
    def wrap(*providers); end
  end
end

class Roadie::ProvidersFailed < ::Roadie::CssNotFound
  # @return [ProvidersFailed] a new instance of ProvidersFailed
  def initialize(css_name:, providers:, errors:); end

  # Returns the value of attribute errors.
  def errors; end

  private

  def build_message; end
  def each_error_row(errors); end
end

# A selector is a domain object for a CSS selector, such as:
#   body
#   a:hover
#   input::placeholder
#   p:nth-of-child(4n+1) .important a img
#
# "Selectors" such as "strong, em" are actually two selectors and should be
# represented as two instances of this class.
#
# This class can also calculate specificity for the selector and answer a few
# questions about them.
#
# Selectors can be coerced into Strings, so they should be transparent to use
# anywhere a String is expected.
#
# @api private
class Roadie::Selector
  # @api private
  # @return [Selector] a new instance of Selector
  def initialize(selector, specificity = T.unsafe(nil)); end

  # {Selector}s are equal to other {Selector}s if, and only if, their string
  # representations are equal.
  #
  # @api private
  def ==(other); end

  # Returns whenever or not a selector can be inlined.
  # It's impossible to inline properties that applies to a pseudo element
  # (like +::placeholder+, +::before+) or a pseudo function (like +:active+).
  #
  # We cannot inline styles that appear inside "@" constructs, like +@keyframes+.
  #
  # @api private
  # @return [Boolean]
  def inlinable?; end

  # @api private
  def inspect; end

  # Returns the specificity of the selector, calculating it if needed.
  #
  # @api private
  def specificity; end

  # @api private
  def to_s; end

  # @api private
  def to_str; end

  protected

  # @api private
  def selector; end

  private

  # @api private
  # @return [Boolean]
  def at_rule?; end

  # @api private
  # @return [Boolean]
  def pseudo_element?; end

  # @api private
  # @return [Boolean]
  def pseudo_function?; end
end

# @api private
Roadie::Selector::BAD_PSEUDO_FUNCTIONS = T.let(T.unsafe(nil), Array)

class Roadie::StyleAttributeBuilder
  # @return [StyleAttributeBuilder] a new instance of StyleAttributeBuilder
  def initialize; end

  def <<(style); end
  def attribute_string; end

  private

  def stable_sort(list); end
end

# A style block is the combination of a {Selector} and a list of {StyleProperty}.
#
# @api private
class Roadie::StyleBlock
  extend ::Forwardable

  # @api private
  # @param selector [Selector]
  # @param properties [Array<StyleProperty>]
  # @param media [Array<String>] Array of media types, e.g.
  #   @media screen, print and (max-width 800px) will become
  #   ['screen', 'print and (max-width 800px)']
  # @return [StyleBlock] a new instance of StyleBlock
  def initialize(selector, properties, media); end

  # Checks whether the media query can be inlined
  #
  # @api private
  # @return [Boolean]
  # @see inlineable_media
  def inlinable?; end

  # @api private
  def media; end

  # @api private
  def properties; end

  # @api private
  def selector; end

  # @see Selector#to_s
  def selector_string(*args, **_arg1, &block); end

  # @see Selector#specificity
  def specificity(*args, **_arg1, &block); end

  # String representation of the style block. This is valid CSS and can be
  # used in the DOM.
  #
  # @api private
  # @return [String]
  def to_s; end

  private

  # A media query cannot be inlined if it contains any advanced rules
  # e.g. @media only screen {...} is ok to inline but
  #
  # @api private
  # @return [Boolean]
  def inlinable_media?; end
end

# Domain object for a CSS property such as "color: red !important".
#
# @api private
# @attr_reader property [String] name of the property (such as "font-size").
# @attr_reader value [String] value of the property (such as "5px solid green").
# @attr_reader important [Boolean] if the property is "!important".
# @attr_reader specificity [Integer] specificity of parent {Selector}. Used to compare/sort.
class Roadie::StyleProperty
  include ::Comparable

  # @api private
  # @return [StyleProperty] a new instance of StyleProperty
  def initialize(property, value, important, specificity); end

  # Compare another {StyleProperty}. Important styles are "greater than"
  # non-important ones; otherwise the specificity declares order.
  #
  # @api private
  def <=>(other); end

  # if the property is "!important".
  #
  # @api private
  # @return [Boolean] the current value of important
  def important; end

  # @api private
  # @return [Boolean]
  def important?; end

  # @api private
  def inspect; end

  # @api private
  # @todo Rename #property to #name
  def property; end

  # specificity of parent {Selector}. Used to compare/sort.
  #
  # @api private
  # @return [Integer] the current value of specificity
  def specificity; end

  # @api private
  def to_s; end

  # value of the property (such as "5px solid green").
  #
  # @api private
  # @return [String] the current value of value
  def value; end

  private

  # @api private
  def value_with_important; end
end

# Domain object that represents a stylesheet (from disc, perhaps).
#
# It has a name and a list of {StyleBlock}s.
#
# @attr_reader name [String] the name of the stylesheet ("stylesheets/main.css", "Admin user styles", etc.). The name of the stylesheet will be visible if any errors occur.
# @attr_reader blocks [Array<StyleBlock>]
class Roadie::Stylesheet
  # Parses the CSS string into a {StyleBlock}s and stores it.
  #
  # @param name [String]
  # @param css [String]
  # @return [Stylesheet] a new instance of Stylesheet
  def initialize(name, css); end

  # @return [Array<StyleBlock>] the current value of blocks
  def blocks; end

  # the name of the stylesheet ("stylesheets/main.css", "Admin user styles", etc.). The name of the stylesheet will be visible if any errors occur.
  #
  # @return [String] the current value of name
  def name; end

  def to_s; end

  private

  def create_style_block(selector_string, rule_set, media_types); end
  def inlinable_blocks; end
  def parse_blocks(css); end
  def setup_parser(css); end
end

Roadie::Stylesheet::BOM = T.let(T.unsafe(nil), String)

# Class that handles URL generation
#
# URL generation is all about converting relative URLs into absolute URLS
# according to the given options. It is written such as absolute URLs will
# get passed right through, so all URLs could be passed through here.
#
# @api private
class Roadie::UrlGenerator
  # Create a new instance with the given URL options.
  #
  # Initializing without a host setting raises an error, as do unknown keys.
  #
  # @api private
  # @option url_options
  # @option url_options
  # @option url_options
  # @option url_options
  # @option url_options
  # @param url_options [Hash]
  # @return [UrlGenerator] a new instance of UrlGenerator
  def initialize(url_options); end

  # Generate an absolute URL from a relative URL.
  #
  # If the passed path is already an absolute URL or just an anchor
  # reference, it will be returned as-is.
  # If passed a blank path, the "root URL" will be returned. The root URL is
  # the URL that the {#url_options} would generate by themselves.
  #
  # An optional base can be specified. The base is another relative path from
  # the root that specifies an "offset" from which the path was found in. A
  # common use-case is to convert a relative path found in a stylesheet which
  # resides in a subdirectory.
  #
  # @api private
  # @example Normal conversions
  #   generator = Roadie::UrlGenerator.new host: "foo.com", scheme: "https"
  #   generator.generate_url("bar.html") # => "https://foo.com/bar.html"
  #   generator.generate_url("/bar.html") # => "https://foo.com/bar.html"
  #   generator.generate_url("") # => "https://foo.com"
  # @example Conversions with a base
  #   generator = Roadie::UrlGenerator.new host: "foo.com", scheme: "https"
  #   generator.generate_url("../images/logo.png", "/css") # => "https://foo.com/images/logo.png"
  #   generator.generate_url("../images/logo.png", "/assets/css") # => "https://foo.com/assets/images/logo.png"
  # @param base [String] The base which the relative path comes from
  # @return [String] an absolute URL
  def generate_url(path, base = T.unsafe(nil)); end

  # @api private
  def url_options; end

  protected

  # @api private
  def root_uri; end

  # @api private
  def scheme; end

  private

  # @api private
  def add_scheme(path); end

  # @api private
  def apply_base(base, path); end

  # @api private
  def build_root_uri; end

  # @api private
  def combine_segments(root, base, path); end

  # @api private
  def make_absolute(path); end

  # Strip :// from any scheme, if present
  #
  # @api private
  def normalize_scheme(scheme); end

  # @api private
  def parse_port(port); end

  # @api private
  # @return [Boolean]
  def path_is_anchor?(path); end

  # @api private
  # @return [Boolean]
  def path_is_schemeless?(path); end

  # @api private
  def validate_options(options); end
end

# @api private
Roadie::UrlGenerator::VALID_OPTIONS = T.let(T.unsafe(nil), Set)

# Class that rewrites URLs in the DOM.
#
# @api private
class Roadie::UrlRewriter
  # @api private
  # @param generator [UrlGenerator]
  # @return [UrlRewriter] a new instance of UrlRewriter
  def initialize(generator); end

  # Mutates passed CSS, rewriting url() directives.
  #
  # This will make all URLs inside url() absolute.
  #
  # Copy of CSS that is mutated is returned, passed string is not mutated.
  #
  # @api private
  # @param css [String] the css to mutate
  # @return [String] copy of css that is mutated
  def transform_css(css); end

  # Mutates the passed DOM tree, rewriting certain element's attributes.
  #
  # This will make all a[href] and img[src] into absolute URLs, as well as
  # all "url()" directives inside style-attributes.
  #
  # [nil] is returned so no one can misunderstand that this method mutates
  # the passed instance.
  #
  # @api private
  # @param dom [Nokogiri::HTML::Document]
  # @return [nil] DOM tree is mutated
  def transform_dom(dom); end

  private

  # @api private
  def generate_url(*args); end

  # @api private
  def transform_element(element); end

  # @api private
  def transform_element_style(element); end
end

# Regexp matching all the url() declarations in CSS
#
# It matches without any quotes and with both single and double quotes
# inside the parenthesis. There's much room for improvement, of course.
#
# @api private
Roadie::UrlRewriter::CSS_URL_REGEXP = T.let(T.unsafe(nil), Regexp)

module Roadie::Utils
  private

  # @api private
  # @return [Boolean]
  def path_is_absolute?(path); end

  # @api private
  def warn(message); end

  class << self
    # @api private
    # @return [Boolean]
    def path_is_absolute?(path); end

    # @api private
    def warn(message); end
  end
end

Roadie::VERSION = T.let(T.unsafe(nil), String)
