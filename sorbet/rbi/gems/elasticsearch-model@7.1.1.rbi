# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `elasticsearch-model` gem.
# Please instead update this file by running `bin/tapioca gem elasticsearch-model`.

module Elasticsearch; end

# Elasticsearch integration for Ruby models
# =========================================
#
# `Elasticsearch::Model` contains modules for integrating the Elasticsearch search and analytical engine
# with ActiveModel-based classes, or models, for the Ruby programming language.
#
# It facilitates importing your data into an index, automatically updating it when a record changes,
# searching the specific index, setting up the index mapping or the model JSON serialization.
#
# When the `Elasticsearch::Model` module is included in your class, it automatically extends it
# with the functionality; see {Elasticsearch::Model.included}. Most methods are available via
# the `__elasticsearch__` class and instance method proxies.
#
# It is possible to include/extend the model with the corresponding
# modules directly, if that is desired:
#
#     MyModel.__send__ :extend,  Elasticsearch::Model::Client::ClassMethods
#     MyModel.__send__ :include, Elasticsearch::Model::Client::InstanceMethods
#     MyModel.__send__ :extend,  Elasticsearch::Model::Searching::ClassMethods
#     # ...
module Elasticsearch::Model
  extend ::Elasticsearch::Model::ClassMethods
  include ::Elasticsearch::Model::Adapter::Default::Importing
  include ::Elasticsearch::Model::Proxy

  class << self
    # Adds the `Elasticsearch::Model` functionality to the including class.
    #
    # * Creates the `__elasticsearch__` class and instance method. These methods return a proxy object with
    #   other common methods defined on them.
    # * The module includes other modules with further functionality.
    # * Sets up delegation for common methods such as `import` and `search`.
    #
    # @example Include the module in the `Article` model definition
    #
    #   class Article < ActiveRecord::Base
    #   include Elasticsearch::Model
    #   end
    # @example Inject the module into the `Article` model during run time
    #
    #   Article.__send__ :include, Elasticsearch::Model
    def included(base); end
  end
end

# Contains an adapter which provides OxM-specific implementations for common behaviour:
#
# * {Adapter::Adapter#records_mixin   Fetching records from the database}
# * {Adapter::Adapter#callbacks_mixin Model callbacks for automatic index updates}
# * {Adapter::Adapter#importing_mixin Efficient bulk loading from the database}
#
# @see Elasticsearch::Model::Adapter::Default
# @see Elasticsearch::Model::Adapter::ActiveRecord
# @see Elasticsearch::Model::Adapter::Mongoid
module Elasticsearch::Model::Adapter
  private

  # Returns registered adapters
  #
  # @see ::Elasticsearch::Model::Adapter::Adapter.adapters
  def adapters; end

  # Returns an adapter based on the Ruby class passed
  #
  # @example Create an adapter for an ActiveRecord-based model
  #
  #   class Article < ActiveRecord::Base; end
  #
  #   myadapter = Elasticsearch::Model::Adapter.from_class(Article)
  #   myadapter.adapter
  #   # => Elasticsearch::Model::Adapter::ActiveRecord
  # @see Adapter.adapters The list of included adapters
  # @see Adapter.register Register a custom adapter
  def from_class(klass); end

  # Registers an adapter
  #
  # @see ::Elasticsearch::Model::Adapter::Adapter.register
  def register(name, condition); end

  class << self
    # Returns registered adapters
    #
    # @see ::Elasticsearch::Model::Adapter::Adapter.adapters
    def adapters; end

    # Returns an adapter based on the Ruby class passed
    #
    # @example Create an adapter for an ActiveRecord-based model
    #   class Article < ActiveRecord::Base; end
    #
    #   myadapter = Elasticsearch::Model::Adapter.from_class(Article)
    #   myadapter.adapter
    #   # => Elasticsearch::Model::Adapter::ActiveRecord
    # @see Adapter.adapters The list of included adapters
    # @see Adapter.register Register a custom adapter
    def from_class(klass); end

    # Registers an adapter
    #
    # @see ::Elasticsearch::Model::Adapter::Adapter.register
    def register(name, condition); end
  end
end

# An adapter for ActiveRecord-based models
module Elasticsearch::Model::Adapter::ActiveRecord; end

module Elasticsearch::Model::Adapter::ActiveRecord::Callbacks
  class << self
    # Handle index updates (creating, updating or deleting documents)
    # when the model changes, by hooking into the lifecycle
    #
    # @see http://guides.rubyonrails.org/active_record_callbacks.html
    def included(base); end
  end
end

module Elasticsearch::Model::Adapter::ActiveRecord::Importing
  # Fetch batches of records from the database (used by the import method)
  #
  # @see http://api.rubyonrails.org/classes/ActiveRecord/Batches.html ActiveRecord::Batches.find_in_batches
  def __find_in_batches(options = T.unsafe(nil), &block); end

  def __transform; end
end

module Elasticsearch::Model::Adapter::ActiveRecord::Records
  # Prevent clash with `ActiveSupport::Dependencies::Loadable`
  def load; end

  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  def options=(_arg0); end

  # Returns an `ActiveRecord::Relation` instance
  def records; end
end

# Contains an adapter for specific OxM or architecture.
class Elasticsearch::Model::Adapter::Adapter
  # @return [Adapter] a new instance of Adapter
  def initialize(klass); end

  # Returns the adapter module
  #
  # @api private
  def adapter; end

  # Return the module with {Default::Callbacks} interface implementation
  #
  # @api private
  def callbacks_mixin; end

  # Return the module with {Default::Importing} interface implementation
  #
  # @api private
  def importing_mixin; end

  # Returns the value of attribute klass.
  def klass; end

  # Return the module with {Default::Records} interface implementation
  #
  # @api private
  def records_mixin; end

  class << self
    # Return the collection of registered adapters
    #
    # @example Return the currently registered adapters
    #
    #   Elasticsearch::Model::Adapter.adapters
    #   # => {
    #   #  Elasticsearch::Model::Adapter::ActiveRecord => #<Proc:0x007...(lambda)>,
    #   #  Elasticsearch::Model::Adapter::Mongoid => #<Proc:0x007... (lambda)>,
    #   # }
    # @return [Hash] The collection of adapters
    def adapters; end

    # Registers an adapter for specific condition
    #
    # @example Register an adapter for DataMapper
    #
    #   module DataMapperAdapter
    #
    #   # Implement the interface for fetching records
    #   #
    #   module Records
    #   def records
    #   klass.all(id: @ids)
    #   end
    #
    #   # ...
    #   end
    #   end
    #
    #   # Register the adapter
    #   #
    #   Elasticsearch::Model::Adapter.register(
    #   DataMapperAdapter,
    #   lambda { |klass|
    #   defined?(::DataMapper::Resource) and klass.ancestors.include?(::DataMapper::Resource)
    #   }
    #   )
    # @param name [Module] The module containing the implemented interface
    # @param condition [Proc] An object with a `call` method which is evaluated in {.adapter}
    def register(name, condition); end
  end
end

# The default adapter for models which haven't one registered
module Elasticsearch::Model::Adapter::Default; end

# Module for implementing methods and logic related to hooking into model lifecycle
# (e.g. to perform automatic index updates)
#
# @see http://api.rubyonrails.org/classes/ActiveModel/Callbacks.html
module Elasticsearch::Model::Adapter::Default::Callbacks; end

# Module for efficiently fetching records from the database to import them into the index
module Elasticsearch::Model::Adapter::Default::Importing
  # @abstract Implement this method in your adapter
  # @raise [NotImplemented]
  def __find_in_batches(options = T.unsafe(nil), &block); end

  # @abstract Implement this method in your adapter
  # @raise [NotImplemented]
  def __transform; end
end

# Module for implementing methods and logic related to fetching records from the database
module Elasticsearch::Model::Adapter::Default::Records
  # Return the collection of records fetched from the database
  #
  # By default uses `MyModel#find[1, 2, 3]`
  def records; end
end

# An adapter for Mongoid-based models
#
# @see http://mongoid.org
module Elasticsearch::Model::Adapter::Mongoid; end

module Elasticsearch::Model::Adapter::Mongoid::Callbacks
  class << self
    # Handle index updates (creating, updating or deleting documents)
    # when the model changes, by hooking into the lifecycle
    #
    # @see http://mongoid.org/en/mongoid/docs/callbacks.html
    def included(base); end
  end
end

module Elasticsearch::Model::Adapter::Mongoid::Importing
  # Fetch batches of records from the database
  #
  # @see https://github.com/mongoid/mongoid/issues/1334
  # @see https://github.com/karmi/retire/pull/724
  def __find_in_batches(options = T.unsafe(nil), &block); end

  def __transform; end
end

module Elasticsearch::Model::Adapter::Mongoid::Records
  def asc(*args); end
  def desc(*args); end
  def order_by(*args); end

  # Return a `Mongoid::Criteria` instance
  def records; end
end

# An adapter to be used for deserializing results from multiple models,
# retrieved through `Elasticsearch::Model.search`
#
# @see Elasticsearch::Model.search
module Elasticsearch::Model::Adapter::Multiple; end

module Elasticsearch::Model::Adapter::Multiple::Records
  # Returns the adapter registered for a particular `klass` or `nil` if not available
  #
  # @api private
  def __adapter_for_klass(klass); end

  # Returns the record IDs grouped by class based on type `_type`
  #
  # Example:
  #
  #   { Foo => ["1"], Bar => ["1", "5"] }
  #
  # @api private
  def __ids_by_type; end

  # @return [Boolean]
  def __no_type?(hit); end

  # Â Returns the collection of records grouped by class based on `_type`
  #
  # Example:
  #
  # {
  #   Foo  => {"1"=> #<Foo id: 1, title: "ABC"}, ...},
  #   Bar  => {"1"=> #<Bar id: 1, name: "XYZ"}, ...}
  # }
  #
  # @api private
  def __records_by_type; end

  # Returns the collection of records for a specific type based on passed `klass`
  #
  # @api private
  def __records_for_klass(klass, ids); end

  # Returns the class of the model corresponding to a specific `hit` in Elasticsearch results
  #
  # @api private
  # @see Elasticsearch::Model::Registry
  def __type_for_hit(hit); end

  # Returns a collection of model instances, possibly of different classes (ActiveRecord, Mongoid, ...)
  #
  # @note The order of results in the Elasticsearch response is preserved
  def records; end
end

# Allows to automatically update index based on model changes,
# by hooking into the model lifecycle.
#
# @note A blocking HTTP request is done during the update process.
#   If you need a more performant/resilient way of updating the index,
#   consider adapting the callbacks behaviour, and use a background
#   processing solution such as [Sidekiq](http://sidekiq.org)
#   or [Resque](https://github.com/resque/resque).
module Elasticsearch::Model::Callbacks
  include ::Elasticsearch::Model::Adapter::Default::Callbacks

  class << self
    # When included in a model, automatically injects the callback subscribers (`after_save`, etc)
    #
    # @example Automatically update Elasticsearch index when the model changes
    #
    #   class Article
    #   include Elasticsearch::Model
    #   include Elasticsearch::Model::Callbacks
    #   end
    #
    #   Article.first.update_attribute :title, 'Updated'
    #   #  SQL (0.3ms)  UPDATE "articles" SET "title" = ...
    #   #  2013-11-20 15:08:52 +0100: POST http://localhost:9200/articles/article/1/_update ...
    def included(base); end
  end
end

module Elasticsearch::Model::ClassMethods
  # Get the client common for all models
  #
  # @example Get the client
  #
  #   Elasticsearch::Model.client
  #   => #<Elasticsearch::Transport::Client:0x007f96a7d0d000 @transport=... >
  def client; end

  # Set the client for all models
  #
  # @example Configure (set) the client for all models
  #
  #   Elasticsearch::Model.client = Elasticsearch::Client.new host: 'http://localhost:9200', tracer: true
  #   => #<Elasticsearch::Transport::Client:0x007f96a6dd0d80 @transport=... >
  # @note You have to set the client before you call Elasticsearch methods on the model,
  #   or set it directly on the model; see {Elasticsearch::Model::Client::ClassMethods#client}
  def client=(client); end

  # Search across multiple models
  #
  # By default, all models which include the `Elasticsearch::Model` module are searched
  #
  # @example Search across specific models
  #
  #   Elasticsearch::Model.search('foo', [Author, Article])
  # @example Search across all models which include the `Elasticsearch::Model` module
  #
  #   Elasticsearch::Model.search('foo')
  # @param query_or_payload [String, Hash, Object] The search request definition
  #   (string, JSON, Hash, or object responding to `to_hash`)
  # @param models [Array] The Array of Model objects to search
  # @param options [Hash] Optional parameters to be passed to the Elasticsearch client
  # @return [Elasticsearch::Model::Response::Response]
  def search(query_or_payload, models = T.unsafe(nil), options = T.unsafe(nil)); end

  # Access the module settings
  def settings; end
end

# Contains an `Elasticsearch::Client` instance
module Elasticsearch::Model::Client; end

module Elasticsearch::Model::Client::ClassMethods
  # Get the client for a specific model class
  #
  # @example Get the client for `Article` and perform API request
  #
  #   Article.client.cluster.health
  #   # => { "cluster_name" => "elasticsearch" ... }
  def client(client = T.unsafe(nil)); end

  # Set the client for a specific model class
  #
  # @example Configure the client for the `Article` model
  #
  #   Article.client = Elasticsearch::Client.new host: 'http://api.server:8080'
  #   Article.search ...
  def client=(client); end
end

module Elasticsearch::Model::Client::InstanceMethods
  # Get or set the client for a specific model instance
  #
  # @example Get the client for a specific record and perform API request
  #
  #   @article = Article.first
  #   @article.client.info
  #   # => { "name" => "Node-1", ... }
  def client; end

  # Set the client for a specific model instance
  #
  # @example Set the client for a specific record
  #
  #   @article = Article.first
  #   @article.client = Elasticsearch::Client.new host: 'http://api.server:8080'
  def client=(client); end
end

# Subclass of `Hashie::Mash` to wrap Hash-like structures
# (responses from Elasticsearch, search definitions, etc)
#
# The primary goal of the subclass is to disable the
# warning being printed by Hashie for re-defined
# methods, such as `sort`.
class Elasticsearch::Model::HashWrapper < ::Hashie::Mash; end

# Provides support for easily and efficiently importing large amounts of
# records from the including class into the index.
#
# @see ClassMethods#import
module Elasticsearch::Model::Importing
  include ::Elasticsearch::Model::Adapter::Default::Importing

  mixes_in_class_methods ::Elasticsearch::Model::Importing::ClassMethods
  mixes_in_class_methods ::Elasticsearch::Model::Adapter::Default::Importing

  class << self
    # When included in a model, adds the importing methods.
    #
    # @example Import all records from the `Article` model
    #
    #   Article.import
    # @see #import
    def included(base); end
  end
end

module Elasticsearch::Model::Importing::ClassMethods
  def __batch_to_bulk(batch, transform); end

  # Import all model records into the index
  #
  # The method will pick up correct strategy based on the `Importing` module
  # defined in the corresponding adapter.
  #
  # @example Import all records into the index
  #
  #   Article.import
  # @example Set the batch size to 100
  #
  #   Article.import batch_size: 100
  # @example Process the response from Elasticsearch
  #
  #   Article.import do |response|
  #   puts "Got " + response['items'].select { |i| i['index']['error'] }.size.to_s + " errors"
  #   end
  # @example Delete and create the index with appropriate settings and mappings
  #
  #   Article.import force: true
  # @example Refresh the index after importing all batches
  #
  #   Article.import refresh: true
  # @example Import the records into a different index/type than the default one
  #
  #   Article.import index: 'my-new-index', type: 'my-other-type'
  # @example Pass an ActiveRecord scope to limit the imported records
  #
  #   Article.import scope: 'published'
  # @example Pass an ActiveRecord query to limit the imported records
  #
  #   Article.import query: -> { where(author_id: author_id) }
  # @example Transform records during the import with a lambda
  #
  #   transform = lambda do |a|
  #   {index: {_id: a.id, _parent: a.author_id, data: a.__elasticsearch__.as_indexed_json}}
  #   end
  #
  #   Article.import transform: transform
  # @example Update the batch before yielding it
  #
  #   class Article
  #   # ...
  #   def self.enrich(batch)
  #   batch.each do |item|
  #   item.metadata = MyAPI.get_metadata(item.id)
  #   end
  #   batch
  #   end
  #   end
  #
  #   Article.import preprocess: :enrich
  # @example Return an array of error elements instead of the number of errors, e.g. to try importing these records again
  #
  #   Article.import return: 'errors'
  # @param options [Hash] Options passed to the underlying `__find_in_batches`method
  # @param block [Proc] Optional block to evaluate for each batch
  # @return [Fixnum] default, number of errors encountered during importing
  # @return [Array<Hash>] if +return+ option is specified to be +"errors"+,
  #   contains only those failed items in the response +items+ key, e.g.:
  #
  #   [
  #   {
  #   "index" => {
  #   "error" => 'FAILED',
  #   "_index" => "test",
  #   "_type" => "_doc",
  #   "_id" => '1',
  #   "_version" => 1,
  #   "result" => "foo",
  #   "_shards" => {
  #   "total" => 1,
  #   "successful" => 0,
  #   "failed" => 1
  #   },
  #   "status" => 400
  #   }
  #   }
  #   ]
  # @yield [Hash] Gives the Hash with the Elasticsearch response to the block
  def import(options = T.unsafe(nil), &block); end
end

# Provides the necessary support to set up index options (mappings, settings)
# as well as instance methods to create, update or delete documents in the index.
#
# @see ClassMethods#settings
# @see ClassMethods#mapping
# @see InstanceMethods#index_document
# @see InstanceMethods#update_document
# @see InstanceMethods#delete_document
module Elasticsearch::Model::Indexing; end

module Elasticsearch::Model::Indexing::ClassMethods
  # Creates an index with correct name, automatically passing
  # `settings` and `mappings` defined in the model
  #
  # @example Create an index for the `Article` model
  #
  #   Article.__elasticsearch__.create_index!
  # @example Forcefully create (delete first) an index for the `Article` model
  #
  #   Article.__elasticsearch__.create_index! force: true
  # @example Pass a specific index name
  #
  #   Article.__elasticsearch__.create_index! index: 'my-index'
  def create_index!(options = T.unsafe(nil)); end

  # Deletes the index with corresponding name
  #
  # @example Delete the index for the `Article` model
  #
  #   Article.__elasticsearch__.delete_index!
  # @example Pass a specific index name
  #
  #   Article.__elasticsearch__.delete_index! index: 'my-index'
  def delete_index!(options = T.unsafe(nil)); end

  # Returns true if the index exists
  #
  # @example Check whether the model's index exists
  #
  #   Article.__elasticsearch__.index_exists?
  # @example Check whether a specific index exists
  #
  #   Article.__elasticsearch__.index_exists? index: 'my-index'
  # @return [Boolean]
  def index_exists?(options = T.unsafe(nil)); end

  def load_settings_from_io(settings); end

  # Defines mappings for the index
  #
  # The `mappings` and `settings` methods are accessible directly on the model class,
  # when it doesn't already define them. Use the `__elasticsearch__` proxy otherwise.
  #
  # @example Define mapping for model
  #
  #   class Article
  #   mapping dynamic: 'strict' do
  #   indexes :foo do
  #   indexes :bar
  #   end
  #   indexes :baz
  #   end
  #   end
  #
  #   Article.mapping.to_hash
  #
  #   # => { :article =>
  #   #        { :dynamic => "strict",
  #   #          :properties=>
  #   #            { :foo => {
  #   #                :type=>"object",
  #   #                :properties => {
  #   #                  :bar => { :type => "string" }
  #   #                }
  #   #              }
  #   #            },
  #   #           :baz => { :type=> "string" }
  #   #        }
  #   #    }
  # @example Define index settings and mappings
  #
  #   class Article
  #   settings number_of_shards: 1 do
  #   mappings do
  #   indexes :foo
  #   end
  #   end
  #   end
  # @example Call the mapping method directly
  #
  #   Article.mapping(dynamic: 'strict') { indexes :foo, type: 'long' }
  #
  #   Article.mapping.to_hash
  #
  #   # => {:article=>{:dynamic=>"strict", :properties=>{:foo=>{:type=>"long"}}}}
  def mapping(options = T.unsafe(nil), &block); end

  # Defines mappings for the index
  #
  # The `mappings` and `settings` methods are accessible directly on the model class,
  # when it doesn't already define them. Use the `__elasticsearch__` proxy otherwise.
  #
  # @example Define mapping for model
  #   class Article
  #   mapping dynamic: 'strict' do
  #   indexes :foo do
  #   indexes :bar
  #   end
  #   indexes :baz
  #   end
  #   end
  #
  #   Article.mapping.to_hash
  #
  #   # => { :article =>
  #   #        { :dynamic => "strict",
  #   #          :properties=>
  #   #            { :foo => {
  #   #                :type=>"object",
  #   #                :properties => {
  #   #                  :bar => { :type => "string" }
  #   #                }
  #   #              }
  #   #            },
  #   #           :baz => { :type=> "string" }
  #   #        }
  #   #    }
  # @example Define index settings and mappings
  #   class Article
  #   settings number_of_shards: 1 do
  #   mappings do
  #   indexes :foo
  #   end
  #   end
  #   end
  # @example Call the mapping method directly
  #   Article.mapping(dynamic: 'strict') { indexes :foo, type: 'long' }
  #
  #   Article.mapping.to_hash
  #
  #   # => {:article=>{:dynamic=>"strict", :properties=>{:foo=>{:type=>"long"}}}}
  def mappings(options = T.unsafe(nil), &block); end

  # Performs the "refresh" operation for the index (useful e.g. in tests)
  #
  # @example Refresh the index for the `Article` model
  #
  #   Article.__elasticsearch__.refresh_index!
  # @example Pass a specific index name
  #
  #   Article.__elasticsearch__.refresh_index! index: 'my-index'
  # @see https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-refresh.html
  def refresh_index!(options = T.unsafe(nil)); end

  # Define settings for the index
  #
  # You can read settings from any object that responds to :read
  # as long as its return value can be parsed as either YAML or JSON.
  #
  # @example Define index settings
  #
  #   Article.settings(index: { number_of_shards: 1 })
  #
  #   Article.settings.to_hash
  #
  #   # => {:index=>{:number_of_shards=>1}}
  # @example Define index settings from YAML file
  #
  #   # config/elasticsearch/articles.yml:
  #   #
  #   # index:
  #   #   number_of_shards: 1
  #   #
  #
  #   Article.settings File.open("config/elasticsearch/articles.yml")
  #
  #   Article.settings.to_hash
  #
  #   # => { "index" => { "number_of_shards" => 1 } }
  # @example Define index settings from JSON file
  #
  #   # config/elasticsearch/articles.json:
  #   #
  #   # { "index": { "number_of_shards": 1 } }
  #   #
  #
  #   Article.settings File.open("config/elasticsearch/articles.json")
  #
  #   Article.settings.to_hash
  #
  #   # => { "index" => { "number_of_shards" => 1 } }
  def settings(settings = T.unsafe(nil), &block); end
end

module Elasticsearch::Model::Indexing::InstanceMethods
  # Deletes the model instance from the index
  #
  # @example Delete a record
  #
  #   @article.__elasticsearch__.delete_document
  #   2013-11-20 16:27:00 +0100: DELETE http://localhost:9200/articles/article/1
  # @param options [Hash] Optional arguments for passing to the client
  # @return [Hash] The response from Elasticsearch
  # @see http://rubydoc.info/gems/elasticsearch-api/Elasticsearch/API/Actions:delete
  def delete_document(options = T.unsafe(nil)); end

  # Serializes the model instance into JSON (by calling `as_indexed_json`),
  # and saves the document into the Elasticsearch index.
  #
  # @example Index a record
  #
  #   @article.__elasticsearch__.index_document
  #   2013-11-20 16:25:57 +0100: PUT http://localhost:9200/articles/article/1 ...
  # @param options [Hash] Optional arguments for passing to the client
  # @return [Hash] The response from Elasticsearch
  # @see http://rubydoc.info/gems/elasticsearch-api/Elasticsearch/API/Actions:index
  def index_document(options = T.unsafe(nil)); end

  # Tries to gather the changed attributes of a model instance
  # (via [ActiveModel::Dirty](http://api.rubyonrails.org/classes/ActiveModel/Dirty.html)),
  # performing a _partial_ update of the document.
  #
  # When the changed attributes are not available, performs full re-index of the record.
  #
  # See the {#update_document_attributes} method for updating specific attributes directly.
  #
  # @example Update a document corresponding to the record
  #
  #   @article = Article.first
  #   @article.update_attribute :title, 'Updated'
  #   # SQL (0.3ms)  UPDATE "articles" SET "title" = ?...
  #
  #   @article.__elasticsearch__.update_document
  #   # 2013-11-20 17:00:05 +0100: POST http://localhost:9200/articles/article/1/_update ...
  #   # 2013-11-20 17:00:05 +0100: > {"doc":{"title":"Updated"}}
  # @param options [Hash] Optional arguments for passing to the client
  # @return [Hash] The response from Elasticsearch
  # @see http://rubydoc.info/gems/elasticsearch-api/Elasticsearch/API/Actions:update
  def update_document(options = T.unsafe(nil)); end

  # Perform a _partial_ update of specific document attributes
  # (without consideration for changed attributes as in {#update_document})
  #
  # @example Update the `title` attribute
  #
  #   @article = Article.first
  #   @article.title = "New title"
  #   @article.__elasticsearch__.update_document_attributes title: "New title"
  # @param attributes [Hash] Attributes to be updated
  # @param options [Hash] Optional arguments for passing to the client
  # @return [Hash] The response from Elasticsearch
  def update_document_attributes(attributes, options = T.unsafe(nil)); end

  class << self
    # @private
    def included(base); end
  end
end

# Wraps the [index mappings](https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html)
class Elasticsearch::Model::Indexing::Mappings
  # @return [Mappings] a new instance of Mappings
  def initialize(type = T.unsafe(nil), options = T.unsafe(nil)); end

  def as_json(options = T.unsafe(nil)); end
  def indexes(name, options = T.unsafe(nil), &block); end

  # Returns the value of attribute options.
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  def options=(_arg0); end

  def to_hash; end

  # Returns the value of attribute type.
  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  def type=(_arg0); end
end

# @private
Elasticsearch::Model::Indexing::Mappings::TYPES_WITH_EMBEDDED_PROPERTIES = T.let(T.unsafe(nil), Array)

# Wraps the [index settings](https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html)
class Elasticsearch::Model::Indexing::Settings
  # @return [Settings] a new instance of Settings
  def initialize(settings = T.unsafe(nil)); end

  def as_json(options = T.unsafe(nil)); end

  # Returns the value of attribute settings.
  def settings; end

  # Sets the attribute settings
  #
  # @param value the value to set the attribute settings to.
  def settings=(_arg0); end

  def to_hash; end
end

Elasticsearch::Model::METHODS = T.let(T.unsafe(nil), Array)

# Wraps a collection of models when querying multiple indices
#
# @see Elasticsearch::Model.search
class Elasticsearch::Model::Multimodel
  # @param models [Class] The list of models across which the search will be performed
  # @return [Multimodel] a new instance of Multimodel
  def initialize(*models); end

  # Get the client common for all models
  #
  # @return Elasticsearch::Transport::Client
  def client; end

  # Get an Array of document types used for retrieving documents when doing a search across multiple models
  #
  # @return [Array] the list of document types used for retrieving documents
  def document_type; end

  # Get an Array of index names used for retrieving documents when doing a search across multiple models
  #
  # @return [Array] the list of index names used for retrieving documents
  def index_name; end

  # Returns the value of attribute models.
  def models; end
end

# Provides methods for getting and setting index name and document type for the model
module Elasticsearch::Model::Naming; end

module Elasticsearch::Model::Naming::ClassMethods
  # Get or set the document type
  #
  # @example Set the document type for the `Article` model
  #
  #   class Article
  #   document_type "my-article"
  #   end
  # @example Directly set the document type for the `Article` model
  #
  #   Article.document_type "my-article"
  def document_type(name = T.unsafe(nil)); end

  # Set the document type
  #
  # @see document_type
  def document_type=(name); end

  # Get or set the name of the index
  #
  # @example Set the index name for the `Article` model
  #
  #   class Article
  #   index_name "articles-#{Rails.env}"
  #   end
  # @example Set the index name for the `Article` model and re-evaluate it on each call
  #
  #   class Article
  #   index_name { "articles-#{Time.now.year}" }
  #   end
  # @example Directly set the index name for the `Article` model
  #
  #   Article.index_name "articles-#{Rails.env}"
  def index_name(name = T.unsafe(nil), &block); end

  # Set the index name
  #
  # @see index_name
  def index_name=(name); end

  private

  def default_document_type; end
  def default_index_name; end
  def implicit(prop); end
end

Elasticsearch::Model::Naming::DEFAULT_DOC_TYPE = T.let(T.unsafe(nil), String)

module Elasticsearch::Model::Naming::InstanceMethods
  # @example Set the document type for an instance of the `Article` model
  #
  #   @article.document_type "my-article"
  #   @article.__elasticsearch__.update_document
  def document_type(name = T.unsafe(nil)); end

  # Set the document type
  #
  # @see document_type
  def document_type=(name); end

  # Get or set the index name for the model instance
  #
  # @example Set the index name for an instance of the `Article` model
  #
  #   @article.index_name "articles-#{@article.user_id}"
  #   @article.__elasticsearch__.update_document
  def index_name(name = T.unsafe(nil), &block); end

  # Set the index name
  #
  # @see index_name
  def index_name=(name); end
end

class Elasticsearch::Model::NotImplemented < ::NoMethodError; end

# This module provides a proxy interfacing between the including class and
# `Elasticsearch::Model`, preventing the pollution of the including class namespace.
#
# The only "gateway" between the model and Elasticsearch::Model is the
# `#__elasticsearch__` class and instance method.
#
# The including class must be compatible with
# [ActiveModel](https://github.com/rails/rails/tree/master/activemodel).
#
# @example Include the `Elasticsearch::Model` module into an `Article` model
#
#   class Article < ActiveRecord::Base
#   include Elasticsearch::Model
#   end
#
#   Article.__elasticsearch__.respond_to?(:search)
#   # => true
#
#   article = Article.first
#
#   article.respond_to? :index_document
#   # => false
#
#   article.__elasticsearch__.respond_to?(:index_document)
#   # => true
module Elasticsearch::Model::Proxy
  include ::Elasticsearch::Model::Adapter::Default::Importing

  # {InstanceMethodsProxy}, accessed as `@mymodel.__elasticsearch__`
  def __elasticsearch__(&block); end

  private

  # Returns a copy of this object. Resets the __elasticsearch__ proxy so
  # the duplicate will build its own proxy.
  #
  # @overload dup
  def initialize_dup(_); end

  class << self
    # Define the `__elasticsearch__` class and instance methods in the including class
    # and register a callback for intercepting changes in the model.
    #
    # @note The callback is triggered only when `Elasticsearch::Model` is included in the
    #   module and the functionality is accessible via the proxy.
    def included(base); end
  end
end

# Common module for the proxy classes
module Elasticsearch::Model::Proxy::Base
  def initialize(target); end

  def inspect; end

  # Delegate methods to `@target`
  def method_missing(method_name, *arguments, &block); end

  # Respond to methods from `@target`
  #
  # @return [Boolean]
  def respond_to?(method_name, include_private = T.unsafe(nil)); end

  # Returns the value of attribute target.
  def target; end
end

# A proxy interfacing between Elasticsearch::Model class methods and model class methods
#
# TODO: Inherit from BasicObject and make Pry's `ls` command behave?
class Elasticsearch::Model::Proxy::ClassMethodsProxy
  include ::Elasticsearch::Model::Proxy::Base
  include ::Elasticsearch::Model::Client::ClassMethods
  include ::Elasticsearch::Model::Naming::ClassMethods
  include ::Elasticsearch::Model::Indexing::ClassMethods
  include ::Elasticsearch::Model::Searching::ClassMethods
  include ::Elasticsearch::Model::Importing::ClassMethods
end

# A proxy interfacing between Elasticsearch::Model instance methods and model instance methods
#
# TODO: Inherit from BasicObject and make Pry's `ls` command behave?
class Elasticsearch::Model::Proxy::InstanceMethodsProxy
  include ::Elasticsearch::Model::Proxy::Base
  include ::Elasticsearch::Model::Client::InstanceMethods
  include ::Elasticsearch::Model::Naming::InstanceMethods
  include ::Elasticsearch::Model::Indexing::InstanceMethods
  include ::Elasticsearch::Model::Serializing::InstanceMethods

  def as_indexed_json(options = T.unsafe(nil)); end

  # Need to redefine `as_json` because we're not inheriting from `BasicObject`;
  # see TODO note above.
  def as_json(options = T.unsafe(nil)); end

  def class; end
  def klass; end
end

# Keeps a global registry of classes that include `Elasticsearch::Model`
class Elasticsearch::Model::Registry
  # @return [Registry] a new instance of Registry
  def initialize; end

  # Adds a model to the registry
  def add(klass); end

  # Returns a copy of the registered models
  def models; end

  class << self
    # Returns the unique instance of the registry (Singleton)
    #
    # @api private
    def __instance; end

    # Adds a model to the registry
    def add(klass); end

    # Returns an Array of registered models
    def all; end
  end
end

# Contains modules and classes for wrapping the response from Elasticsearch
module Elasticsearch::Model::Response; end

class Elasticsearch::Model::Response::Aggregations < ::Elasticsearch::Model::HashWrapper
  # @return [Aggregations] a new instance of Aggregations
  def initialize(attributes = T.unsafe(nil)); end

  # Fix the problem of Hashie::Mash returning unexpected values for `min` and `max` methods
  #
  # People can define names for aggregations such as `min` and `max`, but these
  # methods are defined in `Enumerable#min` and `Enumerable#max`
  #
  #     { foo: 'bar' }.min
  #     # => [:foo, "bar"]
  #
  # Therefore, any Hashie::Mash instance value has the `min` and `max`
  # methods redefined to return the real value
  def __redefine_enumerable_methods(h); end
end

# Common funtionality for classes in the {Elasticsearch::Model::Response} module
module Elasticsearch::Model::Response::Base
  # @param klass [Class] The name of the model class
  # @param response [Hash] The full response returned from Elasticsearch client
  # @param options [Hash] Optional parameters
  def initialize(klass, response, options = T.unsafe(nil)); end

  # Returns the value of attribute klass.
  def klass; end

  # Returns the max_score
  def max_score; end

  # Returns the value of attribute raw_response.
  def raw_response; end

  # @abstract Implement this method in specific class
  # @raise [NotImplemented]
  def records; end

  # Returns the value of attribute response.
  def response; end

  # @abstract Implement this method in specific class
  # @raise [NotImplemented]
  def results; end

  # Returns the total number of hits
  def total; end
end

# Pagination for search results/records
module Elasticsearch::Model::Response::Pagination; end

# Allow models to be paginated with the "kaminari" gem [https://github.com/amatsuda/kaminari]
module Elasticsearch::Model::Response::Pagination::Kaminari
  include ::Kaminari::ConfigurationMethods::ClassMethods
  include ::Kaminari::PageScopeMethods

  # Returns the models's `per_page` value or the default
  #
  # @api private
  def __default_per_page; end

  # Set the "limit" (`size`) value
  def limit(value); end

  # Returns the current "limit" (`size`) value
  def limit_value; end

  # Set the "offset" (`from`) value
  def offset(value); end

  # Returns the current "offset" (`from`) value
  def offset_value; end

  # Returns the total number of results
  def total_count; end

  class << self
    # @private
    def included(base); end
  end
end

# Allow models to be paginated with the "will_paginate" gem [https://github.com/mislav/will_paginate]
module Elasticsearch::Model::Response::Pagination::WillPaginate
  # Returns the models's `per_page` value or the default
  #
  # @api private
  def __default_per_page; end

  # Return the current page
  def current_page; end

  def length; end
  def offset; end

  # Pagination method
  #
  # @example
  #
  #   Article.search('foo').page(2)
  def page(num); end

  # Main pagination method
  #
  # @example
  #
  #   Article.search('foo').paginate(page: 1, per_page: 30)
  def paginate(options); end

  # Return or set the "size" value
  #
  # @example
  #
  #   Article.search('foo').per_page(15).page(2)
  def per_page(num = T.unsafe(nil)); end

  # Returns the total number of results
  def total_entries; end

  class << self
    # @private
    def included(base); end
  end
end

# Encapsulates the collection of records returned from the database
#
# Implements Enumerable and forwards its methods to the {#records} object,
# which is provided by an {Elasticsearch::Model::Adapter::Adapter} implementation.
class Elasticsearch::Model::Response::Records
  include ::Enumerable
  include ::Elasticsearch::Model::Response::Base
  include ::Kaminari::PageScopeMethods

  # @return [Records] a new instance of Records
  # @see Base#initialize
  def initialize(klass, response, options = T.unsafe(nil)); end

  def [](*_arg0, **_arg1, &_arg2); end
  def each(*_arg0, **_arg1, &_arg2); end

  # Yields [record, hit] pairs to the block
  def each_with_hit(&block); end

  def empty?(*_arg0, **_arg1, &_arg2); end

  # Returns the hit IDs
  def ids; end

  def limit_value(*_arg0, **_arg1, &_arg2); end

  # Yields [record, hit] pairs and returns the result
  def map_with_hit(&block); end

  def max_pages(*_arg0, **_arg1, &_arg2); end

  # Delegate methods to `@records`
  def method_missing(method_name, *arguments); end

  def offset_value(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute options.
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  def options=(_arg0); end

  # Respond to methods from `@records`
  #
  # @return [Boolean]
  def respond_to?(method_name, include_private = T.unsafe(nil)); end

  # Returns the {Results} collection
  def results; end

  def size(*_arg0, **_arg1, &_arg2); end
  def slice(*_arg0, **_arg1, &_arg2); end
  def to_a(*_arg0, **_arg1, &_arg2); end
  def to_ary(*_arg0, **_arg1, &_arg2); end
  def total_count(*_arg0, **_arg1, &_arg2); end
end

# Encapsulate the response returned from the Elasticsearch client
#
# Implements Enumerable and forwards its methods to the {#results} object.
class Elasticsearch::Model::Response::Response
  include ::Enumerable
  include ::Elasticsearch::Model::Response::Pagination::Kaminari
  include ::Kaminari::ConfigurationMethods::ClassMethods
  include ::Kaminari::PageScopeMethods

  # @return [Response] a new instance of Response
  def initialize(klass, search, options = T.unsafe(nil)); end

  def [](*_arg0, **_arg1, &_arg2); end

  # Returns a Hashie::Mash of the aggregations
  def aggregations; end

  def each(*_arg0, **_arg1, &_arg2); end
  def empty?(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute klass.
  def klass; end

  def page(num = T.unsafe(nil)); end
  def raw_response; end

  # Returns the collection of records from the database
  #
  # @return [Records]
  def records(options = T.unsafe(nil)); end

  # Returns the Elasticsearch response
  #
  # @return [Hash]
  def response; end

  # Returns the collection of "hits" from Elasticsearch
  #
  # @return [Results]
  def results; end

  # Returns the value of attribute search.
  def search; end

  # Returns the statistics on shards
  def shards; end

  def size(*_arg0, **_arg1, &_arg2); end
  def slice(*_arg0, **_arg1, &_arg2); end

  # Returns a Hashie::Mash of the suggestions
  def suggestions; end

  # Returns whether the response timed out
  def timed_out; end

  def to_ary(*_arg0, **_arg1, &_arg2); end

  # Returns the "took" time
  def took; end
end

# Encapsulates the "hit" returned from the Elasticsearch client
#
# Wraps the raw Hash with in a `Hashie::Mash` instance, providing
# access to the Hash properties by calling Ruby methods.
#
# @see https://github.com/intridea/hashie
class Elasticsearch::Model::Response::Result
  # @param attributes [Hash] A Hash with document properties
  # @return [Result] a new instance of Result
  def initialize(attributes = T.unsafe(nil)); end

  def as_json(options = T.unsafe(nil)); end

  # Return document `_id` as `id`
  def id; end

  # Delegate methods to `@result` or `@result._source`
  def method_missing(name, *arguments); end

  # Return document `_type` as `_type`
  def type; end

  private

  # Respond to methods from `@result` or `@result._source`
  #
  # @return [Boolean]
  def respond_to_missing?(method_name, include_private = T.unsafe(nil)); end
end

# Encapsulates the collection of documents returned from Elasticsearch
#
# Implements Enumerable and forwards its methods to the {#results} object.
class Elasticsearch::Model::Response::Results
  include ::Elasticsearch::Model::Response::Base
  include ::Enumerable
  include ::Kaminari::ConfigurationMethods::ClassMethods
  include ::Kaminari::PageScopeMethods

  # @return [Results] a new instance of Results
  # @see Base#initialize
  def initialize(klass, response, options = T.unsafe(nil)); end

  def [](*_arg0, **_arg1, &_arg2); end
  def each(*_arg0, **_arg1, &_arg2); end
  def empty?(*_arg0, **_arg1, &_arg2); end
  def limit_value(*_arg0, **_arg1, &_arg2); end
  def max_pages(*_arg0, **_arg1, &_arg2); end
  def offset_value(*_arg0, **_arg1, &_arg2); end

  # Returns the {Results} collection
  def results; end

  def size(*_arg0, **_arg1, &_arg2); end
  def slice(*_arg0, **_arg1, &_arg2); end
  def to_a(*_arg0, **_arg1, &_arg2); end
  def to_ary(*_arg0, **_arg1, &_arg2); end
  def total_count(*_arg0, **_arg1, &_arg2); end
end

class Elasticsearch::Model::Response::Suggestions < ::Elasticsearch::Model::HashWrapper
  def terms; end
end

# Contains functionality related to searching.
module Elasticsearch::Model::Searching; end

module Elasticsearch::Model::Searching::ClassMethods
  # Provides a `search` method for the model to easily search within an index/type
  # corresponding to the model settings.
  #
  # @example Simple search in `Article`
  #
  #   Article.search 'foo'
  # @example Search using a search definition as a Hash
  #
  #   response = Article.search \
  #   query: {
  #   match: {
  #   title: 'foo'
  #   }
  #   },
  #   highlight: {
  #   fields: {
  #   title: {}
  #   }
  #   },
  #   size: 50
  #
  #   response.results.first.title
  #   # => "Foo"
  #
  #   response.results.first.highlight.title
  #   # => ["<em>Foo</em>"]
  #
  #   response.records.first.title
  #   #  Article Load (0.2ms)  SELECT "articles".* FROM "articles" WHERE "articles"."id" IN (1, 3)
  #   # => "Foo"
  # @example Search using a search definition as a JSON string
  #
  #   Article.search '{"query" : { "match_all" : {} }}'
  # @param query_or_payload [String, Hash, Object] The search request definition
  #   (string, JSON, Hash, or object responding to `to_hash`)
  # @param options [Hash] Optional parameters to be passed to the Elasticsearch client
  # @return [Elasticsearch::Model::Response::Response]
  def search(query_or_payload, options = T.unsafe(nil)); end
end

# Wraps a search request definition
class Elasticsearch::Model::Searching::SearchRequest
  # @param klass [Class] The class of the model
  # @param query_or_payload [String, Hash, Object] The search request definition
  #   (string, JSON, Hash, or object responding to `to_hash`)
  # @param options [Hash] Optional parameters to be passed to the Elasticsearch client
  # @return [SearchRequest] a new instance of SearchRequest
  def initialize(klass, query_or_payload, options = T.unsafe(nil)); end

  # Returns the value of attribute definition.
  def definition; end

  # Performs the request and returns the response from client
  #
  # @return [Hash] The response from Elasticsearch
  def execute!; end

  # Returns the value of attribute klass.
  def klass; end

  # Returns the value of attribute options.
  def options; end
end

# Contains functionality for serializing model instances for the client
module Elasticsearch::Model::Serializing; end

module Elasticsearch::Model::Serializing::ClassMethods; end

module Elasticsearch::Model::Serializing::InstanceMethods
  # Serialize the record as a Hash, to be passed to the client.
  #
  # Re-define this method to customize the serialization.
  #
  # @example Return the model instance as a Hash
  #
  #   Article.first.__elasticsearch__.as_indexed_json
  #   => {"title"=>"Foo"}
  # @return [Hash]
  # @see Elasticsearch::Model::Indexing
  def as_indexed_json(options = T.unsafe(nil)); end
end

Elasticsearch::Model::VERSION = T.let(T.unsafe(nil), String)
Elasticsearch::VERSION = T.let(T.unsafe(nil), String)
