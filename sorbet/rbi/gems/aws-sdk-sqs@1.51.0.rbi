# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `aws-sdk-sqs` gem.
# Please instead update this file by running `bin/tapioca gem aws-sdk-sqs`.

module Aws
  class << self
    # @return [Hash] Returns a hash of default configuration options shared
    #   by all constructed clients.
    def config; end

    # @param config [Hash]
    def config=(config); end

    # @api private
    def eager_autoload!(*args); end

    # Close any long-lived connections maintained by the SDK's internal
    # connection pool.
    #
    # Applications that rely heavily on the `fork()` system call on POSIX systems
    # should call this method in the child process directly after fork to ensure
    # there are no race conditions between the parent
    # process and its children
    # for the pooled TCP connections.
    #
    # Child processes that make multi-threaded calls to the SDK should block on
    # this call before beginning work.
    #
    # @return [nil]
    def empty_connection_pools!; end

    # @see (Aws::Partitions.partition)
    def partition(partition_name); end

    # @see (Aws::Partitions.partitions)
    def partitions; end

    # @api private
    def shared_config; end

    # The SDK ships with a ca certificate bundle to use when verifying SSL
    # peer certificates. By default, this cert bundle is *NOT* used. The
    # SDK will rely on the default cert available to OpenSSL. This ensures
    # the cert provided by your OS is used.
    #
    # For cases where the default cert is unavailable, e.g. Windows, you
    # can call this method.
    #
    #     Aws.use_bundled_cert!
    #
    # @return [String] Returns the path to the bundled cert.
    def use_bundled_cert!; end
  end
end

Aws::CORE_GEM_VERSION = T.let(T.unsafe(nil), String)

# This module provides support for Amazon Simple Queue Service. This module is available in the
# `aws-sdk-sqs` gem.
#
# # Client
#
# The {Client} class provides one method for each API operation. Operation
# methods each accept a hash of request parameters and return a response
# structure.
#
#     sqs = Aws::SQS::Client.new
#     resp = sqs.add_permission(params)
#
# See {Client} for more information.
#
# # Errors
#
# Errors returned from Amazon Simple Queue Service are defined in the
# {Errors} module and all extend {Errors::ServiceError}.
#
#     begin
#       # do stuff
#     rescue Aws::SQS::Errors::ServiceError
#       # rescues all Amazon Simple Queue Service API errors
#     end
#
# See {Errors} for more information.
module Aws::SQS; end

# An API client for SQS.  To construct a client, you need to configure a `:region` and `:credentials`.
#
#     client = Aws::SQS::Client.new(
#       region: region_name,
#       credentials: credentials,
#       # ...
#     )
#
# For details on configuring region and credentials see
# the [developer guide](/sdk-for-ruby/v3/developer-guide/setup-config.html).
#
# See {#initialize} for a full list of supported configuration options.
class Aws::SQS::Client < ::Seahorse::Client::Base
  include ::Aws::ClientStubs

  # @overload initialize
  # @return [Client] a new instance of Client
  def initialize(*args); end

  # Adds a permission to a queue for a specific [principal][1]. This
  # allows sharing access to the queue.
  #
  # When you create a queue, you have full control access rights for the
  # queue. Only you, the owner of the queue, can grant or deny permissions
  # to the queue. For more information about these permissions, see [Allow
  # Developers to Write Messages to a Shared Queue][2] in the *Amazon SQS
  # Developer Guide*.
  #
  # <note markdown="1"> * `AddPermission` generates a policy for you. You can use `
  #   SetQueueAttributes ` to upload your policy. For more information,
  #   see [Using Custom Policies with the Amazon SQS Access Policy
  #   Language][3] in the *Amazon SQS Developer Guide*.
  #
  # * An Amazon SQS policy can have a maximum of 7 actions.
  #
  # * To remove the ability to change queue permissions, you must deny
  #   permission to the `AddPermission`, `RemovePermission`, and
  #   `SetQueueAttributes` actions in your IAM policy.
  #
  #  </note>
  #
  # Some actions take lists of parameters. These lists are specified using
  # the `param.n` notation. Values of `n` are integers starting from 1.
  # For example, a parameter list with two elements looks like this:
  #
  # `&AttributeName.1=first`
  #
  # `&AttributeName.2=second`
  #
  # <note markdown="1"> Cross-account permissions don't apply to this action. For more
  # information, see [Grant cross-account permissions to a role and a user
  # name][4] in the *Amazon SQS Developer Guide*.
  #
  #  </note>
  #
  #
  #
  # [1]: https://docs.aws.amazon.com/general/latest/gr/glos-chap.html#P
  # [2]: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-writing-an-sqs-policy.html#write-messages-to-shared-queue
  # [3]: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-creating-custom-policies.html
  # [4]: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-customer-managed-policy-examples.html#grant-cross-account-permissions-to-role-and-user-name
  #
  # @example Request syntax with placeholder values
  #
  #   resp = client.add_permission({
  #   queue_url: "String", # required
  #   label: "String", # required
  #   aws_account_ids: ["String"], # required
  #   actions: ["String"], # required
  #   })
  # @option params
  # @option params
  # @option params
  # @option params
  # @overload add_permission
  # @param params [Hash] ({})
  # @return [Struct] Returns an empty {Seahorse::Client::Response response}.
  # @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/AddPermission AWS API Documentation
  def add_permission(params = T.unsafe(nil), options = T.unsafe(nil)); end

  # @api private
  # @param params [{}]
  def build_request(operation_name, params = T.unsafe(nil)); end

  # Changes the visibility timeout of a specified message in a queue to a
  # new value. The default visibility timeout for a message is 30 seconds.
  # The minimum is 0 seconds. The maximum is 12 hours. For more
  # information, see [Visibility Timeout][1] in the *Amazon SQS Developer
  # Guide*.
  #
  # For example, you have a message with a visibility timeout of 5
  # minutes. After 3 minutes, you call `ChangeMessageVisibility` with a
  # timeout of 10 minutes. You can continue to call
  # `ChangeMessageVisibility` to extend the visibility timeout to the
  # maximum allowed time. If you try to extend the visibility timeout
  # beyond the maximum, your request is rejected.
  #
  # An Amazon SQS message has three basic states:
  #
  # 1.  Sent to a queue by a producer.
  #
  # 2.  Received from the queue by a consumer.
  #
  # 3.  Deleted from the queue.
  #
  # A message is considered to be *stored* after it is sent to a queue by
  # a producer, but not yet received from the queue by a consumer (that
  # is, between states 1 and 2). There is no limit to the number of stored
  # messages. A message is considered to be *in flight* after it is
  # received from a queue by a consumer, but not yet deleted from the
  # queue (that is, between states 2 and 3). There is a limit to the
  # number of inflight messages.
  #
  # Limits that apply to inflight messages are unrelated to the
  # *unlimited* number of stored messages.
  #
  # For most standard queues (depending on queue traffic and message
  # backlog), there can be a maximum of approximately 120,000 inflight
  # messages (received from a queue by a consumer, but not yet deleted
  # from the queue). If you reach this limit, Amazon SQS returns the
  # `OverLimit` error message. To avoid reaching the limit, you should
  # delete messages from the queue after they're processed. You can also
  # increase the number of queues you use to process your messages. To
  # request a limit increase, [file a support request][2].
  #
  # For FIFO queues, there can be a maximum of 20,000 inflight messages
  # (received from a queue by a consumer, but not yet deleted from the
  # queue). If you reach this limit, Amazon SQS returns no error messages.
  #
  # If you attempt to set the `VisibilityTimeout` to a value greater than
  # the maximum time left, Amazon SQS returns an error. Amazon SQS
  # doesn't automatically recalculate and increase the timeout to the
  # maximum remaining time.
  #
  #  Unlike with a queue, when you change the visibility timeout for a
  # specific message the timeout value is applied immediately but isn't
  # saved in memory for that message. If you don't delete a message after
  # it is received, the visibility timeout for the message reverts to the
  # original timeout value (not to the value you set using the
  # `ChangeMessageVisibility` action) the next time the message is
  # received.
  #
  #
  #
  # [1]: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-visibility-timeout.html
  # [2]: https://console.aws.amazon.com/support/home#/case/create?issueType=service-limit-increase&amp;limitType=service-code-sqs
  #
  # @example Request syntax with placeholder values
  #
  #   resp = client.change_message_visibility({
  #   queue_url: "String", # required
  #   receipt_handle: "String", # required
  #   visibility_timeout: 1, # required
  #   })
  # @option params
  # @option params
  # @option params
  # @overload change_message_visibility
  # @param params [Hash] ({})
  # @return [Struct] Returns an empty {Seahorse::Client::Response response}.
  # @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/ChangeMessageVisibility AWS API Documentation
  def change_message_visibility(params = T.unsafe(nil), options = T.unsafe(nil)); end

  # Changes the visibility timeout of multiple messages. This is a batch
  # version of ` ChangeMessageVisibility.` The result of the action on
  # each message is reported individually in the response. You can send up
  # to 10 ` ChangeMessageVisibility ` requests with each
  # `ChangeMessageVisibilityBatch` action.
  #
  # Because the batch request can result in a combination of successful
  # and unsuccessful actions, you should check for batch errors even when
  # the call returns an HTTP status code of `200`.
  #
  # Some actions take lists of parameters. These lists are specified using
  # the `param.n` notation. Values of `n` are integers starting from 1.
  # For example, a parameter list with two elements looks like this:
  #
  # `&AttributeName.1=first`
  #
  # `&AttributeName.2=second`
  #
  # @example Request syntax with placeholder values
  #
  #   resp = client.change_message_visibility_batch({
  #   queue_url: "String", # required
  #   entries: [ # required
  #   {
  #   id: "String", # required
  #   receipt_handle: "String", # required
  #   visibility_timeout: 1,
  #   },
  #   ],
  #   })
  # @example Response structure
  #
  #   resp.successful #=> Array
  #   resp.successful[0].id #=> String
  #   resp.failed #=> Array
  #   resp.failed[0].id #=> String
  #   resp.failed[0].sender_fault #=> Boolean
  #   resp.failed[0].code #=> String
  #   resp.failed[0].message #=> String
  # @option params
  # @option params
  # @overload change_message_visibility_batch
  # @param params [Hash] ({})
  # @return [Types::ChangeMessageVisibilityBatchResult] Returns a {Seahorse::Client::Response response} object which responds to the following methods:
  #
  #   * {Types::ChangeMessageVisibilityBatchResult#successful #successful} => Array&lt;Types::ChangeMessageVisibilityBatchResultEntry&gt;
  #   * {Types::ChangeMessageVisibilityBatchResult#failed #failed} => Array&lt;Types::BatchResultErrorEntry&gt;
  # @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/ChangeMessageVisibilityBatch AWS API Documentation
  def change_message_visibility_batch(params = T.unsafe(nil), options = T.unsafe(nil)); end

  # Creates a new standard or FIFO queue. You can pass one or more
  # attributes in the request. Keep the following in mind:
  #
  # * If you don't specify the `FifoQueue` attribute, Amazon SQS creates
  #   a standard queue.
  #
  #   <note markdown="1"> You can't change the queue type after you create it and you can't
  #   convert an existing standard queue into a FIFO queue. You must
  #   either create a new FIFO queue for your application or delete your
  #   existing standard queue and recreate it as a FIFO queue. For more
  #   information, see [Moving From a Standard Queue to a FIFO Queue][1]
  #   in the *Amazon SQS Developer Guide*.
  #
  #    </note>
  #
  # * If you don't provide a value for an attribute, the queue is created
  #   with the default value for the attribute.
  #
  # * If you delete a queue, you must wait at least 60 seconds before
  #   creating a queue with the same name.
  #
  # To successfully create a new queue, you must provide a queue name that
  # adheres to the [limits related to queues][2] and is unique within the
  # scope of your queues.
  #
  # <note markdown="1"> After you create a queue, you must wait at least one second after the
  # queue is created to be able to use the queue.
  #
  #  </note>
  #
  # To get the queue URL, use the ` GetQueueUrl ` action. ` GetQueueUrl `
  # requires only the `QueueName` parameter. be aware of existing queue
  # names:
  #
  # * If you provide the name of an existing queue along with the exact
  #   names and values of all the queue's attributes, `CreateQueue`
  #   returns the queue URL for the existing queue.
  #
  # * If the queue name, attribute names, or attribute values don't match
  #   an existing queue, `CreateQueue` returns an error.
  #
  # Some actions take lists of parameters. These lists are specified using
  # the `param.n` notation. Values of `n` are integers starting from 1.
  # For example, a parameter list with two elements looks like this:
  #
  # `&AttributeName.1=first`
  #
  # `&AttributeName.2=second`
  #
  # <note markdown="1"> Cross-account permissions don't apply to this action. For more
  # information, see [Grant cross-account permissions to a role and a user
  # name][3] in the *Amazon SQS Developer Guide*.
  #
  #  </note>
  #
  #
  #
  # [1]: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues.html#FIFO-queues-moving
  # [2]: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/limits-queues.html
  # [3]: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-customer-managed-policy-examples.html#grant-cross-account-permissions-to-role-and-user-name
  #
  # @example Response structure
  #
  #   resp.queue_url #=> String
  # @example Request syntax with placeholder values
  #
  #   resp = client.create_queue({
  #   queue_name: "String", # required
  #   attributes: {
  #   "All" => "String",
  #   },
  #   tags: {
  #   "TagKey" => "TagValue",
  #   },
  #   })
  # @option params
  # @option params
  # @option params
  # @overload create_queue
  # @param params [Hash] ({})
  # @return [Types::CreateQueueResult] Returns a {Seahorse::Client::Response response} object which responds to the following methods:
  #
  #   * {Types::CreateQueueResult#queue_url #queue_url} => String
  # @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/CreateQueue AWS API Documentation
  def create_queue(params = T.unsafe(nil), options = T.unsafe(nil)); end

  # Deletes the specified message from the specified queue. To select the
  # message to delete, use the `ReceiptHandle` of the message (*not* the
  # `MessageId` which you receive when you send the message). Amazon SQS
  # can delete a message from a queue even if a visibility timeout setting
  # causes the message to be locked by another consumer. Amazon SQS
  # automatically deletes messages left in a queue longer than the
  # retention period configured for the queue.
  #
  # <note markdown="1"> The `ReceiptHandle` is associated with a *specific instance* of
  # receiving a message. If you receive a message more than once, the
  # `ReceiptHandle` is different each time you receive a message. When you
  # use the `DeleteMessage` action, you must provide the most recently
  # received `ReceiptHandle` for the message (otherwise, the request
  # succeeds, but the message might not be deleted).
  #
  #  For standard queues, it is possible to receive a message even after
  # you delete it. This might happen on rare occasions if one of the
  # servers which stores a copy of the message is unavailable when you
  # send the request to delete the message. The copy remains on the server
  # and might be returned to you during a subsequent receive request. You
  # should ensure that your application is idempotent, so that receiving a
  # message more than once does not cause issues.
  #
  #  </note>
  #
  # @example Request syntax with placeholder values
  #
  #   resp = client.delete_message({
  #   queue_url: "String", # required
  #   receipt_handle: "String", # required
  #   })
  # @option params
  # @option params
  # @overload delete_message
  # @param params [Hash] ({})
  # @return [Struct] Returns an empty {Seahorse::Client::Response response}.
  # @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/DeleteMessage AWS API Documentation
  def delete_message(params = T.unsafe(nil), options = T.unsafe(nil)); end

  # Deletes up to ten messages from the specified queue. This is a batch
  # version of ` DeleteMessage.` The result of the action on each message
  # is reported individually in the response.
  #
  # Because the batch request can result in a combination of successful
  # and unsuccessful actions, you should check for batch errors even when
  # the call returns an HTTP status code of `200`.
  #
  # Some actions take lists of parameters. These lists are specified using
  # the `param.n` notation. Values of `n` are integers starting from 1.
  # For example, a parameter list with two elements looks like this:
  #
  # `&AttributeName.1=first`
  #
  # `&AttributeName.2=second`
  #
  # @example Request syntax with placeholder values
  #
  #   resp = client.delete_message_batch({
  #   queue_url: "String", # required
  #   entries: [ # required
  #   {
  #   id: "String", # required
  #   receipt_handle: "String", # required
  #   },
  #   ],
  #   })
  # @example Response structure
  #
  #   resp.successful #=> Array
  #   resp.successful[0].id #=> String
  #   resp.failed #=> Array
  #   resp.failed[0].id #=> String
  #   resp.failed[0].sender_fault #=> Boolean
  #   resp.failed[0].code #=> String
  #   resp.failed[0].message #=> String
  # @option params
  # @option params
  # @overload delete_message_batch
  # @param params [Hash] ({})
  # @return [Types::DeleteMessageBatchResult] Returns a {Seahorse::Client::Response response} object which responds to the following methods:
  #
  #   * {Types::DeleteMessageBatchResult#successful #successful} => Array&lt;Types::DeleteMessageBatchResultEntry&gt;
  #   * {Types::DeleteMessageBatchResult#failed #failed} => Array&lt;Types::BatchResultErrorEntry&gt;
  # @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/DeleteMessageBatch AWS API Documentation
  def delete_message_batch(params = T.unsafe(nil), options = T.unsafe(nil)); end

  # Deletes the queue specified by the `QueueUrl`, regardless of the
  # queue's contents.
  #
  # Be careful with the `DeleteQueue` action: When you delete a queue, any
  # messages in the queue are no longer available.
  #
  # When you delete a queue, the deletion process takes up to 60 seconds.
  # Requests you send involving that queue during the 60 seconds might
  # succeed. For example, a ` SendMessage ` request might succeed, but
  # after 60 seconds the queue and the message you sent no longer exist.
  #
  # When you delete a queue, you must wait at least 60 seconds before
  # creating a queue with the same name.
  #
  # <note markdown="1"> Cross-account permissions don't apply to this action. For more
  # information, see [Grant cross-account permissions to a role and a user
  # name][1] in the *Amazon SQS Developer Guide*.
  #
  #  </note>
  #
  #
  #
  # [1]: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-customer-managed-policy-examples.html#grant-cross-account-permissions-to-role-and-user-name
  #
  # @example Request syntax with placeholder values
  #
  #   resp = client.delete_queue({
  #   queue_url: "String", # required
  #   })
  # @option params
  # @overload delete_queue
  # @param params [Hash] ({})
  # @return [Struct] Returns an empty {Seahorse::Client::Response response}.
  # @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/DeleteQueue AWS API Documentation
  def delete_queue(params = T.unsafe(nil), options = T.unsafe(nil)); end

  # Gets attributes for the specified queue.
  #
  # <note markdown="1"> To determine whether a queue is [FIFO][1], you can check whether
  # `QueueName` ends with the `.fifo` suffix.
  #
  #  </note>
  #
  #
  #
  # [1]: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues.html
  #
  # @example Request syntax with placeholder values
  #
  #   resp = client.get_queue_attributes({
  #   queue_url: "String", # required
  #   attribute_names: ["All"], # accepts All, Policy, VisibilityTimeout, MaximumMessageSize, MessageRetentionPeriod, ApproximateNumberOfMessages, ApproximateNumberOfMessagesNotVisible, CreatedTimestamp, LastModifiedTimestamp, QueueArn, ApproximateNumberOfMessagesDelayed, DelaySeconds, ReceiveMessageWaitTimeSeconds, RedrivePolicy, FifoQueue, ContentBasedDeduplication, KmsMasterKeyId, KmsDataKeyReusePeriodSeconds, DeduplicationScope, FifoThroughputLimit, RedriveAllowPolicy, SqsManagedSseEnabled
  #   })
  # @example Response structure
  #
  #   resp.attributes #=> Hash
  #   resp.attributes["QueueAttributeName"] #=> String
  # @option params
  # @option params
  # @overload get_queue_attributes
  # @param params [Hash] ({})
  # @return [Types::GetQueueAttributesResult] Returns a {Seahorse::Client::Response response} object which responds to the following methods:
  #
  #   * {Types::GetQueueAttributesResult#attributes #attributes} => Hash&lt;String,String&gt;
  # @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/GetQueueAttributes AWS API Documentation
  def get_queue_attributes(params = T.unsafe(nil), options = T.unsafe(nil)); end

  # Returns the URL of an existing Amazon SQS queue.
  #
  # To access a queue that belongs to another AWS account, use the
  # `QueueOwnerAWSAccountId` parameter to specify the account ID of the
  # queue's owner. The queue's owner must grant you permission to access
  # the queue. For more information about shared queue access, see `
  # AddPermission ` or see [Allow Developers to Write Messages to a Shared
  # Queue][1] in the *Amazon SQS Developer Guide*.
  #
  #
  #
  # [1]: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-writing-an-sqs-policy.html#write-messages-to-shared-queue
  #
  # @example Request syntax with placeholder values
  #
  #   resp = client.get_queue_url({
  #   queue_name: "String", # required
  #   queue_owner_aws_account_id: "String",
  #   })
  # @example Response structure
  #
  #   resp.queue_url #=> String
  # @option params
  # @option params
  # @overload get_queue_url
  # @param params [Hash] ({})
  # @return [Types::GetQueueUrlResult] Returns a {Seahorse::Client::Response response} object which responds to the following methods:
  #
  #   * {Types::GetQueueUrlResult#queue_url #queue_url} => String
  # @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/GetQueueUrl AWS API Documentation
  def get_queue_url(params = T.unsafe(nil), options = T.unsafe(nil)); end

  # Returns a list of your queues that have the `RedrivePolicy` queue
  # attribute configured with a dead-letter queue.
  #
  # The `ListDeadLetterSourceQueues` methods supports pagination. Set
  # parameter `MaxResults` in the request to specify the maximum number of
  # results to be returned in the response. If you do not set
  # `MaxResults`, the response includes a maximum of 1,000 results. If you
  # set `MaxResults` and there are additional results to display, the
  # response includes a value for `NextToken`. Use `NextToken` as a
  # parameter in your next request to `ListDeadLetterSourceQueues` to
  # receive the next page of results.
  #
  # For more information about using dead-letter queues, see [Using Amazon
  # SQS Dead-Letter Queues][1] in the *Amazon SQS Developer Guide*.
  #
  #
  #
  # [1]: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-dead-letter-queues.html
  #
  # The returned {Seahorse::Client::Response response} is a pageable response and is Enumerable. For details on usage see {Aws::PageableResponse PageableResponse}.
  #
  # @example Response structure
  #
  #   resp.queue_urls #=> Array
  #   resp.queue_urls[0] #=> String
  #   resp.next_token #=> String
  # @example Request syntax with placeholder values
  #
  #   resp = client.list_dead_letter_source_queues({
  #   queue_url: "String", # required
  #   next_token: "Token",
  #   max_results: 1,
  #   })
  # @option params
  # @option params
  # @option params
  # @overload list_dead_letter_source_queues
  # @param params [Hash] ({})
  # @return [Types::ListDeadLetterSourceQueuesResult] Returns a {Seahorse::Client::Response response} object which responds to the following methods:
  #
  #   * {Types::ListDeadLetterSourceQueuesResult#queue_urls #queue_urls} => Array&lt;String&gt;
  #   * {Types::ListDeadLetterSourceQueuesResult#next_token #next_token} => String
  # @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/ListDeadLetterSourceQueues AWS API Documentation
  def list_dead_letter_source_queues(params = T.unsafe(nil), options = T.unsafe(nil)); end

  # List all cost allocation tags added to the specified Amazon SQS queue.
  # For an overview, see [Tagging Your Amazon SQS Queues][1] in the
  # *Amazon SQS Developer Guide*.
  #
  # <note markdown="1"> Cross-account permissions don't apply to this action. For more
  # information, see [Grant cross-account permissions to a role and a user
  # name][2] in the *Amazon SQS Developer Guide*.
  #
  #  </note>
  #
  #
  #
  # [1]: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-queue-tags.html
  # [2]: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-customer-managed-policy-examples.html#grant-cross-account-permissions-to-role-and-user-name
  #
  # @example Request syntax with placeholder values
  #
  #   resp = client.list_queue_tags({
  #   queue_url: "String", # required
  #   })
  # @example Response structure
  #
  #   resp.tags #=> Hash
  #   resp.tags["TagKey"] #=> String
  # @option params
  # @overload list_queue_tags
  # @param params [Hash] ({})
  # @return [Types::ListQueueTagsResult] Returns a {Seahorse::Client::Response response} object which responds to the following methods:
  #
  #   * {Types::ListQueueTagsResult#tags #tags} => Hash&lt;String,String&gt;
  # @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/ListQueueTags AWS API Documentation
  def list_queue_tags(params = T.unsafe(nil), options = T.unsafe(nil)); end

  # Returns a list of your queues in the current region. The response
  # includes a maximum of 1,000 results. If you specify a value for the
  # optional `QueueNamePrefix` parameter, only queues with a name that
  # begins with the specified value are returned.
  #
  # The `listQueues` methods supports pagination. Set parameter
  # `MaxResults` in the request to specify the maximum number of results
  # to be returned in the response. If you do not set `MaxResults`, the
  # response includes a maximum of 1,000 results. If you set `MaxResults`
  # and there are additional results to display, the response includes a
  # value for `NextToken`. Use `NextToken` as a parameter in your next
  # request to `listQueues` to receive the next page of results.
  #
  # <note markdown="1"> Cross-account permissions don't apply to this action. For more
  # information, see [Grant cross-account permissions to a role and a user
  # name][1] in the *Amazon SQS Developer Guide*.
  #
  #  </note>
  #
  #
  #
  # [1]: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-customer-managed-policy-examples.html#grant-cross-account-permissions-to-role-and-user-name
  #
  # The returned {Seahorse::Client::Response response} is a pageable response and is Enumerable. For details on usage see {Aws::PageableResponse PageableResponse}.
  #
  # @example Response structure
  #
  #   resp.queue_urls #=> Array
  #   resp.queue_urls[0] #=> String
  #   resp.next_token #=> String
  # @example Request syntax with placeholder values
  #
  #   resp = client.list_queues({
  #   queue_name_prefix: "String",
  #   next_token: "Token",
  #   max_results: 1,
  #   })
  # @option params
  # @option params
  # @option params
  # @overload list_queues
  # @param params [Hash] ({})
  # @return [Types::ListQueuesResult] Returns a {Seahorse::Client::Response response} object which responds to the following methods:
  #
  #   * {Types::ListQueuesResult#queue_urls #queue_urls} => Array&lt;String&gt;
  #   * {Types::ListQueuesResult#next_token #next_token} => String
  # @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/ListQueues AWS API Documentation
  def list_queues(params = T.unsafe(nil), options = T.unsafe(nil)); end

  # Deletes the messages in a queue specified by the `QueueURL` parameter.
  #
  # When you use the `PurgeQueue` action, you can't retrieve any messages
  # deleted from a queue.
  #
  #  The message deletion process takes up to 60 seconds. We recommend
  # waiting for 60 seconds regardless of your queue's size.
  #
  # Messages sent to the queue *before* you call `PurgeQueue` might be
  # received but are deleted within the next minute.
  #
  # Messages sent to the queue *after* you call `PurgeQueue` might be
  # deleted while the queue is being purged.
  #
  # @example Request syntax with placeholder values
  #
  #   resp = client.purge_queue({
  #   queue_url: "String", # required
  #   })
  # @option params
  # @overload purge_queue
  # @param params [Hash] ({})
  # @return [Struct] Returns an empty {Seahorse::Client::Response response}.
  # @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/PurgeQueue AWS API Documentation
  def purge_queue(params = T.unsafe(nil), options = T.unsafe(nil)); end

  # Retrieves one or more messages (up to 10), from the specified queue.
  # Using the `WaitTimeSeconds` parameter enables long-poll support. For
  # more information, see [Amazon SQS Long Polling][1] in the *Amazon SQS
  # Developer Guide*.
  #
  # Short poll is the default behavior where a weighted random set of
  # machines is sampled on a `ReceiveMessage` call. Thus, only the
  # messages on the sampled machines are returned. If the number of
  # messages in the queue is small (fewer than 1,000), you most likely get
  # fewer messages than you requested per `ReceiveMessage` call. If the
  # number of messages in the queue is extremely small, you might not
  # receive any messages in a particular `ReceiveMessage` response. If
  # this happens, repeat the request.
  #
  # For each message returned, the response includes the following:
  #
  # * The message body.
  #
  # * An MD5 digest of the message body. For information about MD5, see
  #   [RFC1321][2].
  #
  # * The `MessageId` you received when you sent the message to the queue.
  #
  # * The receipt handle.
  #
  # * The message attributes.
  #
  # * An MD5 digest of the message attributes.
  #
  # The receipt handle is the identifier you must provide when deleting
  # the message. For more information, see [Queue and Message
  # Identifiers][3] in the *Amazon SQS Developer Guide*.
  #
  # You can provide the `VisibilityTimeout` parameter in your request. The
  # parameter is applied to the messages that Amazon SQS returns in the
  # response. If you don't include the parameter, the overall visibility
  # timeout for the queue is used for the returned messages. For more
  # information, see [Visibility Timeout][4] in the *Amazon SQS Developer
  # Guide*.
  #
  # A message that isn't deleted or a message whose visibility isn't
  # extended before the visibility timeout expires counts as a failed
  # receive. Depending on the configuration of the queue, the message
  # might be sent to the dead-letter queue.
  #
  # <note markdown="1"> In the future, new attributes might be added. If you write code that
  # calls this action, we recommend that you structure your code so that
  # it can handle new attributes gracefully.
  #
  #  </note>
  #
  #
  #
  # [1]: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-long-polling.html
  # [2]: https://www.ietf.org/rfc/rfc1321.txt
  # [3]: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-queue-message-identifiers.html
  # [4]: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-visibility-timeout.html
  #
  # @example Response structure
  #
  #   resp.messages #=> Array
  #   resp.messages[0].message_id #=> String
  #   resp.messages[0].receipt_handle #=> String
  #   resp.messages[0].md5_of_body #=> String
  #   resp.messages[0].body #=> String
  #   resp.messages[0].attributes #=> Hash
  #   resp.messages[0].attributes["MessageSystemAttributeName"] #=> String
  #   resp.messages[0].md5_of_message_attributes #=> String
  #   resp.messages[0].message_attributes #=> Hash
  #   resp.messages[0].message_attributes["String"].string_value #=> String
  #   resp.messages[0].message_attributes["String"].binary_value #=> String
  #   resp.messages[0].message_attributes["String"].string_list_values #=> Array
  #   resp.messages[0].message_attributes["String"].string_list_values[0] #=> String
  #   resp.messages[0].message_attributes["String"].binary_list_values #=> Array
  #   resp.messages[0].message_attributes["String"].binary_list_values[0] #=> String
  #   resp.messages[0].message_attributes["String"].data_type #=> String
  # @example Request syntax with placeholder values
  #
  #   resp = client.receive_message({
  #   queue_url: "String", # required
  #   attribute_names: ["All"], # accepts All, Policy, VisibilityTimeout, MaximumMessageSize, MessageRetentionPeriod, ApproximateNumberOfMessages, ApproximateNumberOfMessagesNotVisible, CreatedTimestamp, LastModifiedTimestamp, QueueArn, ApproximateNumberOfMessagesDelayed, DelaySeconds, ReceiveMessageWaitTimeSeconds, RedrivePolicy, FifoQueue, ContentBasedDeduplication, KmsMasterKeyId, KmsDataKeyReusePeriodSeconds, DeduplicationScope, FifoThroughputLimit, RedriveAllowPolicy, SqsManagedSseEnabled
  #   message_attribute_names: ["MessageAttributeName"],
  #   max_number_of_messages: 1,
  #   visibility_timeout: 1,
  #   wait_time_seconds: 1,
  #   receive_request_attempt_id: "String",
  #   })
  # @option params
  # @option params
  # @option params
  # @option params
  # @option params
  # @option params
  # @option params
  # @overload receive_message
  # @param params [Hash] ({})
  # @return [Types::ReceiveMessageResult] Returns a {Seahorse::Client::Response response} object which responds to the following methods:
  #
  #   * {Types::ReceiveMessageResult#messages #messages} => Array&lt;Types::Message&gt;
  # @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/ReceiveMessage AWS API Documentation
  def receive_message(params = T.unsafe(nil), options = T.unsafe(nil)); end

  # Revokes any permissions in the queue policy that matches the specified
  # `Label` parameter.
  #
  # <note markdown="1"> * Only the owner of a queue can remove permissions from it.
  #
  # * Cross-account permissions don't apply to this action. For more
  #   information, see [Grant cross-account permissions to a role and a
  #   user name][1] in the *Amazon SQS Developer Guide*.
  #
  # * To remove the ability to change queue permissions, you must deny
  #   permission to the `AddPermission`, `RemovePermission`, and
  #   `SetQueueAttributes` actions in your IAM policy.
  #
  #  </note>
  #
  #
  #
  # [1]: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-customer-managed-policy-examples.html#grant-cross-account-permissions-to-role-and-user-name
  #
  # @example Request syntax with placeholder values
  #
  #   resp = client.remove_permission({
  #   queue_url: "String", # required
  #   label: "String", # required
  #   })
  # @option params
  # @option params
  # @overload remove_permission
  # @param params [Hash] ({})
  # @return [Struct] Returns an empty {Seahorse::Client::Response response}.
  # @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/RemovePermission AWS API Documentation
  def remove_permission(params = T.unsafe(nil), options = T.unsafe(nil)); end

  # Delivers a message to the specified queue.
  #
  # A message can include only XML, JSON, and unformatted text. The
  # following Unicode characters are allowed:
  #
  #  `#x9` \| `#xA` \| `#xD` \| `#x20` to `#xD7FF` \| `#xE000` to `#xFFFD`
  # \| `#x10000` to `#x10FFFF`
  #
  #  Any characters not included in this list will be rejected. For more
  # information, see the [W3C specification for characters][1].
  #
  #
  #
  # [1]: http://www.w3.org/TR/REC-xml/#charsets
  #
  # @example Response structure
  #
  #   resp.md5_of_message_body #=> String
  #   resp.md5_of_message_attributes #=> String
  #   resp.md5_of_message_system_attributes #=> String
  #   resp.message_id #=> String
  #   resp.sequence_number #=> String
  # @example Request syntax with placeholder values
  #
  #   resp = client.send_message({
  #   queue_url: "String", # required
  #   message_body: "String", # required
  #   delay_seconds: 1,
  #   message_attributes: {
  #   "String" => {
  #   string_value: "String",
  #   binary_value: "data",
  #   string_list_values: ["String"],
  #   binary_list_values: ["data"],
  #   data_type: "String", # required
  #   },
  #   },
  #   message_system_attributes: {
  #   "AWSTraceHeader" => {
  #   string_value: "String",
  #   binary_value: "data",
  #   string_list_values: ["String"],
  #   binary_list_values: ["data"],
  #   data_type: "String", # required
  #   },
  #   },
  #   message_deduplication_id: "String",
  #   message_group_id: "String",
  #   })
  # @option params
  # @option params
  # @option params
  # @option params
  # @option params
  # @option params
  # @option params
  # @overload send_message
  # @param params [Hash] ({})
  # @return [Types::SendMessageResult] Returns a {Seahorse::Client::Response response} object which responds to the following methods:
  #
  #   * {Types::SendMessageResult#md5_of_message_body #md5_of_message_body} => String
  #   * {Types::SendMessageResult#md5_of_message_attributes #md5_of_message_attributes} => String
  #   * {Types::SendMessageResult#md5_of_message_system_attributes #md5_of_message_system_attributes} => String
  #   * {Types::SendMessageResult#message_id #message_id} => String
  #   * {Types::SendMessageResult#sequence_number #sequence_number} => String
  # @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/SendMessage AWS API Documentation
  def send_message(params = T.unsafe(nil), options = T.unsafe(nil)); end

  # Delivers up to ten messages to the specified queue. This is a batch
  # version of ` SendMessage.` For a FIFO queue, multiple messages within
  # a single batch are enqueued in the order they are sent.
  #
  # The result of sending each message is reported individually in the
  # response. Because the batch request can result in a combination of
  # successful and unsuccessful actions, you should check for batch errors
  # even when the call returns an HTTP status code of `200`.
  #
  # The maximum allowed individual message size and the maximum total
  # payload size (the sum of the individual lengths of all of the batched
  # messages) are both 256 KB (262,144 bytes).
  #
  # A message can include only XML, JSON, and unformatted text. The
  # following Unicode characters are allowed:
  #
  #  `#x9` \| `#xA` \| `#xD` \| `#x20` to `#xD7FF` \| `#xE000` to `#xFFFD`
  # \| `#x10000` to `#x10FFFF`
  #
  #  Any characters not included in this list will be rejected. For more
  # information, see the [W3C specification for characters][1].
  #
  # If you don't specify the `DelaySeconds` parameter for an entry,
  # Amazon SQS uses the default value for the queue.
  #
  # Some actions take lists of parameters. These lists are specified using
  # the `param.n` notation. Values of `n` are integers starting from 1.
  # For example, a parameter list with two elements looks like this:
  #
  # `&AttributeName.1=first`
  #
  # `&AttributeName.2=second`
  #
  #
  #
  # [1]: http://www.w3.org/TR/REC-xml/#charsets
  #
  # @example Request syntax with placeholder values
  #
  #   resp = client.send_message_batch({
  #   queue_url: "String", # required
  #   entries: [ # required
  #   {
  #   id: "String", # required
  #   message_body: "String", # required
  #   delay_seconds: 1,
  #   message_attributes: {
  #   "String" => {
  #   string_value: "String",
  #   binary_value: "data",
  #   string_list_values: ["String"],
  #   binary_list_values: ["data"],
  #   data_type: "String", # required
  #   },
  #   },
  #   message_system_attributes: {
  #   "AWSTraceHeader" => {
  #   string_value: "String",
  #   binary_value: "data",
  #   string_list_values: ["String"],
  #   binary_list_values: ["data"],
  #   data_type: "String", # required
  #   },
  #   },
  #   message_deduplication_id: "String",
  #   message_group_id: "String",
  #   },
  #   ],
  #   })
  # @example Response structure
  #
  #   resp.successful #=> Array
  #   resp.successful[0].id #=> String
  #   resp.successful[0].message_id #=> String
  #   resp.successful[0].md5_of_message_body #=> String
  #   resp.successful[0].md5_of_message_attributes #=> String
  #   resp.successful[0].md5_of_message_system_attributes #=> String
  #   resp.successful[0].sequence_number #=> String
  #   resp.failed #=> Array
  #   resp.failed[0].id #=> String
  #   resp.failed[0].sender_fault #=> Boolean
  #   resp.failed[0].code #=> String
  #   resp.failed[0].message #=> String
  # @option params
  # @option params
  # @overload send_message_batch
  # @param params [Hash] ({})
  # @return [Types::SendMessageBatchResult] Returns a {Seahorse::Client::Response response} object which responds to the following methods:
  #
  #   * {Types::SendMessageBatchResult#successful #successful} => Array&lt;Types::SendMessageBatchResultEntry&gt;
  #   * {Types::SendMessageBatchResult#failed #failed} => Array&lt;Types::BatchResultErrorEntry&gt;
  # @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/SendMessageBatch AWS API Documentation
  def send_message_batch(params = T.unsafe(nil), options = T.unsafe(nil)); end

  # Sets the value of one or more queue attributes. When you change a
  # queue's attributes, the change can take up to 60 seconds for most of
  # the attributes to propagate throughout the Amazon SQS system. Changes
  # made to the `MessageRetentionPeriod` attribute can take up to 15
  # minutes.
  #
  # <note markdown="1"> * In the future, new attributes might be added. If you write code that
  #   calls this action, we recommend that you structure your code so that
  #   it can handle new attributes gracefully.
  #
  # * Cross-account permissions don't apply to this action. For more
  #   information, see [Grant cross-account permissions to a role and a
  #   user name][1] in the *Amazon SQS Developer Guide*.
  #
  # * To remove the ability to change queue permissions, you must deny
  #   permission to the `AddPermission`, `RemovePermission`, and
  #   `SetQueueAttributes` actions in your IAM policy.
  #
  #  </note>
  #
  #
  #
  # [1]: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-customer-managed-policy-examples.html#grant-cross-account-permissions-to-role-and-user-name
  #
  # @example Request syntax with placeholder values
  #
  #   resp = client.set_queue_attributes({
  #   queue_url: "String", # required
  #   attributes: { # required
  #   "All" => "String",
  #   },
  #   })
  # @option params
  # @option params
  # @overload set_queue_attributes
  # @param params [Hash] ({})
  # @return [Struct] Returns an empty {Seahorse::Client::Response response}.
  # @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/SetQueueAttributes AWS API Documentation
  def set_queue_attributes(params = T.unsafe(nil), options = T.unsafe(nil)); end

  # Add cost allocation tags to the specified Amazon SQS queue. For an
  # overview, see [Tagging Your Amazon SQS Queues][1] in the *Amazon SQS
  # Developer Guide*.
  #
  # When you use queue tags, keep the following guidelines in mind:
  #
  # * Adding more than 50 tags to a queue isn't recommended.
  #
  # * Tags don't have any semantic meaning. Amazon SQS interprets tags as
  #   character strings.
  #
  # * Tags are case-sensitive.
  #
  # * A new tag with a key identical to that of an existing tag overwrites
  #   the existing tag.
  #
  # For a full list of tag restrictions, see [Quotas related to queues][2]
  # in the *Amazon SQS Developer Guide*.
  #
  # <note markdown="1"> Cross-account permissions don't apply to this action. For more
  # information, see [Grant cross-account permissions to a role and a user
  # name][3] in the *Amazon SQS Developer Guide*.
  #
  #  </note>
  #
  #
  #
  # [1]: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-queue-tags.html
  # [2]: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-limits.html#limits-queues
  # [3]: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-customer-managed-policy-examples.html#grant-cross-account-permissions-to-role-and-user-name
  #
  # @example Request syntax with placeholder values
  #
  #   resp = client.tag_queue({
  #   queue_url: "String", # required
  #   tags: { # required
  #   "TagKey" => "TagValue",
  #   },
  #   })
  # @option params
  # @option params
  # @overload tag_queue
  # @param params [Hash] ({})
  # @return [Struct] Returns an empty {Seahorse::Client::Response response}.
  # @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/TagQueue AWS API Documentation
  def tag_queue(params = T.unsafe(nil), options = T.unsafe(nil)); end

  # Remove cost allocation tags from the specified Amazon SQS queue. For
  # an overview, see [Tagging Your Amazon SQS Queues][1] in the *Amazon
  # SQS Developer Guide*.
  #
  # <note markdown="1"> Cross-account permissions don't apply to this action. For more
  # information, see [Grant cross-account permissions to a role and a user
  # name][2] in the *Amazon SQS Developer Guide*.
  #
  #  </note>
  #
  #
  #
  # [1]: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-queue-tags.html
  # [2]: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-customer-managed-policy-examples.html#grant-cross-account-permissions-to-role-and-user-name
  #
  # @example Request syntax with placeholder values
  #
  #   resp = client.untag_queue({
  #   queue_url: "String", # required
  #   tag_keys: ["TagKey"], # required
  #   })
  # @option params
  # @option params
  # @overload untag_queue
  # @param params [Hash] ({})
  # @return [Struct] Returns an empty {Seahorse::Client::Response response}.
  # @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/UntagQueue AWS API Documentation
  def untag_queue(params = T.unsafe(nil), options = T.unsafe(nil)); end

  # @api private
  # @deprecated
  def waiter_names; end

  class << self
    # @api private
    def errors_module; end

    # @api private
    def identifier; end
  end
end

# @api private
module Aws::SQS::ClientApi
  include ::Seahorse::Model
end

# @api private
Aws::SQS::ClientApi::API = T.let(T.unsafe(nil), Seahorse::Model::Api)

# @api private
Aws::SQS::ClientApi::AWSAccountIdList = T.let(T.unsafe(nil), Seahorse::Model::Shapes::ListShape)

# @api private
Aws::SQS::ClientApi::ActionNameList = T.let(T.unsafe(nil), Seahorse::Model::Shapes::ListShape)

# @api private
Aws::SQS::ClientApi::AddPermissionRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::AttributeNameList = T.let(T.unsafe(nil), Seahorse::Model::Shapes::ListShape)

# @api private
Aws::SQS::ClientApi::BatchEntryIdsNotDistinct = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::BatchRequestTooLong = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::BatchResultErrorEntry = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::BatchResultErrorEntryList = T.let(T.unsafe(nil), Seahorse::Model::Shapes::ListShape)

# @api private
Aws::SQS::ClientApi::Binary = T.let(T.unsafe(nil), Seahorse::Model::Shapes::BlobShape)

# @api private
Aws::SQS::ClientApi::BinaryList = T.let(T.unsafe(nil), Seahorse::Model::Shapes::ListShape)

# @api private
Aws::SQS::ClientApi::Boolean = T.let(T.unsafe(nil), Seahorse::Model::Shapes::BooleanShape)

# @api private
Aws::SQS::ClientApi::BoxedInteger = T.let(T.unsafe(nil), Seahorse::Model::Shapes::IntegerShape)

# @api private
Aws::SQS::ClientApi::ChangeMessageVisibilityBatchRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::ChangeMessageVisibilityBatchRequestEntry = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::ChangeMessageVisibilityBatchRequestEntryList = T.let(T.unsafe(nil), Seahorse::Model::Shapes::ListShape)

# @api private
Aws::SQS::ClientApi::ChangeMessageVisibilityBatchResult = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::ChangeMessageVisibilityBatchResultEntry = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::ChangeMessageVisibilityBatchResultEntryList = T.let(T.unsafe(nil), Seahorse::Model::Shapes::ListShape)

# @api private
Aws::SQS::ClientApi::ChangeMessageVisibilityRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::CreateQueueRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::CreateQueueResult = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::DeleteMessageBatchRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::DeleteMessageBatchRequestEntry = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::DeleteMessageBatchRequestEntryList = T.let(T.unsafe(nil), Seahorse::Model::Shapes::ListShape)

# @api private
Aws::SQS::ClientApi::DeleteMessageBatchResult = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::DeleteMessageBatchResultEntry = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::DeleteMessageBatchResultEntryList = T.let(T.unsafe(nil), Seahorse::Model::Shapes::ListShape)

# @api private
Aws::SQS::ClientApi::DeleteMessageRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::DeleteQueueRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::EmptyBatchRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::GetQueueAttributesRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::GetQueueAttributesResult = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::GetQueueUrlRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::GetQueueUrlResult = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::Integer = T.let(T.unsafe(nil), Seahorse::Model::Shapes::IntegerShape)

# @api private
Aws::SQS::ClientApi::InvalidAttributeName = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::InvalidBatchEntryId = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::InvalidIdFormat = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::InvalidMessageContents = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::ListDeadLetterSourceQueuesRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::ListDeadLetterSourceQueuesResult = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::ListQueueTagsRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::ListQueueTagsResult = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::ListQueuesRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::ListQueuesResult = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::Message = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::MessageAttributeName = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StringShape)

# @api private
Aws::SQS::ClientApi::MessageAttributeNameList = T.let(T.unsafe(nil), Seahorse::Model::Shapes::ListShape)

# @api private
Aws::SQS::ClientApi::MessageAttributeValue = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::MessageBodyAttributeMap = T.let(T.unsafe(nil), Seahorse::Model::Shapes::MapShape)

# @api private
Aws::SQS::ClientApi::MessageBodySystemAttributeMap = T.let(T.unsafe(nil), Seahorse::Model::Shapes::MapShape)

# @api private
Aws::SQS::ClientApi::MessageList = T.let(T.unsafe(nil), Seahorse::Model::Shapes::ListShape)

# @api private
Aws::SQS::ClientApi::MessageNotInflight = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::MessageSystemAttributeMap = T.let(T.unsafe(nil), Seahorse::Model::Shapes::MapShape)

# @api private
Aws::SQS::ClientApi::MessageSystemAttributeName = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StringShape)

# @api private
Aws::SQS::ClientApi::MessageSystemAttributeNameForSends = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StringShape)

# @api private
Aws::SQS::ClientApi::MessageSystemAttributeValue = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::OverLimit = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::PurgeQueueInProgress = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::PurgeQueueRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::QueueAttributeMap = T.let(T.unsafe(nil), Seahorse::Model::Shapes::MapShape)

# @api private
Aws::SQS::ClientApi::QueueAttributeName = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StringShape)

# @api private
Aws::SQS::ClientApi::QueueDeletedRecently = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::QueueDoesNotExist = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::QueueNameExists = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::QueueUrlList = T.let(T.unsafe(nil), Seahorse::Model::Shapes::ListShape)

# @api private
Aws::SQS::ClientApi::ReceiptHandleIsInvalid = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::ReceiveMessageRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::ReceiveMessageResult = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::RemovePermissionRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::SendMessageBatchRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::SendMessageBatchRequestEntry = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::SendMessageBatchRequestEntryList = T.let(T.unsafe(nil), Seahorse::Model::Shapes::ListShape)

# @api private
Aws::SQS::ClientApi::SendMessageBatchResult = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::SendMessageBatchResultEntry = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::SendMessageBatchResultEntryList = T.let(T.unsafe(nil), Seahorse::Model::Shapes::ListShape)

# @api private
Aws::SQS::ClientApi::SendMessageRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::SendMessageResult = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::SetQueueAttributesRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::String = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StringShape)

# @api private
Aws::SQS::ClientApi::StringList = T.let(T.unsafe(nil), Seahorse::Model::Shapes::ListShape)

# @api private
Aws::SQS::ClientApi::TagKey = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StringShape)

# @api private
Aws::SQS::ClientApi::TagKeyList = T.let(T.unsafe(nil), Seahorse::Model::Shapes::ListShape)

# @api private
Aws::SQS::ClientApi::TagMap = T.let(T.unsafe(nil), Seahorse::Model::Shapes::MapShape)

# @api private
Aws::SQS::ClientApi::TagQueueRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::TagValue = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StringShape)

# @api private
Aws::SQS::ClientApi::Token = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StringShape)

# @api private
Aws::SQS::ClientApi::TooManyEntriesInBatchRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::UnsupportedOperation = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# @api private
Aws::SQS::ClientApi::UntagQueueRequest = T.let(T.unsafe(nil), Seahorse::Model::Shapes::StructureShape)

# When SQS returns an error response, the Ruby SDK constructs and raises an error.
# These errors all extend Aws::SQS::Errors::ServiceError < {Aws::Errors::ServiceError}
#
# You can rescue all SQS errors using ServiceError:
#
#     begin
#       # do stuff
#     rescue Aws::SQS::Errors::ServiceError
#       # rescues all SQS API errors
#     end
#
#
# ## Request Context
# ServiceError objects have a {Aws::Errors::ServiceError#context #context} method that returns
# information about the request that generated the error.
# See {Seahorse::Client::RequestContext} for more information.
#
# ## Error Classes
# * {BatchEntryIdsNotDistinct}
# * {BatchRequestTooLong}
# * {EmptyBatchRequest}
# * {InvalidAttributeName}
# * {InvalidBatchEntryId}
# * {InvalidIdFormat}
# * {InvalidMessageContents}
# * {MessageNotInflight}
# * {OverLimit}
# * {PurgeQueueInProgress}
# * {QueueDeletedRecently}
# * {QueueDoesNotExist}
# * {QueueNameExists}
# * {ReceiptHandleIsInvalid}
# * {TooManyEntriesInBatchRequest}
# * {UnsupportedOperation}
#
# Additionally, error classes are dynamically generated for service errors based on the error code
# if they are not defined above.
module Aws::SQS::Errors
  extend ::Aws::Errors::DynamicErrors
end

class Aws::SQS::Errors::BatchEntryIdsNotDistinct < ::Aws::SQS::Errors::ServiceError
  # @param context [Seahorse::Client::RequestContext]
  # @param message [String]
  # @param data [Aws::SQS::Types::BatchEntryIdsNotDistinct]
  # @return [BatchEntryIdsNotDistinct] a new instance of BatchEntryIdsNotDistinct
  def initialize(context, message, data = T.unsafe(nil)); end
end

class Aws::SQS::Errors::BatchRequestTooLong < ::Aws::SQS::Errors::ServiceError
  # @param context [Seahorse::Client::RequestContext]
  # @param message [String]
  # @param data [Aws::SQS::Types::BatchRequestTooLong]
  # @return [BatchRequestTooLong] a new instance of BatchRequestTooLong
  def initialize(context, message, data = T.unsafe(nil)); end
end

class Aws::SQS::Errors::EmptyBatchRequest < ::Aws::SQS::Errors::ServiceError
  # @param context [Seahorse::Client::RequestContext]
  # @param message [String]
  # @param data [Aws::SQS::Types::EmptyBatchRequest]
  # @return [EmptyBatchRequest] a new instance of EmptyBatchRequest
  def initialize(context, message, data = T.unsafe(nil)); end
end

class Aws::SQS::Errors::InvalidAttributeName < ::Aws::SQS::Errors::ServiceError
  # @param context [Seahorse::Client::RequestContext]
  # @param message [String]
  # @param data [Aws::SQS::Types::InvalidAttributeName]
  # @return [InvalidAttributeName] a new instance of InvalidAttributeName
  def initialize(context, message, data = T.unsafe(nil)); end
end

class Aws::SQS::Errors::InvalidBatchEntryId < ::Aws::SQS::Errors::ServiceError
  # @param context [Seahorse::Client::RequestContext]
  # @param message [String]
  # @param data [Aws::SQS::Types::InvalidBatchEntryId]
  # @return [InvalidBatchEntryId] a new instance of InvalidBatchEntryId
  def initialize(context, message, data = T.unsafe(nil)); end
end

class Aws::SQS::Errors::InvalidIdFormat < ::Aws::SQS::Errors::ServiceError
  # @param context [Seahorse::Client::RequestContext]
  # @param message [String]
  # @param data [Aws::SQS::Types::InvalidIdFormat]
  # @return [InvalidIdFormat] a new instance of InvalidIdFormat
  def initialize(context, message, data = T.unsafe(nil)); end
end

class Aws::SQS::Errors::InvalidMessageContents < ::Aws::SQS::Errors::ServiceError
  # @param context [Seahorse::Client::RequestContext]
  # @param message [String]
  # @param data [Aws::SQS::Types::InvalidMessageContents]
  # @return [InvalidMessageContents] a new instance of InvalidMessageContents
  def initialize(context, message, data = T.unsafe(nil)); end
end

class Aws::SQS::Errors::MessageNotInflight < ::Aws::SQS::Errors::ServiceError
  # @param context [Seahorse::Client::RequestContext]
  # @param message [String]
  # @param data [Aws::SQS::Types::MessageNotInflight]
  # @return [MessageNotInflight] a new instance of MessageNotInflight
  def initialize(context, message, data = T.unsafe(nil)); end
end

class Aws::SQS::Errors::OverLimit < ::Aws::SQS::Errors::ServiceError
  # @param context [Seahorse::Client::RequestContext]
  # @param message [String]
  # @param data [Aws::SQS::Types::OverLimit]
  # @return [OverLimit] a new instance of OverLimit
  def initialize(context, message, data = T.unsafe(nil)); end
end

class Aws::SQS::Errors::PurgeQueueInProgress < ::Aws::SQS::Errors::ServiceError
  # @param context [Seahorse::Client::RequestContext]
  # @param message [String]
  # @param data [Aws::SQS::Types::PurgeQueueInProgress]
  # @return [PurgeQueueInProgress] a new instance of PurgeQueueInProgress
  def initialize(context, message, data = T.unsafe(nil)); end
end

class Aws::SQS::Errors::QueueDeletedRecently < ::Aws::SQS::Errors::ServiceError
  # @param context [Seahorse::Client::RequestContext]
  # @param message [String]
  # @param data [Aws::SQS::Types::QueueDeletedRecently]
  # @return [QueueDeletedRecently] a new instance of QueueDeletedRecently
  def initialize(context, message, data = T.unsafe(nil)); end
end

class Aws::SQS::Errors::QueueDoesNotExist < ::Aws::SQS::Errors::ServiceError
  # @param context [Seahorse::Client::RequestContext]
  # @param message [String]
  # @param data [Aws::SQS::Types::QueueDoesNotExist]
  # @return [QueueDoesNotExist] a new instance of QueueDoesNotExist
  def initialize(context, message, data = T.unsafe(nil)); end
end

class Aws::SQS::Errors::QueueNameExists < ::Aws::SQS::Errors::ServiceError
  # @param context [Seahorse::Client::RequestContext]
  # @param message [String]
  # @param data [Aws::SQS::Types::QueueNameExists]
  # @return [QueueNameExists] a new instance of QueueNameExists
  def initialize(context, message, data = T.unsafe(nil)); end
end

class Aws::SQS::Errors::ReceiptHandleIsInvalid < ::Aws::SQS::Errors::ServiceError
  # @param context [Seahorse::Client::RequestContext]
  # @param message [String]
  # @param data [Aws::SQS::Types::ReceiptHandleIsInvalid]
  # @return [ReceiptHandleIsInvalid] a new instance of ReceiptHandleIsInvalid
  def initialize(context, message, data = T.unsafe(nil)); end
end

class Aws::SQS::Errors::ServiceError < ::Aws::Errors::ServiceError; end

class Aws::SQS::Errors::TooManyEntriesInBatchRequest < ::Aws::SQS::Errors::ServiceError
  # @param context [Seahorse::Client::RequestContext]
  # @param message [String]
  # @param data [Aws::SQS::Types::TooManyEntriesInBatchRequest]
  # @return [TooManyEntriesInBatchRequest] a new instance of TooManyEntriesInBatchRequest
  def initialize(context, message, data = T.unsafe(nil)); end
end

class Aws::SQS::Errors::UnsupportedOperation < ::Aws::SQS::Errors::ServiceError
  # @param context [Seahorse::Client::RequestContext]
  # @param message [String]
  # @param data [Aws::SQS::Types::UnsupportedOperation]
  # @return [UnsupportedOperation] a new instance of UnsupportedOperation
  def initialize(context, message, data = T.unsafe(nil)); end
end

Aws::SQS::GEM_VERSION = T.let(T.unsafe(nil), String)

class Aws::SQS::Message
  extend ::Aws::Deprecations

  # @overload initialize
  # @overload initialize
  # @return [Message] a new instance of Message
  def initialize(*args); end

  # A map of the attributes requested in ` ReceiveMessage ` to their
  # respective values. Supported attributes:
  #
  # * `ApproximateReceiveCount`
  #
  # * `ApproximateFirstReceiveTimestamp`
  #
  # * `MessageDeduplicationId`
  #
  # * `MessageGroupId`
  #
  # * `SenderId`
  #
  # * `SentTimestamp`
  #
  # * `SequenceNumber`
  #
  # `ApproximateFirstReceiveTimestamp` and `SentTimestamp` are each
  # returned as an integer representing the [epoch time][1] in
  # milliseconds.
  #
  #
  #
  # [1]: http://en.wikipedia.org/wiki/Unix_time
  #
  # @return [Hash<String,String>]
  def attributes; end

  # The message's contents (not URL-encoded).
  #
  # @return [String]
  def body; end

  # @example Request syntax with placeholder values
  #
  #   message.change_visibility({
  #   visibility_timeout: 1, # required
  #   })
  # @option options
  # @param options [Hash] ({})
  # @return [EmptyStructure]
  def change_visibility(options = T.unsafe(nil)); end

  # @return [Client]
  def client; end

  # @raise [NotImplementedError] Raises when {#data_loaded?} is `false`.
  # @return [Types::Message] Returns the data for this {Message}.
  def data; end

  # @return [Boolean] Returns `true` if this resource is loaded.  Accessing attributes or
  #   {#data} on an unloaded resource will trigger a call to {#load}.
  def data_loaded?; end

  # @example Request syntax with placeholder values
  #
  #   message.delete()
  # @param options [Hash] ({})
  # @return [EmptyStructure]
  def delete(options = T.unsafe(nil)); end

  def deprecated_identifiers; end

  # @api private
  # @deprecated
  def identifiers(*args, &block); end

  # @api private
  # @raise [NotImplementedError]
  def load; end

  # An MD5 digest of the non-URL-encoded message body string.
  #
  # @return [String]
  def md5_of_body; end

  # An MD5 digest of the non-URL-encoded message attribute string. You can
  # use this attribute to verify that Amazon SQS received the message
  # correctly. Amazon SQS URL-decodes the message before creating the MD5
  # digest. For information about MD5, see [RFC1321][1].
  #
  #
  #
  # [1]: https://www.ietf.org/rfc/rfc1321.txt
  #
  # @return [String]
  def md5_of_message_attributes; end

  # Each message attribute consists of a `Name`, `Type`, and `Value`. For
  # more information, see [Amazon SQS message attributes][1] in the
  # *Amazon SQS Developer Guide*.
  #
  #
  #
  # [1]: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-message-metadata.html#sqs-message-attributes
  #
  # @return [Hash<String,Types::MessageAttributeValue>]
  def message_attributes; end

  # A unique identifier for the message. A `MessageId`is considered unique
  # across all Amazon Web Services accounts for an extended period of
  # time.
  #
  # @return [String]
  def message_id; end

  # @return [Queue]
  def queue; end

  # @return [String]
  def queue_url; end

  # @return [String]
  def receipt_handle; end

  # @api private
  # @raise [NotImplementedError]
  def reload; end

  private

  def extract_queue_url(args, options); end
  def extract_receipt_handle(args, options); end
end

class Aws::SQS::Message::Collection < ::Aws::Resources::Collection
  # @param options [{}]
  # @return [void]
  def batch_delete!(options = T.unsafe(nil)); end
end

module Aws::SQS::Plugins; end

class Aws::SQS::Plugins::Md5s < ::Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
end

# @api private
class Aws::SQS::Plugins::Md5s::Handler < ::Seahorse::Client::Handler
  # @api private
  def call(context); end

  private

  # @api private
  def encode_length_and_bytes(bytes); end

  # @api private
  def encode_length_and_string(string); end

  # @api private
  def md5_of_message_attributes(message_attributes); end

  # @api private
  def md5_of_message_body(message_body); end

  # @api private
  def mismatch_error_message(section, local_md5, returned_md5, response); end

  # @api private
  def validate_attributes(attributes, response); end

  # @api private
  def validate_body(body, response); end

  # @api private
  def validate_send_message(context, response); end

  # @api private
  def validate_send_message_batch(context, response); end

  # @api private
  def validate_single_message(body, attributes, response); end
end

# @api private
Aws::SQS::Plugins::Md5s::Handler::DATA_TYPE = T.let(T.unsafe(nil), Regexp)

# @api private
Aws::SQS::Plugins::Md5s::Handler::NORMALIZED_ENCODING = T.let(T.unsafe(nil), Encoding)

# @api private
Aws::SQS::Plugins::Md5s::Handler::TRANSPORT_TYPE_ENCODINGS = T.let(T.unsafe(nil), Hash)

# @api private
class Aws::SQS::Plugins::QueueUrls < ::Seahorse::Client::Plugin; end

# @api private
class Aws::SQS::Plugins::QueueUrls::Handler < ::Seahorse::Client::Handler
  # @api private
  def call(context); end

  # @api private
  def update_endpoint(context, url); end

  # If the region in the queue url is not the configured
  # region, then we will modify the request to have
  # a sigv4 signer for the proper region.
  #
  # @api private
  def update_region(context, queue_url); end

  private

  # take the first component after service delimiter
  # https://sqs.us-east-1.amazonaws.com/1234567890/demo
  # https://vpce-x-y.sqs.us-east-1.vpce.amazonaws.com/1234567890/demo
  #
  # @api private
  def parse_region(url); end
end

class Aws::SQS::Queue
  extend ::Aws::Deprecations

  # @overload initialize
  # @overload initialize
  # @return [Queue] a new instance of Queue
  def initialize(*args); end

  # @example Request syntax with placeholder values
  #
  #   queue.add_permission({
  #   label: "String", # required
  #   aws_account_ids: ["String"], # required
  #   actions: ["String"], # required
  #   })
  # @option options
  # @option options
  # @option options
  # @param options [Hash] ({})
  # @return [EmptyStructure]
  def add_permission(options = T.unsafe(nil)); end

  # A map of attributes to their respective values.
  #
  # @return [Hash<String,String>]
  def attributes; end

  # @example Request syntax with placeholder values
  #
  #   queue.change_message_visibility_batch({
  #   entries: [ # required
  #   {
  #   id: "String", # required
  #   receipt_handle: "String", # required
  #   visibility_timeout: 1,
  #   },
  #   ],
  #   })
  # @option options
  # @param options [Hash] ({})
  # @return [Types::ChangeMessageVisibilityBatchResult]
  def change_message_visibility_batch(options = T.unsafe(nil)); end

  # @return [Client]
  def client; end

  # @return [Types::GetQueueAttributesResult] Returns the data for this {Queue}. Calls
  #   {Client#get_queue_attributes} if {#data_loaded?} is `false`.
  def data; end

  # @return [Boolean] Returns `true` if this resource is loaded.  Accessing attributes or
  #   {#data} on an unloaded resource will trigger a call to {#load}.
  def data_loaded?; end

  # @example Request syntax with placeholder values
  #
  #   queue.dead_letter_source_queues()
  # @param options [Hash] ({})
  # @return [Queue::Collection]
  def dead_letter_source_queues(options = T.unsafe(nil)); end

  # @example Request syntax with placeholder values
  #
  #   queue.delete()
  # @param options [Hash] ({})
  # @return [EmptyStructure]
  def delete(options = T.unsafe(nil)); end

  # @example Request syntax with placeholder values
  #
  #   queue.delete_messages({
  #   entries: [ # required
  #   {
  #   id: "String", # required
  #   receipt_handle: "String", # required
  #   },
  #   ],
  #   })
  # @option options
  # @param options [Hash] ({})
  # @return [Types::DeleteMessageBatchResult]
  def delete_messages(options = T.unsafe(nil)); end

  def deprecated_identifiers; end

  # @api private
  # @deprecated
  def identifiers(*args, &block); end

  # Loads, or reloads {#data} for the current {Queue}.
  # Returns `self` making it possible to chain methods.
  #
  #     queue.reload.data
  #
  # @return [self]
  def load; end

  # @param receipt_handle [String]
  # @return [Message]
  def message(receipt_handle); end

  # @example Request syntax with placeholder values
  #
  #   queue.purge()
  # @param options [Hash] ({})
  # @return [EmptyStructure]
  def purge(options = T.unsafe(nil)); end

  # @example Request syntax with placeholder values
  #
  #   message = queue.receive_messages({
  #   attribute_names: ["All"], # accepts All, Policy, VisibilityTimeout, MaximumMessageSize, MessageRetentionPeriod, ApproximateNumberOfMessages, ApproximateNumberOfMessagesNotVisible, CreatedTimestamp, LastModifiedTimestamp, QueueArn, ApproximateNumberOfMessagesDelayed, DelaySeconds, ReceiveMessageWaitTimeSeconds, RedrivePolicy, FifoQueue, ContentBasedDeduplication, KmsMasterKeyId, KmsDataKeyReusePeriodSeconds, DeduplicationScope, FifoThroughputLimit, RedriveAllowPolicy, SqsManagedSseEnabled
  #   message_attribute_names: ["MessageAttributeName"],
  #   max_number_of_messages: 1,
  #   visibility_timeout: 1,
  #   wait_time_seconds: 1,
  #   receive_request_attempt_id: "String",
  #   })
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash] ({})
  # @return [Message::Collection]
  def receive_messages(options = T.unsafe(nil)); end

  # Loads, or reloads {#data} for the current {Queue}.
  # Returns `self` making it possible to chain methods.
  #
  #     queue.reload.data
  #
  # @return [self]
  def reload; end

  # @example Request syntax with placeholder values
  #
  #   queue.remove_permission({
  #   label: "String", # required
  #   })
  # @option options
  # @param options [Hash] ({})
  # @return [EmptyStructure]
  def remove_permission(options = T.unsafe(nil)); end

  # @example Request syntax with placeholder values
  #
  #   queue.send_message({
  #   message_body: "String", # required
  #   delay_seconds: 1,
  #   message_attributes: {
  #   "String" => {
  #   string_value: "String",
  #   binary_value: "data",
  #   string_list_values: ["String"],
  #   binary_list_values: ["data"],
  #   data_type: "String", # required
  #   },
  #   },
  #   message_system_attributes: {
  #   "AWSTraceHeader" => {
  #   string_value: "String",
  #   binary_value: "data",
  #   string_list_values: ["String"],
  #   binary_list_values: ["data"],
  #   data_type: "String", # required
  #   },
  #   },
  #   message_deduplication_id: "String",
  #   message_group_id: "String",
  #   })
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash] ({})
  # @return [Types::SendMessageResult]
  def send_message(options = T.unsafe(nil)); end

  # @example Request syntax with placeholder values
  #
  #   queue.send_messages({
  #   entries: [ # required
  #   {
  #   id: "String", # required
  #   message_body: "String", # required
  #   delay_seconds: 1,
  #   message_attributes: {
  #   "String" => {
  #   string_value: "String",
  #   binary_value: "data",
  #   string_list_values: ["String"],
  #   binary_list_values: ["data"],
  #   data_type: "String", # required
  #   },
  #   },
  #   message_system_attributes: {
  #   "AWSTraceHeader" => {
  #   string_value: "String",
  #   binary_value: "data",
  #   string_list_values: ["String"],
  #   binary_list_values: ["data"],
  #   data_type: "String", # required
  #   },
  #   },
  #   message_deduplication_id: "String",
  #   message_group_id: "String",
  #   },
  #   ],
  #   })
  # @option options
  # @param options [Hash] ({})
  # @return [Types::SendMessageBatchResult]
  def send_messages(options = T.unsafe(nil)); end

  # @example Request syntax with placeholder values
  #
  #   queue.set_attributes({
  #   attributes: { # required
  #   "All" => "String",
  #   },
  #   })
  # @option options
  # @param options [Hash] ({})
  # @return [EmptyStructure]
  def set_attributes(options = T.unsafe(nil)); end

  # @return [String]
  def url; end

  private

  def extract_url(args, options); end
end

class Aws::SQS::Queue::Collection < ::Aws::Resources::Collection; end

# A utility class for long polling messages in a loop. **Messages are
# automatically deleted from the queue at the end of the given block.**
#
#     poller = Aws::SQS::QueuePoller.new(queue_url)
#
#     poller.poll do |msg|
#       puts msg.body
#     end
#
# ## Long Polling
#
# By default, messages are received using long polling. This
# method will force a default `:wait_time_seconds` of 20 seconds.
# If you prefer to use the queue default wait time, then pass
# a `nil` value for `:wait_time_seconds`.
#
#     # disables 20 second default, use queue ReceiveMessageWaitTimeSeconds
#     poller.poll(wait_time_seconds:nil) do |msg|
#       # ...
#     end
#
# When disabling `:wait_time_seconds` by passing `nil`, you must
# ensure the queue `ReceiveMessageWaitTimeSeconds` attribute is
# set to a non-zero value, or you will be short-polling.
# This will trigger significantly more API calls.
#
# ## Batch Receiving Messages
#
# You can specify a maximum number of messages to receive with
# each polling attempt via `:max_number_of_messages`. When this is
# set to a positive value, greater than 1, the block will receive
# an array of messages, instead of a single message.
#
#     # receives and yields 1 message at a time
#     poller.poll do |msg|
#       # ...
#     end
#
#     # receives and yields up to 10 messages at a time
#     poller.poll(max_number_of_messages:10) do |messages|
#       messages.each do |msg|
#         # ...
#       end
#     end
#
# The maximum value for `:max_number_of_messages` is enforced by
# Amazon SQS.
#
# ## Visibility Timeouts
#
# When receiving messages, you have a fixed amount of time to process
# and delete the message before it is added back into the queue. This
# is the visibility timeout. By default, the queue's `VisibilityTimeout`
# attribute is used. You can provide an alternative visibility timeout
# when polling.
#
#     # queue default VisibilityTimeout
#     poller.poll do |msg|
#     end
#
#     # custom visibility timeout
#     poller.poll(visibility_timeout:10) do |msg|
#     end
#
#
# You can reset the visibility timeout of a single message by calling
# {#change_message_visibility_timeout}. This is useful when you need
# more time to finish processing the message.
#
#     poller.poll do |msg|
#
#       # do work ...
#
#       # need more time for processing
#       poller.change_message_visibility_timeout(msg, 60)
#
#       # finish work ...
#
#     end
#
# If you change the visibility timeout of a message to zero, it will
# return to the queue immediately.
#
# ## Deleting Messages
#
# Messages are deleted from the queue when the block returns normally.
#
#     poller.poll do |msg|
#       # do work
#     end # messages deleted here
#
# You can skip message deletion by passing `skip_delete: true`.
# This allows you to manually delete the messages using
# {#delete_message}, or {#delete_messages}.
#
#     # single message
#     poller.poll(skip_delete: true) do |msg|
#       poller.delete_message(msg) # if successful
#     end
#
#     # batch delete messages
#     poller.poll(skip_delete: true, max_number_of_messages:10) do |messages|
#       poller.delete_messages(messages)
#     end
#
# Another way to manage message deletion is to throw `:skip_delete`
# from the poll block. You can use this to choose when a message, or
# message batch is deleted on an individual basis. This can be very
# useful when you are capturing temporal errors and wish for the
# message to timeout.
#
#     poller.poll do |msg|
#       begin
#         # do work
#       rescue
#         # unexpected error occurred while processing messages,
#         # log it, and skip delete so it can be re-processed later
#         throw :skip_delete
#       end
#     end
#
# ## Terminating the Polling Loop
#
# By default, polling will continue indefinitely. You can stop
# the poller by providing an idle timeout or by throwing `:stop_polling`
# from the {#before_request} callback.
#
# ### `:idle_timeout` Option
#
# This is a configurable, maximum number of seconds to wait for a
# new message before the polling loop exists. By default, there is
# no idle timeout.
#
#     # stops polling after a minute of no received messages
#     poller.poll(idle_timeout: 60) do |msg|
#       # ...
#     end
#
# ### Throw `:stop_polling`
#
# If you want more fine grained control, you can configure a
# before request callback to trigger before each long poll. Throwing
# `:stop_polling` from this callback will cause the poller to exit
# normally without making the next request.
#
#     # stop after processing 100 messages
#     poller.before_request do |stats|
#       throw :stop_polling if stats.received_message_count >= 100
#     end
#
#     poller.poll do |msg|
#       # do work ...
#     end
#
# ## Tracking Progress
#
# The poller will automatically track a few statistics client-side in
# a {PollerStats} object. You can access the poller stats
# three ways:
#
# * The first block argument of {#before_request}
# * The second block argument of {#poll}.
# * The return value from {#poll}.
#
# Here are examples of accessing the statistics.
#
# * Configure a {#before_request} callback.
#
#   ```
#   poller.before_request do |stats|
#     logger.info("requests: #{stats.request_count}")
#     logger.info("messages: #{stats.received_message_count}")
#     logger.info("last-timestamp: #{stats.last_message_received_at}")
#   end
#   ```
#
# * Accept a 2nd argument in the poll block, for example:
#
#   ```
#   poller.poll do |msg, stats|
#     logger.info("requests: #{stats.request_count}")
#     logger.info("messages: #{stats.received_message_count}")
#     logger.info("last-timestamp: #{stats.last_message_received_at}")
#   end
#   ```
#
# * Return value:
#
#   ```
#   stats = poller.poll(idle_timeout:10) do |msg|
#     # do work ...
#   end
#   logger.info("requests: #{stats.request_count}")
#   logger.info("messages: #{stats.received_message_count}")
#   logger.info("last-timestamp: #{stats.last_message_received_at}")
#   ```
class Aws::SQS::QueuePoller
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param queue_url [String]
  # @param options [Hash] a customizable set of options
  # @return [QueuePoller] a new instance of QueuePoller
  def initialize(queue_url, options = T.unsafe(nil)); end

  # Registers a callback that is invoked once before every polling
  # attempt.
  #
  #     poller.before_request do |stats|
  #       logger.info("requests: #{stats.request_count}")
  #       logger.info("messages: #{stats.received_message_count}")
  #       logger.info("last-timestamp: #{stats.last_message_received_at}")
  #     end
  #
  #     poller.poll do |msg|
  #       # do work ...
  #     end
  #
  # ## `:stop_polling`
  #
  # If you throw `:stop_polling` from the {#before_request} callback,
  # then the poller will exit normally before making the next long
  # poll request.
  #
  #     poller.before_request do |stats|
  #       throw :stop_polling if stats.received_messages >= 100
  #     end
  #
  #     # at most 100 messages will be yielded
  #     poller.poll do |msg|
  #       # do work ...
  #     end
  #
  # @return [void]
  # @yieldparam stats [PollerStats] An object that tracks a few
  #   client-side statistics about the queue polling.
  def before_request(&block); end

  # @note This method should be called from inside a {#poll} block.
  # @param message [#receipt_handle] An object that responds to
  #   `#receipt_handle`.
  # @param seconds [Integer]
  def change_message_visibility_timeout(message, seconds); end

  # @return [Client]
  def client; end

  # @return [PollerConfig]
  def default_config; end

  # @note This method should be called from inside a {#poll} block.
  # @param message [#receipt_handle] An object that responds to
  #   `#receipt_handle`.
  def delete_message(message); end

  # @note This method should be called from inside a {#poll} block.
  # @param messages [Array<#message_id, #receipt_handle>] An array of received
  #   messages. Each object must respond to `#message_id` and
  #   `#receipt_handle`.
  def delete_messages(messages); end

  # Polls the queue, yielded a message, or an array of messages.
  # Messages are automatically deleted from the queue at the
  # end of the given block. See the class documentation on
  # {QueuePoller} for more examples.
  #
  # @example Basic example, loops indefinitely
  #
  #   poller.poll do |msg|
  #   # ...
  #   end
  # @example Receives and deletes messages as a batch
  #
  #   poller.poll(max_number_of_messages:10) do |messages|
  #   messages.each do |msg|
  #   # ...
  #   end
  #   end
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash] a customizable set of options
  # @return [PollerStats]
  def poll(options = T.unsafe(nil), &block); end

  # @return [String]
  def queue_url; end

  private

  def check_idle_timeout(config, stats, messages); end
  def get_messages(config, stats); end
  def process_messages(config, stats, messages, &block); end
  def send_request(config); end
  def yield_messages(config, messages, stats, &block); end
end

# A read-only set of configuration used by the QueuePoller.
class Aws::SQS::QueuePoller::PollerConfig
  # @return [PollerConfig] a new instance of PollerConfig
  def initialize(options); end

  # @return [Proc, nil]
  def before_request; end

  # @return [Integer, nil]
  def idle_timeout; end

  # @return [Hash]
  def request_params; end

  # @return [Boolean]
  def skip_delete; end

  # @return [PollerConfig] Returns a new {PollerConfig} instance
  #   with the given options applied.
  def with(options); end

  private

  def to_h; end
end

# @api private
Aws::SQS::QueuePoller::PollerConfig::CONFIG_OPTIONS = T.let(T.unsafe(nil), Set)

# @api private
Aws::SQS::QueuePoller::PollerConfig::PARAM_OPTIONS = T.let(T.unsafe(nil), Set)

# Statistics tracked client-side by the {QueuePoller}.
class Aws::SQS::QueuePoller::PollerStats
  # @return [PollerStats] a new instance of PollerStats
  def initialize; end

  # @return [Time, nil]
  def last_message_received_at; end

  # @return [Time, nil]
  def last_message_received_at=(_arg0); end

  # @return [Time]
  def polling_started_at; end

  # @return [Time]
  def polling_started_at=(_arg0); end

  # @return [Time, nil]
  def polling_stopped_at; end

  # @return [Time, nil]
  def polling_stopped_at=(_arg0); end

  # @return [Integer]
  def received_message_count; end

  # @return [Integer]
  def received_message_count=(_arg0); end

  # @return [Integer]
  def request_count; end

  # @return [Integer]
  def request_count=(_arg0); end
end

# This class provides a resource oriented interface for SQS.
# To create a resource object:
#
#     resource = Aws::SQS::Resource.new(region: 'us-west-2')
#
# You can supply a client object with custom configuration that will be used for all resource operations.
# If you do not pass `:client`, a default client will be constructed.
#
#     client = Aws::SQS::Client.new(region: 'us-west-2')
#     resource = Aws::SQS::Resource.new(client: client)
class Aws::SQS::Resource
  # @option options
  # @param options [{}]
  # @return [Resource] a new instance of Resource
  def initialize(options = T.unsafe(nil)); end

  # @return [Client]
  def client; end

  # @example Request syntax with placeholder values
  #
  #   queue = sqs.create_queue({
  #   queue_name: "String", # required
  #   attributes: {
  #   "All" => "String",
  #   },
  #   tags: {
  #   "TagKey" => "TagValue",
  #   },
  #   })
  # @option options
  # @option options
  # @option options
  # @param options [Hash] ({})
  # @return [Queue]
  def create_queue(options = T.unsafe(nil)); end

  # @example Request syntax with placeholder values
  #
  #   queue = sqs.get_queue_by_name({
  #   queue_name: "String", # required
  #   queue_owner_aws_account_id: "String",
  #   })
  # @option options
  # @option options
  # @param options [Hash] ({})
  # @return [Queue]
  def get_queue_by_name(options = T.unsafe(nil)); end

  # @param url [String]
  # @return [Queue]
  def queue(url); end

  # @example Request syntax with placeholder values
  #
  #   queues = sqs.queues({
  #   queue_name_prefix: "String",
  #   })
  # @option options
  # @param options [Hash] ({})
  # @return [Queue::Collection]
  def queues(options = T.unsafe(nil)); end
end

module Aws::SQS::Types; end

# @note When making an API call, you may pass AddPermissionRequest
#   data as a hash:
#
#   {
#   queue_url: "String", # required
#   label: "String", # required
#   aws_account_ids: ["String"], # required
#   actions: ["String"], # required
#   }
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/AddPermissionRequest AWS API Documentation
class Aws::SQS::Types::AddPermissionRequest < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::AddPermissionRequest::SENSITIVE = T.let(T.unsafe(nil), Array)

# Two or more batch entries in the request have the same `Id`.
#
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/BatchEntryIdsNotDistinct AWS API Documentation
class Aws::SQS::Types::BatchEntryIdsNotDistinct < ::Aws::EmptyStructure; end

# The length of all the messages put together is more than the limit.
#
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/BatchRequestTooLong AWS API Documentation
class Aws::SQS::Types::BatchRequestTooLong < ::Aws::EmptyStructure; end

# Gives a detailed description of the result of an action on each entry
# in the request.
#
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/BatchResultErrorEntry AWS API Documentation
class Aws::SQS::Types::BatchResultErrorEntry < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::BatchResultErrorEntry::SENSITIVE = T.let(T.unsafe(nil), Array)

# @note When making an API call, you may pass ChangeMessageVisibilityBatchRequest
#   data as a hash:
#
#   {
#   queue_url: "String", # required
#   entries: [ # required
#   {
#   id: "String", # required
#   receipt_handle: "String", # required
#   visibility_timeout: 1,
#   },
#   ],
#   }
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/ChangeMessageVisibilityBatchRequest AWS API Documentation
class Aws::SQS::Types::ChangeMessageVisibilityBatchRequest < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::ChangeMessageVisibilityBatchRequest::SENSITIVE = T.let(T.unsafe(nil), Array)

# Encloses a receipt handle and an entry id for each message in `
# ChangeMessageVisibilityBatch.`
#
# All of the following list parameters must be prefixed with
# `ChangeMessageVisibilityBatchRequestEntry.n`, where `n` is an integer
# value starting with `1`. For example, a parameter list for this action
# might look like this:
#
# `&ChangeMessageVisibilityBatchRequestEntry.1.Id=change_visibility_msg_2`
#
# `&ChangeMessageVisibilityBatchRequestEntry.1.ReceiptHandle=your_receipt_handle`
#
# `&ChangeMessageVisibilityBatchRequestEntry.1.VisibilityTimeout=45`
#
# @note When making an API call, you may pass ChangeMessageVisibilityBatchRequestEntry
#   data as a hash:
#
#   {
#   id: "String", # required
#   receipt_handle: "String", # required
#   visibility_timeout: 1,
#   }
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/ChangeMessageVisibilityBatchRequestEntry AWS API Documentation
class Aws::SQS::Types::ChangeMessageVisibilityBatchRequestEntry < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::ChangeMessageVisibilityBatchRequestEntry::SENSITIVE = T.let(T.unsafe(nil), Array)

# For each message in the batch, the response contains a `
# ChangeMessageVisibilityBatchResultEntry ` tag if the message succeeds
# or a ` BatchResultErrorEntry ` tag if the message fails.
#
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/ChangeMessageVisibilityBatchResult AWS API Documentation
class Aws::SQS::Types::ChangeMessageVisibilityBatchResult < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::ChangeMessageVisibilityBatchResult::SENSITIVE = T.let(T.unsafe(nil), Array)

# Encloses the `Id` of an entry in ` ChangeMessageVisibilityBatch.`
#
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/ChangeMessageVisibilityBatchResultEntry AWS API Documentation
class Aws::SQS::Types::ChangeMessageVisibilityBatchResultEntry < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::ChangeMessageVisibilityBatchResultEntry::SENSITIVE = T.let(T.unsafe(nil), Array)

# @note When making an API call, you may pass ChangeMessageVisibilityRequest
#   data as a hash:
#
#   {
#   queue_url: "String", # required
#   receipt_handle: "String", # required
#   visibility_timeout: 1, # required
#   }
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/ChangeMessageVisibilityRequest AWS API Documentation
class Aws::SQS::Types::ChangeMessageVisibilityRequest < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::ChangeMessageVisibilityRequest::SENSITIVE = T.let(T.unsafe(nil), Array)

# @note When making an API call, you may pass CreateQueueRequest
#   data as a hash:
#
#   {
#   queue_name: "String", # required
#   attributes: {
#   "All" => "String",
#   },
#   tags: {
#   "TagKey" => "TagValue",
#   },
#   }
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/CreateQueueRequest AWS API Documentation
class Aws::SQS::Types::CreateQueueRequest < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::CreateQueueRequest::SENSITIVE = T.let(T.unsafe(nil), Array)

# Returns the `QueueUrl` attribute of the created queue.
#
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/CreateQueueResult AWS API Documentation
class Aws::SQS::Types::CreateQueueResult < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::CreateQueueResult::SENSITIVE = T.let(T.unsafe(nil), Array)

# @note When making an API call, you may pass DeleteMessageBatchRequest
#   data as a hash:
#
#   {
#   queue_url: "String", # required
#   entries: [ # required
#   {
#   id: "String", # required
#   receipt_handle: "String", # required
#   },
#   ],
#   }
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/DeleteMessageBatchRequest AWS API Documentation
class Aws::SQS::Types::DeleteMessageBatchRequest < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::DeleteMessageBatchRequest::SENSITIVE = T.let(T.unsafe(nil), Array)

# Encloses a receipt handle and an identifier for it.
#
# @note When making an API call, you may pass DeleteMessageBatchRequestEntry
#   data as a hash:
#
#   {
#   id: "String", # required
#   receipt_handle: "String", # required
#   }
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/DeleteMessageBatchRequestEntry AWS API Documentation
class Aws::SQS::Types::DeleteMessageBatchRequestEntry < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::DeleteMessageBatchRequestEntry::SENSITIVE = T.let(T.unsafe(nil), Array)

# For each message in the batch, the response contains a `
# DeleteMessageBatchResultEntry ` tag if the message is deleted or a `
# BatchResultErrorEntry ` tag if the message can't be deleted.
#
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/DeleteMessageBatchResult AWS API Documentation
class Aws::SQS::Types::DeleteMessageBatchResult < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::DeleteMessageBatchResult::SENSITIVE = T.let(T.unsafe(nil), Array)

# Encloses the `Id` of an entry in ` DeleteMessageBatch.`
#
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/DeleteMessageBatchResultEntry AWS API Documentation
class Aws::SQS::Types::DeleteMessageBatchResultEntry < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::DeleteMessageBatchResultEntry::SENSITIVE = T.let(T.unsafe(nil), Array)

# @note When making an API call, you may pass DeleteMessageRequest
#   data as a hash:
#
#   {
#   queue_url: "String", # required
#   receipt_handle: "String", # required
#   }
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/DeleteMessageRequest AWS API Documentation
class Aws::SQS::Types::DeleteMessageRequest < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::DeleteMessageRequest::SENSITIVE = T.let(T.unsafe(nil), Array)

# @note When making an API call, you may pass DeleteQueueRequest
#   data as a hash:
#
#   {
#   queue_url: "String", # required
#   }
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/DeleteQueueRequest AWS API Documentation
class Aws::SQS::Types::DeleteQueueRequest < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::DeleteQueueRequest::SENSITIVE = T.let(T.unsafe(nil), Array)

# The batch request doesn't contain any entries.
#
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/EmptyBatchRequest AWS API Documentation
class Aws::SQS::Types::EmptyBatchRequest < ::Aws::EmptyStructure; end

# @note When making an API call, you may pass GetQueueAttributesRequest
#   data as a hash:
#
#   {
#   queue_url: "String", # required
#   attribute_names: ["All"], # accepts All, Policy, VisibilityTimeout, MaximumMessageSize, MessageRetentionPeriod, ApproximateNumberOfMessages, ApproximateNumberOfMessagesNotVisible, CreatedTimestamp, LastModifiedTimestamp, QueueArn, ApproximateNumberOfMessagesDelayed, DelaySeconds, ReceiveMessageWaitTimeSeconds, RedrivePolicy, FifoQueue, ContentBasedDeduplication, KmsMasterKeyId, KmsDataKeyReusePeriodSeconds, DeduplicationScope, FifoThroughputLimit, RedriveAllowPolicy, SqsManagedSseEnabled
#   }
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/GetQueueAttributesRequest AWS API Documentation
class Aws::SQS::Types::GetQueueAttributesRequest < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::GetQueueAttributesRequest::SENSITIVE = T.let(T.unsafe(nil), Array)

# A list of returned queue attributes.
#
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/GetQueueAttributesResult AWS API Documentation
class Aws::SQS::Types::GetQueueAttributesResult < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::GetQueueAttributesResult::SENSITIVE = T.let(T.unsafe(nil), Array)

# @note When making an API call, you may pass GetQueueUrlRequest
#   data as a hash:
#
#   {
#   queue_name: "String", # required
#   queue_owner_aws_account_id: "String",
#   }
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/GetQueueUrlRequest AWS API Documentation
class Aws::SQS::Types::GetQueueUrlRequest < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::GetQueueUrlRequest::SENSITIVE = T.let(T.unsafe(nil), Array)

# For more information, see [Interpreting Responses][1] in the *Amazon
# SQS Developer Guide*.
#
#
#
# [1]: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-api-responses.html
#
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/GetQueueUrlResult AWS API Documentation
class Aws::SQS::Types::GetQueueUrlResult < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::GetQueueUrlResult::SENSITIVE = T.let(T.unsafe(nil), Array)

# The specified attribute doesn't exist.
#
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/InvalidAttributeName AWS API Documentation
class Aws::SQS::Types::InvalidAttributeName < ::Aws::EmptyStructure; end

# The `Id` of a batch entry in a batch request doesn't abide by the
# specification.
#
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/InvalidBatchEntryId AWS API Documentation
class Aws::SQS::Types::InvalidBatchEntryId < ::Aws::EmptyStructure; end

# The specified receipt handle isn't valid for the current version.
#
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/InvalidIdFormat AWS API Documentation
class Aws::SQS::Types::InvalidIdFormat < ::Aws::EmptyStructure; end

# The message contains characters outside the allowed set.
#
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/InvalidMessageContents AWS API Documentation
class Aws::SQS::Types::InvalidMessageContents < ::Aws::EmptyStructure; end

# @note When making an API call, you may pass ListDeadLetterSourceQueuesRequest
#   data as a hash:
#
#   {
#   queue_url: "String", # required
#   next_token: "Token",
#   max_results: 1,
#   }
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/ListDeadLetterSourceQueuesRequest AWS API Documentation
class Aws::SQS::Types::ListDeadLetterSourceQueuesRequest < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::ListDeadLetterSourceQueuesRequest::SENSITIVE = T.let(T.unsafe(nil), Array)

# A list of your dead letter source queues.
#
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/ListDeadLetterSourceQueuesResult AWS API Documentation
class Aws::SQS::Types::ListDeadLetterSourceQueuesResult < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::ListDeadLetterSourceQueuesResult::SENSITIVE = T.let(T.unsafe(nil), Array)

# @note When making an API call, you may pass ListQueueTagsRequest
#   data as a hash:
#
#   {
#   queue_url: "String", # required
#   }
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/ListQueueTagsRequest AWS API Documentation
class Aws::SQS::Types::ListQueueTagsRequest < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::ListQueueTagsRequest::SENSITIVE = T.let(T.unsafe(nil), Array)

# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/ListQueueTagsResult AWS API Documentation
class Aws::SQS::Types::ListQueueTagsResult < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::ListQueueTagsResult::SENSITIVE = T.let(T.unsafe(nil), Array)

# @note When making an API call, you may pass ListQueuesRequest
#   data as a hash:
#
#   {
#   queue_name_prefix: "String",
#   next_token: "Token",
#   max_results: 1,
#   }
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/ListQueuesRequest AWS API Documentation
class Aws::SQS::Types::ListQueuesRequest < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::ListQueuesRequest::SENSITIVE = T.let(T.unsafe(nil), Array)

# A list of your queues.
#
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/ListQueuesResult AWS API Documentation
class Aws::SQS::Types::ListQueuesResult < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::ListQueuesResult::SENSITIVE = T.let(T.unsafe(nil), Array)

# An Amazon SQS message.
#
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/Message AWS API Documentation
class Aws::SQS::Types::Message < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::Message::SENSITIVE = T.let(T.unsafe(nil), Array)

# The user-specified message attribute value. For string data types, the
# `Value` attribute has the same restrictions on the content as the
# message body. For more information, see ` SendMessage.`
#
# `Name`, `type`, `value` and the message body must not be empty or
# null. All parts of the message attribute, including `Name`, `Type`,
# and `Value`, are part of the message size restriction (256 KB or
# 262,144 bytes).
#
# @note When making an API call, you may pass MessageAttributeValue
#   data as a hash:
#
#   {
#   string_value: "String",
#   binary_value: "data",
#   string_list_values: ["String"],
#   binary_list_values: ["data"],
#   data_type: "String", # required
#   }
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/MessageAttributeValue AWS API Documentation
class Aws::SQS::Types::MessageAttributeValue < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::MessageAttributeValue::SENSITIVE = T.let(T.unsafe(nil), Array)

# The specified message isn't in flight.
#
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/MessageNotInflight AWS API Documentation
class Aws::SQS::Types::MessageNotInflight < ::Aws::EmptyStructure; end

# The user-specified message system attribute value. For string data
# types, the `Value` attribute has the same restrictions on the content
# as the message body. For more information, see ` SendMessage.`
#
# `Name`, `type`, `value` and the message body must not be empty or
# null.
#
# @note When making an API call, you may pass MessageSystemAttributeValue
#   data as a hash:
#
#   {
#   string_value: "String",
#   binary_value: "data",
#   string_list_values: ["String"],
#   binary_list_values: ["data"],
#   data_type: "String", # required
#   }
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/MessageSystemAttributeValue AWS API Documentation
class Aws::SQS::Types::MessageSystemAttributeValue < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::MessageSystemAttributeValue::SENSITIVE = T.let(T.unsafe(nil), Array)

# The specified action violates a limit. For example, `ReceiveMessage`
# returns this error if the maximum number of inflight messages is
# reached and `AddPermission` returns this error if the maximum number
# of permissions for the queue is reached.
#
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/OverLimit AWS API Documentation
class Aws::SQS::Types::OverLimit < ::Aws::EmptyStructure; end

# Indicates that the specified queue previously received a `PurgeQueue`
# request within the last 60 seconds (the time it can take to delete the
# messages in the queue).
#
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/PurgeQueueInProgress AWS API Documentation
class Aws::SQS::Types::PurgeQueueInProgress < ::Aws::EmptyStructure; end

# @note When making an API call, you may pass PurgeQueueRequest
#   data as a hash:
#
#   {
#   queue_url: "String", # required
#   }
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/PurgeQueueRequest AWS API Documentation
class Aws::SQS::Types::PurgeQueueRequest < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::PurgeQueueRequest::SENSITIVE = T.let(T.unsafe(nil), Array)

# You must wait 60 seconds after deleting a queue before you can create
# another queue with the same name.
#
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/QueueDeletedRecently AWS API Documentation
class Aws::SQS::Types::QueueDeletedRecently < ::Aws::EmptyStructure; end

# The specified queue doesn't exist.
#
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/QueueDoesNotExist AWS API Documentation
class Aws::SQS::Types::QueueDoesNotExist < ::Aws::EmptyStructure; end

# A queue with this name already exists. Amazon SQS returns this error
# only if the request includes attributes whose values differ from those
# of the existing queue.
#
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/QueueNameExists AWS API Documentation
class Aws::SQS::Types::QueueNameExists < ::Aws::EmptyStructure; end

# The specified receipt handle isn't valid.
#
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/ReceiptHandleIsInvalid AWS API Documentation
class Aws::SQS::Types::ReceiptHandleIsInvalid < ::Aws::EmptyStructure; end

# @note When making an API call, you may pass ReceiveMessageRequest
#   data as a hash:
#
#   {
#   queue_url: "String", # required
#   attribute_names: ["All"], # accepts All, Policy, VisibilityTimeout, MaximumMessageSize, MessageRetentionPeriod, ApproximateNumberOfMessages, ApproximateNumberOfMessagesNotVisible, CreatedTimestamp, LastModifiedTimestamp, QueueArn, ApproximateNumberOfMessagesDelayed, DelaySeconds, ReceiveMessageWaitTimeSeconds, RedrivePolicy, FifoQueue, ContentBasedDeduplication, KmsMasterKeyId, KmsDataKeyReusePeriodSeconds, DeduplicationScope, FifoThroughputLimit, RedriveAllowPolicy, SqsManagedSseEnabled
#   message_attribute_names: ["MessageAttributeName"],
#   max_number_of_messages: 1,
#   visibility_timeout: 1,
#   wait_time_seconds: 1,
#   receive_request_attempt_id: "String",
#   }
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/ReceiveMessageRequest AWS API Documentation
class Aws::SQS::Types::ReceiveMessageRequest < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::ReceiveMessageRequest::SENSITIVE = T.let(T.unsafe(nil), Array)

# A list of received messages.
#
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/ReceiveMessageResult AWS API Documentation
class Aws::SQS::Types::ReceiveMessageResult < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::ReceiveMessageResult::SENSITIVE = T.let(T.unsafe(nil), Array)

# @note When making an API call, you may pass RemovePermissionRequest
#   data as a hash:
#
#   {
#   queue_url: "String", # required
#   label: "String", # required
#   }
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/RemovePermissionRequest AWS API Documentation
class Aws::SQS::Types::RemovePermissionRequest < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::RemovePermissionRequest::SENSITIVE = T.let(T.unsafe(nil), Array)

# @note When making an API call, you may pass SendMessageBatchRequest
#   data as a hash:
#
#   {
#   queue_url: "String", # required
#   entries: [ # required
#   {
#   id: "String", # required
#   message_body: "String", # required
#   delay_seconds: 1,
#   message_attributes: {
#   "String" => {
#   string_value: "String",
#   binary_value: "data",
#   string_list_values: ["String"],
#   binary_list_values: ["data"],
#   data_type: "String", # required
#   },
#   },
#   message_system_attributes: {
#   "AWSTraceHeader" => {
#   string_value: "String",
#   binary_value: "data",
#   string_list_values: ["String"],
#   binary_list_values: ["data"],
#   data_type: "String", # required
#   },
#   },
#   message_deduplication_id: "String",
#   message_group_id: "String",
#   },
#   ],
#   }
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/SendMessageBatchRequest AWS API Documentation
class Aws::SQS::Types::SendMessageBatchRequest < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::SendMessageBatchRequest::SENSITIVE = T.let(T.unsafe(nil), Array)

# Contains the details of a single Amazon SQS message along with an
# `Id`.
#
# @note When making an API call, you may pass SendMessageBatchRequestEntry
#   data as a hash:
#
#   {
#   id: "String", # required
#   message_body: "String", # required
#   delay_seconds: 1,
#   message_attributes: {
#   "String" => {
#   string_value: "String",
#   binary_value: "data",
#   string_list_values: ["String"],
#   binary_list_values: ["data"],
#   data_type: "String", # required
#   },
#   },
#   message_system_attributes: {
#   "AWSTraceHeader" => {
#   string_value: "String",
#   binary_value: "data",
#   string_list_values: ["String"],
#   binary_list_values: ["data"],
#   data_type: "String", # required
#   },
#   },
#   message_deduplication_id: "String",
#   message_group_id: "String",
#   }
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/SendMessageBatchRequestEntry AWS API Documentation
class Aws::SQS::Types::SendMessageBatchRequestEntry < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::SendMessageBatchRequestEntry::SENSITIVE = T.let(T.unsafe(nil), Array)

# For each message in the batch, the response contains a `
# SendMessageBatchResultEntry ` tag if the message succeeds or a `
# BatchResultErrorEntry ` tag if the message fails.
#
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/SendMessageBatchResult AWS API Documentation
class Aws::SQS::Types::SendMessageBatchResult < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::SendMessageBatchResult::SENSITIVE = T.let(T.unsafe(nil), Array)

# Encloses a `MessageId` for a successfully-enqueued message in a `
# SendMessageBatch.`
#
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/SendMessageBatchResultEntry AWS API Documentation
class Aws::SQS::Types::SendMessageBatchResultEntry < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::SendMessageBatchResultEntry::SENSITIVE = T.let(T.unsafe(nil), Array)

# @note When making an API call, you may pass SendMessageRequest
#   data as a hash:
#
#   {
#   queue_url: "String", # required
#   message_body: "String", # required
#   delay_seconds: 1,
#   message_attributes: {
#   "String" => {
#   string_value: "String",
#   binary_value: "data",
#   string_list_values: ["String"],
#   binary_list_values: ["data"],
#   data_type: "String", # required
#   },
#   },
#   message_system_attributes: {
#   "AWSTraceHeader" => {
#   string_value: "String",
#   binary_value: "data",
#   string_list_values: ["String"],
#   binary_list_values: ["data"],
#   data_type: "String", # required
#   },
#   },
#   message_deduplication_id: "String",
#   message_group_id: "String",
#   }
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/SendMessageRequest AWS API Documentation
class Aws::SQS::Types::SendMessageRequest < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::SendMessageRequest::SENSITIVE = T.let(T.unsafe(nil), Array)

# The `MD5OfMessageBody` and `MessageId` elements.
#
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/SendMessageResult AWS API Documentation
class Aws::SQS::Types::SendMessageResult < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::SendMessageResult::SENSITIVE = T.let(T.unsafe(nil), Array)

# @note When making an API call, you may pass SetQueueAttributesRequest
#   data as a hash:
#
#   {
#   queue_url: "String", # required
#   attributes: { # required
#   "All" => "String",
#   },
#   }
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/SetQueueAttributesRequest AWS API Documentation
class Aws::SQS::Types::SetQueueAttributesRequest < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::SetQueueAttributesRequest::SENSITIVE = T.let(T.unsafe(nil), Array)

# @note When making an API call, you may pass TagQueueRequest
#   data as a hash:
#
#   {
#   queue_url: "String", # required
#   tags: { # required
#   "TagKey" => "TagValue",
#   },
#   }
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/TagQueueRequest AWS API Documentation
class Aws::SQS::Types::TagQueueRequest < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::TagQueueRequest::SENSITIVE = T.let(T.unsafe(nil), Array)

# The batch request contains more entries than permissible.
#
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/TooManyEntriesInBatchRequest AWS API Documentation
class Aws::SQS::Types::TooManyEntriesInBatchRequest < ::Aws::EmptyStructure; end

# Error code 400. Unsupported operation.
#
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/UnsupportedOperation AWS API Documentation
class Aws::SQS::Types::UnsupportedOperation < ::Aws::EmptyStructure; end

# @note When making an API call, you may pass UntagQueueRequest
#   data as a hash:
#
#   {
#   queue_url: "String", # required
#   tag_keys: ["TagKey"], # required
#   }
# @see http://docs.aws.amazon.com/goto/WebAPI/sqs-2012-11-05/UntagQueueRequest AWS API Documentation
class Aws::SQS::Types::UntagQueueRequest < ::Struct
  include ::Aws::Structure
end

Aws::SQS::Types::UntagQueueRequest::SENSITIVE = T.let(T.unsafe(nil), Array)
