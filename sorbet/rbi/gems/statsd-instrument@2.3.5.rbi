# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `statsd-instrument` gem.
# Please instead update this file by running `bin/tapioca gem statsd-instrument`.

# The StatsD module contains low-level metrics for collecting metrics and sending them to the backend.
#
# @see StatsD::Instrument <tt>StatsD::Instrument</tt> contains module to instrument
#   existing methods with StatsD metrics.
module StatsD
  extend ::StatsD

  # The backend that is being used to emit the metrics.
  #
  # @return [StatsD::Instrument::Backend] the currently active backend. If there is no active backend
  #   yet, it will call {StatsD::Instrument::Environment#default_backend} to obtain a
  #   default backend for the environment.
  # @see StatsD::Instrument::Environment#default_backend
  def backend; end

  # The backend that is being used to emit the metrics.
  #
  # @return [StatsD::Instrument::Backend] the currently active backend. If there is no active backend
  #   yet, it will call {StatsD::Instrument::Environment#default_backend} to obtain a
  #   default backend for the environment.
  # @see StatsD::Instrument::Environment#default_backend
  def backend=(_arg0); end

  # The sample rate to use if the sample rate is unspecified for a metric call.
  #
  # @return [Float] Default is 1.0.
  def default_sample_rate; end

  # The sample rate to use if the sample rate is unspecified for a metric call.
  #
  # @return [Float] Default is 1.0.
  def default_sample_rate=(_arg0); end

  # Emits a distribution metric.
  #
  # @note Supported by the datadog implementation only (in beta)
  # @overload distribution
  # @param key [String] The name of the metric.
  # @param value [Numeric] The value to record.
  # @param metric_options [Hash] (default: {}) Metric options
  # @return [StatsD::Instrument::Metric] The metric that was sent to the backend.
  def distribution(key, value = T.unsafe(nil), *metric_options, &block); end

  # Emits an event metric.
  #
  # @note Supported by the datadog implementation only.
  # @param title [String] Title of the event.
  # @param text [String] Body of the event.
  # @param metric_options [Hash] (default: {}) Metric options
  # @return [StatsD::Instrument::Metric] The metric that was sent to the backend.
  def event(title, text, *metric_options); end

  # Emits a gauge metric.
  #
  # @param key [String] The name of the metric.
  # @param value [Numeric] The current value to record.
  # @param metric_options [Hash] (default: {}) Metric options
  # @return [StatsD::Instrument::Metric] The metric that was sent to the backend.
  def gauge(key, value, *metric_options); end

  # Emits a histogram metric.
  #
  # @note Supported by the datadog implementation only.
  # @param key [String] The name of the metric.
  # @param value [Numeric] The value to record.
  # @param metric_options [Hash] (default: {}) Metric options
  # @return [StatsD::Instrument::Metric] The metric that was sent to the backend.
  def histogram(key, value, *metric_options); end

  # Emits a counter metric.
  #
  # @param key [String] The name of the metric.
  # @param value [Integer] The value to increment the counter by.
  #
  #   You should not compensate for the sample rate using the counter increment. E.g., if
  #   your sample rate is 0.01, you should <b>not</b> use 100 as increment to compensate for it.
  #   The sample rate is part of the packet that is being sent to the server, and the server
  #   should know how to handle it.
  # @param metric_options [Hash] (default: {}) Metric options
  # @return [StatsD::Instrument::Metric] The metric that was sent to the backend.
  def increment(key, value = T.unsafe(nil), *metric_options); end

  # Emits a key/value metric.
  #
  # @note Supported by the statsite implementation only.
  # @param key [String] The name of the metric.
  # @param value [Numeric] The value to record.
  # @param metric_options [Hash] (default: {}) Metric options
  # @return [StatsD::Instrument::Metric] The metric that was sent to the backend.
  def key_value(key, value, *metric_options); end

  # The logger to use in case of any errors. The logger is also used as default logger
  # for the LoggerBackend (although this can be overwritten).
  #
  # @return [Logger]
  # @see StatsD::Instrument::Backends::LoggerBackend
  def logger; end

  # The logger to use in case of any errors. The logger is also used as default logger
  # for the LoggerBackend (although this can be overwritten).
  #
  # @return [Logger]
  # @see StatsD::Instrument::Backends::LoggerBackend
  def logger=(_arg0); end

  # Emits a duration metric.
  #
  # @overload measure
  # @overload measure
  def measure(key, value = T.unsafe(nil), *metric_options, &block); end

  # The prefix to apply to metric names. This can be useful to group all the metrics
  # for an application in a shared StatsD server.
  #
  # When using a prefix a dot will be included automatically to separate the prefix
  # from the metric name.
  #
  # @return [String, nil] The prefix, or <tt>nil</tt> when no prefix is used
  # @see StatsD::Instrument::Metric#name
  def prefix; end

  # The prefix to apply to metric names. This can be useful to group all the metrics
  # for an application in a shared StatsD server.
  #
  # When using a prefix a dot will be included automatically to separate the prefix
  # from the metric name.
  #
  # @return [String, nil] The prefix, or <tt>nil</tt> when no prefix is used
  # @see StatsD::Instrument::Metric#name
  def prefix=(_arg0); end

  # Emits a service check metric.
  #
  # @note Supported by the datadog implementation only.
  # @param title [String] Title of the event.
  # @param text [String] Body of the event.
  # @param metric_options [Hash] (default: {}) Metric options
  # @return [StatsD::Instrument::Metric] The metric that was sent to the backend.
  def service_check(name, status, *metric_options); end

  # Emits a set metric.
  #
  # @note Supported by the datadog implementation only.
  # @param key [String] The name of the metric.
  # @param value [Numeric] The value to record.
  # @param metric_options [Hash] (default: {}) Metric options
  # @return [StatsD::Instrument::Metric] The metric that was sent to the backend.
  def set(key, value, *metric_options); end

  private

  # Instantiates a metric, and sends it to the backend for further processing.
  #
  # @param options [Hash] a customizable set of options
  # @return [StatsD::Instrument::Metric] The metric that was sent to the backend.
  def collect_metric(type, name, value, metric_options); end

  # Converts old-style ordered arguments in an argument hash for backwards compatibility.
  #
  # @param args [Array] The list of non-required arguments.
  # @return [Hash] The hash of optional arguments.
  def hash_argument(args); end

  def parse_options(value, metric_options); end
end

# The StatsD::Instrument module provides metaprogramming methods to instrument your methods with
# StatsD metrics. E.g., yopu can create counters on how often a method is called, how often it is
# successful, the duration of the methods call, etc.
module StatsD::Instrument
  # Adds counter instrumentation to a method.
  #
  # The metric will be incremented for every call of the instrumented method, no matter
  # whether what the method returns, or whether it raises an exception.
  #
  # @param method [Symbol] The name of the method to instrument.
  # @param name [String, #call] The name of the metric to use. You can also pass in a
  #   callable to dynamically generate a metric name
  # @return [void]
  def statsd_count(method, name, *metric_options); end

  # Adds success and failure counter instrumentation to a method.
  #
  # A method call will be considered successful if it does not raise an exception, and the result is true-y.
  # Only for successful calls, the metric will be icnremented
  #
  # @param method [Symbol] The name of the method to instrument.
  # @param name [String, #call] The name of the metric to use. You can also pass in a
  #   callable to dynamically generate a metric name
  # @return [void]
  # @see #statsd_count_success
  # @yield You can pass a block to this method if you want to define yourself what is a successful call
  #   based on the return value of the method.
  # @yieldparam result The return value of the instrumented method.
  # @yieldreturn [Boolean] Return true iff the return value is consisered a success, false otherwise.
  def statsd_count_if(method, name, *metric_options); end

  # Adds success and failure counter instrumentation to a method.
  #
  # A method call will be considered successful if it does not raise an exception, and the result is true-y.
  # For successful calls, the metric <tt>[name].success</tt> will be incremented; for failed calls, the metric
  # name is <tt>[name].failure</tt>.
  #
  # @param method [Symbol] The name of the method to instrument.
  # @param name [String, #call] The name of the metric to use. You can also pass in a
  #   callable to dynamically generate a metric name
  # @return [void]
  # @see #statsd_count_if
  # @yield You can pass a block to this method if you want to define yourself what is a successful call
  #   based on the return value of the method.
  # @yieldparam result The return value of the instrumented method.
  # @yieldreturn [Boolean] Return true iff the return value is consisered a success, false otherwise.
  def statsd_count_success(method, name, *metric_options); end

  # Adds execution duration instrumentation to a method as a distribution.
  #
  # @note Supported by the datadog implementation only (in beta)
  # @param method [Symbol] The name of the method to instrument.
  # @param name [String, #call] The name of the metric to use. You can also pass in a
  #   callable to dynamically generate a metric name
  # @return [void]
  def statsd_distribution(method, name, *metric_options); end

  # @private
  def statsd_instrumentations; end

  # Adds execution duration instrumentation to a method as a timing.
  #
  # @param method [Symbol] The name of the method to instrument.
  # @param name [String, #call] The name of the metric to use. You can also pass in a
  #   callable to dynamically generate a metric name
  # @return [void]
  def statsd_measure(method, name, *metric_options); end

  # Removes StatsD counter instrumentation from a method
  #
  # @param method [Symbol] The method to remove instrumentation from.
  # @param name [String] The name of the metric that was used.
  # @return [void]
  # @see #statsd_count
  def statsd_remove_count(method, name); end

  # Removes StatsD conditional counter instrumentation from a method
  #
  # @param method [Symbol] The method to remove instrumentation from.
  # @param name [String] The name of the metric that was used.
  # @return [void]
  # @see #statsd_count_if
  def statsd_remove_count_if(method, name); end

  # Removes StatsD success counter instrumentation from a method
  #
  # @param method [Symbol] The method to remove instrumentation from.
  # @param name [String] The name of the metric that was used.
  # @return [void]
  # @see #statsd_count_success
  def statsd_remove_count_success(method, name); end

  # Removes StatsD distribution instrumentation from a method
  #
  # @param method [Symbol] The method to remove instrumentation from.
  # @param name [String] The name of the metric that was used.
  # @return [void]
  # @see #statsd_measure
  def statsd_remove_distribution(method, name); end

  # Removes StatsD measure instrumentation from a method
  #
  # @param method [Symbol] The method to remove instrumentation from.
  # @param name [String] The name of the metric that was used.
  # @return [void]
  # @see #statsd_measure
  def statsd_remove_measure(method, name); end

  private

  # @raise [ArgumentError]
  def add_to_method(method, name, action, &block); end

  def method_visibility(method); end
  def remove_from_method(method, name, action); end
  def statsd_instrumentation_for(method, name, action); end

  class << self
    # @private
    def current_timestamp; end

    # Even though this method is considered private, and is no longer used internally,
    # applications in the wild rely on it. As a result, we cannot remove this method
    # until the next major version.
    #
    # @private
    def duration; end

    # @private
    def generate_metric_name(metric_name, callee, *args); end
  end
end

module StatsD::Instrument::Assertions
  include ::StatsD::Instrument::Helpers

  def assert_no_statsd_calls(metric_name = T.unsafe(nil), &block); end

  # @private
  def assert_statsd_calls(expected_metrics, &block); end

  def assert_statsd_distribution(metric_name, options = T.unsafe(nil), &block); end
  def assert_statsd_gauge(metric_name, options = T.unsafe(nil), &block); end
  def assert_statsd_histogram(metric_name, options = T.unsafe(nil), &block); end
  def assert_statsd_increment(metric_name, options = T.unsafe(nil), &block); end
  def assert_statsd_key_value(metric_name, options = T.unsafe(nil), &block); end
  def assert_statsd_measure(metric_name, options = T.unsafe(nil), &block); end
  def assert_statsd_set(metric_name, options = T.unsafe(nil), &block); end

  private

  def assert_statsd_call(metric_type, metric_name, options = T.unsafe(nil), &block); end

  # @return [Boolean]
  def within_numeric_range?(object); end
end

# This abstract class specifies the interface a backend implementation should conform to.
#
# @abstract
class StatsD::Instrument::Backend
  # Collects a metric.
  #
  # @param metric [StatsD::Instrument::Metric] The metric to collect
  # @raise [NotImplementedError]
  # @return [void]
  def collect_metric(metric); end
end

module StatsD::Instrument::Backends; end

# The capture backend is used to capture the metrics that are collected, so you can
# run assertions on them.
#
# @see StatsD::Instrument::Assertions
class StatsD::Instrument::Backends::CaptureBackend < ::StatsD::Instrument::Backend
  # @return [CaptureBackend] a new instance of CaptureBackend
  def initialize; end

  # Adds a metric to the ist of collected metrics.
  #
  # @param metric [StatsD::Instrument::Metric] The metric to collect.
  # @return [void]
  def collect_metric(metric); end

  # @return [Array<StatsD::Instrument::Metric>] The list of metrics that were collected.
  def collected_metrics; end

  # Resets the list of collected metrics to an empty list.
  #
  # @return [void]
  def reset; end
end

# The logger backend simply logs every metric to a logger
class StatsD::Instrument::Backends::LoggerBackend < ::StatsD::Instrument::Backend
  # @return [LoggerBackend] a new instance of LoggerBackend
  def initialize(logger); end

  # @param metric [StatsD::Instrument::Metric]
  # @return [void]
  def collect_metric(metric); end

  # @return [Logger]
  def logger; end

  # @return [Logger]
  def logger=(_arg0); end
end

# The null backend does nothing when receiving a metric, effectively disabling the gem completely.
class StatsD::Instrument::Backends::NullBackend < ::StatsD::Instrument::Backend
  def collect_metric(metric); end
end

class StatsD::Instrument::Backends::UDPBackend < ::StatsD::Instrument::Backend
  include ::MonitorMixin

  # @return [UDPBackend] a new instance of UDPBackend
  def initialize(server = T.unsafe(nil), implementation = T.unsafe(nil)); end

  def collect_metric(metric); end

  # Returns the value of attribute host.
  def host; end

  def host=(host); end

  # Returns the value of attribute implementation.
  def implementation; end

  def implementation=(value); end
  def invalidate_socket; end

  # Returns the value of attribute port.
  def port; end

  def port=(port); end
  def server=(connection_string); end
  def socket; end
  def write_packet(command); end
end

StatsD::Instrument::Backends::UDPBackend::BASE_SUPPORTED_METRIC_TYPES = T.let(T.unsafe(nil), Hash)
StatsD::Instrument::Backends::UDPBackend::DEFAULT_IMPLEMENTATION = T.let(T.unsafe(nil), Symbol)

class StatsD::Instrument::Backends::UDPBackend::DogStatsDProtocol
  def generate_packet(metric); end

  private

  def generate_metadata(metric, options); end
end

StatsD::Instrument::Backends::UDPBackend::DogStatsDProtocol::EVENT_OPTIONS = T.let(T.unsafe(nil), Hash)
StatsD::Instrument::Backends::UDPBackend::DogStatsDProtocol::SERVICE_CHECK_OPTIONS = T.let(T.unsafe(nil), Hash)
StatsD::Instrument::Backends::UDPBackend::DogStatsDProtocol::SUPPORTED_METRIC_TYPES = T.let(T.unsafe(nil), Hash)

class StatsD::Instrument::Backends::UDPBackend::StatsDProtocol
  def generate_packet(metric); end
end

StatsD::Instrument::Backends::UDPBackend::StatsDProtocol::SUPPORTED_METRIC_TYPES = T.let(T.unsafe(nil), Hash)

class StatsD::Instrument::Backends::UDPBackend::StatsiteStatsDProtocol
  def generate_packet(metric); end
end

StatsD::Instrument::Backends::UDPBackend::StatsiteStatsDProtocol::SUPPORTED_METRIC_TYPES = T.let(T.unsafe(nil), Hash)

# The environment module is used to detect, and initialize the environment in
# which this library is active. It will use different default values based on the environment.
module StatsD::Instrument::Environment
  extend ::StatsD::Instrument::Environment

  # Instantiates a default backend for the current environment.
  #
  # @return [StatsD::Instrument::Backend]
  # @see #environment
  def default_backend; end

  # Detects the current environment, either by asking Rails, or by inspecting environment variables.
  #
  # - Within a Rails application, <tt>Rails.env</tt> is used.
  # - It will check the following environment variables in order: <tt>RAILS_ENV</tt>, <tt>RACK_ENV</tt>, <tt>ENV</tt>.
  # - If none of these are set, it will return <tt>development</tt>
  #
  # @return [String] The detected environment.
  def environment; end

  # Sets default values for sample rate and logger.
  #
  # - Default sample rate is set to the value in the STATSD_SAMPLE_RATE environment variable,
  #   or 1.0 otherwise. See {StatsD#default_sample_rate}
  # - {StatsD#logger} is set to a logger that send output to stderr.
  #
  # If you are including this library inside a Rails environment, additional initialization will
  # be done as part of the {StatsD::Instrument::Railtie}.
  #
  # @return [void]
  def setup; end
end

module StatsD::Instrument::Helpers
  def capture_statsd_calls(&block); end
end

# The Metric class represents a metric sample to be send by a backend.
#
# @see StatsD The StatsD module contains methods that generate metric instances.
# @see StatsD::Instrument::Backend A StatsD::Instrument::Backend is used to collect metrics.
class StatsD::Instrument::Metric
  # Initializes a new metric instance.
  # Normally, you don't want to call this method directly, but use one of the metric collection
  # methods on the {StatsD} module.
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash] a customizable set of options
  # @return [Metric] a new instance of Metric
  def initialize(options = T.unsafe(nil)); end

  # The default value for this metric, which will be used if it is not set.
  #
  # A default value is only defined for counter metrics (<tt>1</tt>). For all other
  # metric types, this emthod will raise an <tt>ArgumentError</tt>.
  #
  # @raise ArgumentError if the metric type doesn't have a default value
  # @return [Numeric, String] The default value for this metric.
  def default_value; end

  # @private
  # @return [String]
  def inspect; end

  # Returns the value of attribute metadata.
  def metadata; end

  # Sets the attribute metadata
  #
  # @param value the value to set the attribute metadata to.
  def metadata=(_arg0); end

  # @return [String] The name of the metric. {StatsD#prefix} will automatically be applied
  #   to the metric in the constructor, unless the <tt>:no_prefix</tt> option is set or is
  #   overridden by the <tt>:prefix</tt> option. Note that <tt>:no_prefix</tt> has greater
  #   precedence than <tt>:prefix</tt>.
  def name; end

  # @return [String] The name of the metric. {StatsD#prefix} will automatically be applied
  #   to the metric in the constructor, unless the <tt>:no_prefix</tt> option is set or is
  #   overridden by the <tt>:prefix</tt> option. Note that <tt>:no_prefix</tt> has greater
  #   precedence than <tt>:prefix</tt>.
  def name=(_arg0); end

  # Strip metric names of special characters used by StatsD line protocol, replace with underscore
  #
  # @param name [String]
  # @return [String]
  def normalize_name(name); end

  # The sample rate to use for the metric. How the sample rate is handled differs per backend.
  # The UDP backend will actually sample metric submissions based on the sample rate, while
  # the logger backend will just include the sample rate in its output for debugging purposes.
  #
  # @return [Float] The sample rate to use for this metric. This should be a value between
  #   0 and 1. If not set, it will use the default sample rate set to {StatsD#default_sample_rate}.
  # @see StatsD#default_sample_rate
  def sample_rate; end

  # The sample rate to use for the metric. How the sample rate is handled differs per backend.
  # The UDP backend will actually sample metric submissions based on the sample rate, while
  # the logger backend will just include the sample rate in its output for debugging purposes.
  #
  # @return [Float] The sample rate to use for this metric. This should be a value between
  #   0 and 1. If not set, it will use the default sample rate set to {StatsD#default_sample_rate}.
  # @see StatsD#default_sample_rate
  def sample_rate=(_arg0); end

  # The tags to associate with the metric.
  #
  # @note Only the Datadog implementation supports tags.
  # @return [Array<String>, Hash<String, String>, nil] the tags to associate with the metric.
  #   You can either specify the tags as an array of strings, or a Hash of key/value pairs.
  # @see .normalize_tags
  def tags; end

  # The tags to associate with the metric.
  #
  # @note Only the Datadog implementation supports tags.
  # @return [Array<String>, Hash<String, String>, nil] the tags to associate with the metric.
  #   You can either specify the tags as an array of strings, or a Hash of key/value pairs.
  # @see .normalize_tags
  def tags=(_arg0); end

  # @private
  # @return [String]
  def to_s; end

  # @return [Symbol] The metric type. Must be one of {StatsD::Instrument::Metric::TYPES}
  def type; end

  # @return [Symbol] The metric type. Must be one of {StatsD::Instrument::Metric::TYPES}
  def type=(_arg0); end

  # @return [Numeric, String] The value to collect for the metric. Depending on the metric
  #   type, <tt>value</tt> can be a string, integer, or float.
  # @see #default_value
  def value; end

  # @return [Numeric, String] The value to collect for the metric. Depending on the metric
  #   type, <tt>value</tt> can be a string, integer, or float.
  # @see #default_value
  def value=(_arg0); end

  class << self
    # Utility function to convert tags to the canonical form.
    #
    # - Tags specified as key value pairs will be converted into an array
    # - Tags are normalized to only use word characters and underscores.
    #
    # @param tags [Array<String>, Hash<String, String>, nil] Tags specified in any form.
    # @return [Array<String>, nil] the list of tags in canonical form.
    def normalize_tags(tags); end
  end
end

# The metric types that are supported by this library. Note that every StatsD server
# implementation only supports a subset of them.
StatsD::Instrument::Metric::TYPES = T.let(T.unsafe(nil), Hash)

# @private
class StatsD::Instrument::MetricExpectation
  # @return [MetricExpectation] a new instance of MetricExpectation
  def initialize(options = T.unsafe(nil)); end

  def default_value; end

  # Returns the value of attribute ignore_tags.
  def ignore_tags; end

  def inspect; end
  def matches(actual_metric); end

  # Returns the value of attribute name.
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  def name=(_arg0); end

  # Returns the value of attribute sample_rate.
  def sample_rate; end

  # Sets the attribute sample_rate
  #
  # @param value the value to set the attribute sample_rate to.
  def sample_rate=(_arg0); end

  # Returns the value of attribute tags.
  def tags; end

  # Sets the attribute tags
  #
  # @param value the value to set the attribute tags to.
  def tags=(_arg0); end

  # Returns the value of attribute times.
  def times; end

  # Sets the attribute times
  #
  # @param value the value to set the attribute times to.
  def times=(_arg0); end

  def to_s; end

  # Returns the value of attribute type.
  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  def type=(_arg0); end

  # Returns the value of attribute value.
  def value; end

  # Sets the attribute value
  #
  # @param value the value to set the attribute value to.
  def value=(_arg0); end
end

StatsD::Instrument::MetricExpectation::TYPES = T.let(T.unsafe(nil), Hash)

# This Railtie runs some initializers that will set the logger to <tt>Rails#logger</tt>,
# and will initialize the {StatsD#backend} based on the Rails environment.
#
# @see StatsD::Instrument::Environment
class StatsD::Instrument::Railtie < ::Rails::Railtie; end

StatsD::Instrument::VERSION = T.let(T.unsafe(nil), String)
