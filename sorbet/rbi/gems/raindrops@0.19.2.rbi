# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `raindrops` gem.
# Please instead update this file by running `bin/tapioca gem raindrops`.

# Each Raindrops object is a container that holds several counters.
# It is internally a page-aligned, shared memory area that allows
# atomic increments, decrements, assignments and reads without any
# locking.
#
#   rd = Raindrops.new 4
#   rd.incr(0, 1)   -> 1
#   rd.to_ary       -> [ 1, 0, 0, 0 ]
#
# Unlike many classes in this package, the core Raindrops class is
# intended to be portable to all reasonably modern *nix systems
# supporting mmap().  Please let us know if you have portability
# issues, patches or pull requests at mailto:raindrops-public@yhbt.net
class Raindrops
  def initialize(_arg0); end

  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def capa; end
  def decr(*_arg0); end
  def evaporate!; end
  def incr(*_arg0); end
  def size; end
  def size=(_arg0); end
  def to_ary; end

  private

  def initialize_copy(_arg0); end
end

# raindrops may use the {aggregate}[https://github.com/josephruscio/aggregate]
# RubyGem to aggregate statistics from TCP_Info lookups.
module Raindrops::Aggregate; end

# - Kgio::TCPServer#kgio_tryaccept
module Raindrops::Aggregate::LastDataRecv
  def accept; end
  def accept_nonblock; end

  # The +last_data_recv+ member of Raindrops::TCP_Info can be used to
  # infer the time a client spent in the listen queue before it was
  # accepted.
  #
  # We require TCP_DEFER_ACCEPT on the listen socket for
  # +last_data_recv+ to be accurate
  def count!(io); end

  def kgio_accept(*args); end

  # :stopdoc:
  def kgio_tryaccept(*args); end

  # The integer value of +last_data_recv+ is sent to this object.
  # This is usually a duck type compatible with the \Aggregate class,
  # but can be *anything* that accepts the *<<* method.
  def raindrops_aggregate; end

  # The integer value of +last_data_recv+ is sent to this object.
  # This is usually a duck type compatible with the \Aggregate class,
  # but can be *anything* that accepts the *<<* method.
  def raindrops_aggregate=(_arg0); end

  class << self
    # automatically extends any TCPServer objects used by Unicorn
    def cornify!; end

    # By default, this is a Raindrops::Aggregate::PMQ object
    # It may be anything that responds to *<<*
    def default_aggregate; end

    # Assign any object that responds to *<<*
    def default_aggregate=(agg); end

    # each extended object needs to have TCP_DEFER_ACCEPT enabled
    # for accuracy.
    def extended(obj); end
  end
end

# For reporting TCP ListenStats, users of older \Linux kernels need to ensure
# that the the "inet_diag" and "tcp_diag" kernel modules are loaded as they do
# not autoload correctly.  The inet_diag facilities of \Raindrops is useful
# for periodic snapshot reporting of listen queue sizes.
#
# Instead of snapshotting, Raindrops::Aggregate::LastDataRecv may be used
# to aggregate statistics from +all+ accepted sockets as they arrive
# based on the +last_data_recv+ field in Raindrops::TCP_Info
module Raindrops::Linux
  private

  # Get ListenStats from an array of +paths+
  #
  # Socket state mapping from integer => symbol, based on socket_state
  # enum from include/linux/net.h in the \Linux kernel:
  #     typedef enum {
  #             SS_FREE = 0,              /* not allocated                */
  #             SS_UNCONNECTED,           /* unconnected to any socket    */
  #             SS_CONNECTING,            /* in process of connecting     */
  #             SS_CONNECTED,             /* connected to socket          */
  #             SS_DISCONNECTING          /* in process of disconnecting  */
  #     } socket_state;
  # * SS_CONNECTING maps to ListenStats#queued
  # * SS_CONNECTED maps to ListenStats#active
  #
  # This method may be significantly slower than its tcp_listener_stats
  # counterpart due to the latter being able to use inet_diag via netlink.
  # This parses /proc/net/unix as there is no other (known) way
  # to expose Unix domain socket statistics over netlink.
  def unix_listener_stats(paths = T.unsafe(nil)); end

  class << self
    # Get ListenStats from an array of +paths+
    #
    # Socket state mapping from integer => symbol, based on socket_state
    # enum from include/linux/net.h in the \Linux kernel:
    #     typedef enum {
    #             SS_FREE = 0,              /* not allocated                */
    #             SS_UNCONNECTED,           /* unconnected to any socket    */
    #             SS_CONNECTING,            /* in process of connecting     */
    #             SS_CONNECTED,             /* connected to socket          */
    #             SS_DISCONNECTING          /* in process of disconnecting  */
    #     } socket_state;
    # * SS_CONNECTING maps to ListenStats#queued
    # * SS_CONNECTED maps to ListenStats#active
    #
    # This method may be significantly slower than its tcp_listener_stats
    # counterpart due to the latter being able to use inet_diag via netlink.
    # This parses /proc/net/unix as there is no other (known) way
    # to expose Unix domain socket statistics over netlink.
    def unix_listener_stats(paths = T.unsafe(nil)); end
  end
end

# The standard proc path for active UNIX domain sockets, feel free to call
# String#replace on this if your /proc is mounted in a non-standard location
# for whatever reason
Raindrops::Linux::PROC_NET_UNIX_ARGS = T.let(T.unsafe(nil), Array)

# Used to represent the number of +active+ and +queued+ sockets for
# a single listen socket across all threads and processes on a
# machine.
#
# For TCP listeners, only sockets in the TCP_ESTABLISHED state are
# accounted for.  For Unix domain listeners, only CONNECTING and
# CONNECTED Unix domain sockets are accounted for.
#
# +active+ connections is the number of accept()-ed but not-yet-closed
# sockets in all threads/processes sharing the given listener.
#
# +queued+ connections is the number of un-accept()-ed sockets in the
# queue of a given listen socket.
#
# These stats are currently only available under \Linux
class Raindrops::ListenStats < ::Struct
  # the sum of +active+ and +queued+ sockets
  def total; end
end

Raindrops::MAX = T.let(T.unsafe(nil), Integer)

# Raindrops::Middleware is Rack middleware that allows snapshotting
# current activity from an HTTP request.  For all operating systems,
# it returns at least the following fields:
#
# * calling - the number of application dispatchers on your machine
# * writing - the number of clients being written to on your machine
#
# Additional fields are available for \Linux users.
#
# It should be loaded at the top of Rack middleware stack before other
# middlewares for maximum accuracy.
#
# === Usage (Rainbows!/Unicorn preload_app=false)
#
# If you're using preload_app=false (the default) in your Rainbows!/Unicorn
# config file, you'll need to create the global Stats object before
# forking.
#
#    require 'raindrops'
#    $stats ||= Raindrops::Middleware::Stats.new
#
# In your Rack config.ru:
#
#    use Raindrops::Middleware, :stats => $stats
#
# === Usage (Rainbows!/Unicorn preload_app=true)
#
# If you're using preload_app=true in your Rainbows!/Unicorn
# config file, just add the middleware to your stack:
#
# In your Rack config.ru:
#
#    use Raindrops::Middleware
#
# === Linux-only extras!
#
# To get bound listener statistics under \Linux, you need to specify the
# listener names for your server.  You can even include listen sockets for
# *other* servers on the same machine.  This can be handy for monitoring
# your nginx proxy as well.
#
# In your Rack config.ru, just pass the :listeners argument as an array of
# strings (along with any other arguments).  You can specify any
# combination of TCP or Unix domain socket names:
#
#    use Raindrops::Middleware, :listeners => %w(0.0.0.0:80 /tmp/.sock)
#
# If you're running Unicorn 0.98.0 or later, you don't have to pass in
# the :listeners array, Raindrops will automatically detect the listeners
# used by Unicorn master process.  This does not detect listeners in
# different processes, of course.
#
# The response body includes the following stats for each listener
# (see also Raindrops::ListenStats):
#
# * active - total number of active clients on that listener
# * queued - total number of queued (pre-accept()) clients on that listener
#
# = Demo Server
#
# There is a server running this middleware (and Watcher) at
#  https://yhbt.net/raindrops-demo/_raindrops
#
# Also check out the Watcher demo at https://yhbt.net/raindrops-demo/
#
# The demo server is only limited to 30 users, so be sure not to abuse it
# by using the /tail/ endpoint too much.
class Raindrops::Middleware
  # +app+ may be any Rack application, this middleware wraps it.
  # +opts+ is a hash that understands the following members:
  #
  # * :stats - Raindrops::Middleware::Stats struct (default: Stats.new)
  # * :path - HTTP endpoint used for reading the stats (default: "/_raindrops")
  # * :listeners - array of host:port or socket paths (default: from Unicorn)
  #
  # @return [Middleware] a new instance of Middleware
  def initialize(app, opts = T.unsafe(nil)); end

  def app; end
  def app=(_arg0); end

  # standard Rack endpoint
  def call(env); end

  def path; end
  def path=(_arg0); end
  def stats; end
  def stats=(_arg0); end
  def stats_response; end
  def tcp; end
  def tcp=(_arg0); end
  def unix; end
  def unix=(_arg0); end
end

# :stopdoc:
# This class is used by Raindrops::Middleware to proxy application
# response bodies.  There should be no need to use it directly.
class Raindrops::Middleware::Proxy
  # @return [Proxy] a new instance of Proxy
  def initialize(body, stats); end

  # the Rack server should call this after #each (usually ensure-d)
  def close; end

  # yield to the Rack server here for writing
  def each; end

  # Avoid breaking users of non-standard extensions (e.g. #body)
  # Rack::BodyProxy does the same.
  def method_missing(*args, &block); end

  # Rack servers use +respond_to?+ to check for the presence of +close+
  # and +to_path+ methods.
  #
  # @return [Boolean]
  def respond_to?(m, include_all = T.unsafe(nil)); end

  # Some Rack servers can optimize response processing if it responds
  # to +to_path+ via the sendfile(2) system call, we proxy +to_path+
  # to the underlying body if possible.
  def to_path; end
end

# A Raindrops::Struct used to count the number of :calling and :writing
# clients.  This struct is intended to be shared across multiple processes
# and both counters are updated atomically.
#
# This is supported on all operating systems supported by Raindrops
class Raindrops::Middleware::Stats
  def initialize(*values); end

  def [](index); end
  def []=(index, value); end
  def calling; end
  def calling=(val); end
  def decr_calling; end
  def decr_writing; end
  def incr_calling; end
  def incr_writing; end
  def to_hash; end
  def writing; end
  def writing=(val); end

  private

  def initialize_copy(src); end
end

Raindrops::Middleware::Stats::MEMBERS = T.let(T.unsafe(nil), Array)
Raindrops::PAGE_SIZE = T.let(T.unsafe(nil), Integer)
Raindrops::SIZE = T.let(T.unsafe(nil), Integer)

# This is a wrapper around Raindrops objects much like the core Ruby
# \Struct can be seen as a wrapper around the core \Array class.
# It's usage is similar to the core \Struct class, except its fields
# may only be used to house unsigned long integers.
#
#   class Foo < Raindrops::Struct.new(:readers, :writers)
#   end
#
#   foo = Foo.new 0, 0
#
#   foo.incr_writers    -> 1
#   foo.incr_readers    -> 1
class Raindrops::Struct
  class << self
    # returns a new class derived from Raindrops::Struct and supporting
    # the given +members+ as fields, just like \Struct.new in core Ruby.
    def new(*members); end
  end
end
