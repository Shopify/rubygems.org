# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `toxiproxy` gem.
# Please instead update this file by running `bin/tapioca gem toxiproxy`.

class Toxiproxy
  extend ::SingleForwardable

  # @return [Toxiproxy] a new instance of Toxiproxy
  def initialize(options); end

  # Create a Toxiproxy, proxying traffic from `@listen` (optional argument to
  # the constructor) to `@upstream`. `#down` `#upstream` or `#downstream` can at any time alter the health
  # of this connection.
  def create; end

  # Destroys a Toxiproxy.
  def destroy; end

  # Disables a Toxiproxy. This will drop all active connections and stop the proxy from listening.
  def disable; end

  # Simulates the endpoint is down, by closing the connection and no
  # longer accepting connections. This is useful to simulate critical system
  # failure, such as a data store becoming completely unavailable.
  def down(&block); end

  # Set a downstream toxic.
  def downstream(type, attrs = T.unsafe(nil)); end

  # Enables a Toxiproxy. This will cause the proxy to start listening again.
  def enable; end

  # Returns the value of attribute enabled.
  def enabled; end

  # Returns the value of attribute listen.
  def listen; end

  # Returns the value of attribute name.
  def name; end

  # Set a downstream toxic.
  def toxic(type, attrs = T.unsafe(nil)); end

  # Set a downstream toxic.
  def toxicate(type, attrs = T.unsafe(nil)); end

  # Returns an array of the current toxics for a direction.
  def toxics; end

  # Set an upstream toxic.
  def upstream(type = T.unsafe(nil), attrs = T.unsafe(nil)); end

  private

  def assert_response(*args); end
  def http; end
  def http_request(request); end

  class << self
    # If given a regex, it'll use `grep` to return a Toxiproxy::Collection.
    # Otherwise, it'll convert the passed object to a string and find the proxy by
    # name.
    def [](query); end

    # Returns a collection of all currently active Toxiproxies.
    def all; end

    def assert_response(response); end
    def count(*args, **_arg1, &block); end

    # Convenience method to create a proxy.
    def create(options); end

    def down(*args, **_arg1, &block); end
    def each(*args, **_arg1, &block); end
    def ensure_webmock_whitelists_toxiproxy; end
    def find(*args, **_arg1, &block); end

    # Find a single proxy by name.
    def find_by_name(name = T.unsafe(nil), &block); end

    # Calls find_by_name and raises NotFound if not found
    #
    # @raise [NotFound]
    def find_by_name!(*args); end

    def grep(*args, **_arg1, &block); end

    # Sets the toxiproxy host to use.
    def host=(host); end

    def http; end
    def http_request(request); end
    def length(*args, **_arg1, &block); end
    def map(*args, **_arg1, &block); end
    def populate(*proxies); end
    def reject(*args, **_arg1, &block); end

    # Re-enables all proxies and disables all toxics.
    def reset; end

    def reset_http_client!; end

    # @return [Boolean]
    def running?; end

    def select(*args, **_arg1, &block); end
    def size(*args, **_arg1, &block); end
    def uri; end
    def version; end
  end
end

Toxiproxy::DEFAULT_URI = T.let(T.unsafe(nil), String)
class Toxiproxy::InvalidToxic < ::StandardError; end
class Toxiproxy::NotFound < ::StandardError; end

# ProxyCollection represents a set of proxies. This allows to easily perform
# actions on every proxy in the collection.
#
# Unfortunately, it doesn't implement all of Enumerable because there's no way
# to subclass an Array or include Enumerable for the methods to return a
# Collection instead of an Array (see MRI). Instead, we delegate methods where
# it doesn't matter and only allow the filtering methods that really make
# sense on a proxy collection.
class Toxiproxy::ProxyCollection
  extend ::Forwardable

  # @return [ProxyCollection] a new instance of ProxyCollection
  def initialize(collection); end

  def count(*args, **_arg1, &block); end

  # Destroys all toxiproxy's in the collection
  def destroy; end

  def disable; end

  # Sets every proxy in the collection as down. For example:
  #
  #   Toxiproxy.grep(/redis/).down { .. }
  #
  # Would simulate every Redis server being down for the duration of the
  # block.
  def down(&block); end

  # Set a downstream toxic.
  def downstream(toxic, attrs = T.unsafe(nil)); end

  def each(*args, **_arg1, &block); end
  def enable; end
  def find(*args, **_arg1, &block); end

  # Grep allows easily selecting a subset of proxies, by returning a
  # ProxyCollection with every proxy name matching the regex passed.
  def grep(regex); end

  def length(*args, **_arg1, &block); end
  def map(*args, **_arg1, &block); end
  def reject(&block); end
  def select(&block); end
  def size(*args, **_arg1, &block); end

  # Set a downstream toxic.
  def toxic(toxic, attrs = T.unsafe(nil)); end

  # Set a downstream toxic.
  def toxicate(toxic, attrs = T.unsafe(nil)); end

  # Set an upstream toxic.
  def upstream(toxic, attrs = T.unsafe(nil)); end
end

Toxiproxy::ProxyCollection::DEFINED_METHODS = T.let(T.unsafe(nil), Array)
Toxiproxy::ProxyCollection::DELEGATED_METHODS = T.let(T.unsafe(nil), Array)
Toxiproxy::ProxyCollection::METHODS = T.let(T.unsafe(nil), Array)
class Toxiproxy::ProxyExists < ::StandardError; end

class Toxiproxy::Toxic
  # @return [Toxic] a new instance of Toxic
  def initialize(attrs); end

  def as_json; end

  # Returns the value of attribute attributes.
  def attributes; end

  # Sets the attribute attributes
  #
  # @param value the value to set the attribute attributes to.
  def attributes=(_arg0); end

  def destroy; end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute proxy.
  def proxy; end

  def save; end

  # Returns the value of attribute stream.
  def stream; end

  # Returns the value of attribute toxicity.
  def toxicity; end

  # Sets the attribute toxicity
  #
  # @param value the value to set the attribute toxicity to.
  def toxicity=(_arg0); end

  # Returns the value of attribute type.
  def type; end
end

class Toxiproxy::ToxicCollection
  extend ::Forwardable

  # @return [ToxicCollection] a new instance of ToxicCollection
  def initialize(proxies); end

  def <<(*args, **_arg1, &block); end
  def apply(&block); end
  def downstream(type, attrs = T.unsafe(nil)); end
  def find(*args, **_arg1, &block); end

  # Returns the value of attribute proxies.
  def proxies; end

  def toxic(type, attrs = T.unsafe(nil)); end
  def toxicate(type, attrs = T.unsafe(nil)); end

  # Returns the value of attribute toxics.
  def toxics; end

  # Sets the attribute toxics
  #
  # @param value the value to set the attribute toxics to.
  def toxics=(_arg0); end

  def upstream(type, attrs = T.unsafe(nil)); end
end

Toxiproxy::VALID_DIRECTIONS = T.let(T.unsafe(nil), Array)
